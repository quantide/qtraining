---
output:
  html_document
---

As _John Chambers_ said:

* Everything that exists is an object.
* Everything that happens is a function call.

`R` provides a set of specialized  structures reffered as _objects_. These structures provide access to the data stored in memory. We refer to this structures throught symbols (variables).


## Symbols
In practice, a symbol is the name we assign to any object in `R`.

Therefore, when we write:

```{r}
x <- 0 
```

the name `x` is binded to the value `0`.

Symbols in R may be made of lower or capital letters, numbers and the special characters `"."` and `"_"`. Almost any rule is a valid one when defining a symbol

```
x <- 0 
x0 <- 0 
x_0 <- 0 
x.0 <- 0
.x <- 0 
```

Standard symbols cannot start with a number or a `"_"`. Any name staring with a `"."` is a hidden name meaning that it is not returned by a call to `ls()` unless argument `all.names` is set to `TRUE`.

```{r howRworks-013, echo=FALSE, results='hide'}
remove(list = ls())
```

```{r howRworks-014}
.x <- 0
ls()
ls(all.names = TRUE)
```


## Expressions

Expressions are a set of one or more valid parsed, but not yet evaluated, `R` statements.

```{r}
expr <- expression ({x <- 1+1; y <- 2})
```

Expressions have their own class and storage mode:

```{r}
class(expr)
typeof(expr)
```

Expressions are stored in an R object that can be explored as standard list objects.


```{r howRworks-004}
expr <-  expression (1 + 1)
class(expr)
as.list(expr)
as.list(expr[[1]])
```

and even manipulated as standard list objects

```{r howRworks-005}
expr[[1]][[1]] <- `-`
as.list(expr)
```

Expressions can be generate starting from text strings by mean of function `parse()`:

```{r}
expr <- parse(text = "x <- 0")
class(expr)
```

Function `parse()` returns the parsed but unevaluated expressions in a list.

## Environments 

The _environment_ definition is clearly stated by in _R Language Definition_ manual:

Environments can be thought of as consisting of two things. 

* A frame, consisting of a set of symbol-value pairs, 
* An enclosure, a pointer to an enclosing environment. 

Given that a frame is a set of objects each of them associated to a name, we can consider an environment as a self contained portion of memory containing a frame. Each environment can access one and only one other environment known as the parent environment. 

Environments in `R` are created, and eventually destroyed, under many circumstances. 

Any `R` session has an environment associated known as the _global environment_. as returned by functions `globalenv()` and `environment()`:

```{r environments-001}
globalenv()
environment()
```

When we are working with `R` in interactive mode, we are using the frame within the `globalenv` as a _container_ for our objects:

```{r environments-002}
x <- 0
ls.str(globalenv())
```

Any package has at least one environment: 

```{r environments-003}
as.environment("package:stats")
```

Almost all functions have an environment as part of their definition:

```{r}
environment(mean)
```

User defined functions have an environment too:

```{r}
f <- function() NULL
environment(f)
```

Function `environmentName()` returns the name of an environment. As a result we may query `R` for the environment of function `f()`:

```{r environments-006}
environmentName(environment(f))
```

or for the name of the environment associated to a package:

```{r environments-006A}
require("MASS", quietly = T)
environmentName(as.environment("package:MASS"))
```

Unfortunately, function `environmentName()` does not always return the expected results:

```{r environments-006B}
env <- new.env()
environmentName(env)
```

Environment names for packages and namespaces are assigned at the `C` level. Therefore, user created environments do not reveal names. Users cannot set the name of an environment in `R` even through a, possibly misleadingly named, function called `environmentName()` exists. This function is really only meant for packages and namespaces, not other environments.

As environments are standard `R` objects, environments can be created:

```{r environments-023}
env <- new.env()
```

and eventually deleted:

```{r environments-023A, eval = FALSE}
rm(env)
```

The `frame` component of an environment can be used as an objects place holder almost as we do with lists. We can place objects within an environment at least in three different ways:

by using the `$` operator:

```{r environments-024}
env$zero <- 0
```

by using function `with()`:

```{r environments-025}
with(env , one <- 1)
```

by using function assign:

```{r environments-026}
assign("three", 3, envir  = env)
```

Finally, we can browse environment `env` with standard functions `ls()` or `ls.str()` to check our result:

```{r environments-027}
ls(env)
ls.str(env)
```

The definition of environment also states that an environment is made of an enclosure: a pointer to an enclosing environment. As a consequence, any environment has a parent environment.

Function `parent.env()` returns the parent environment of an environment:

```{r}
parent.env(globalenv())
```

If we create a new environment:

```{r}
env <- new.env()
```

this environment has a parent by definition:

```{r}
parent.env(env)
```

By default, the parent of an environment is the environmnt where the environment is created. This explains because the parent of `env` is the global environment.

Nevertheless, we can create an environment with a different parent from the default one by using the `parent` argument of function `new.env()`:

```{r}
env1 <- new.env()
env2 <- new.env(parent = env1)
identical(env1, parent.env(env2))
```


<!----
parent.frame == sys.frame(sys.parent(1)) 

.GlobalEnv is given number 0 in the list of frames. 
Each subsequent function evaluation increases the frame stack by 1 and the 

call == sys.call 
function definition == sys.function 
and the environment for evaluation of that function == sys.frame 

sys.parent returns the number of the parent frame if n is 1 (the default), the grandparent if n is 2, and so on. See also the ‘Note’
--->

## Evaluaton 

<!--- AS add reference to R for bioinformatic --->

Computer languages provide a level of abstraction that allows programmers, and users, the ability to express certain ideas symbolically. 

In many cases the symbolic statements constitute a program, or a function that may be evaluated many times, with potentially different inputs. 

In other cases, with interactive languages such as `R`, users will type statements directly in the evaluator and immediately see the consequences of their commands. 

In this section we consider the process of evaluating statements in R. 

Since evaluation is a major component of computer use, it is essential that programmers both understand the model that is used in any language and that they be able to control the evaluation process to reliably get the intended answers.

Because of the way `R` works, evaluating expressions is, except few exceptions, about evaluating functions calls. This is clearly true when we call any a standard function in `R` as:

Function `eval()` evaluates an `R` expression specified by its `expr` argument in the environment specified by it argument `envir`.

As an example let's consider an object `x` that takes `0` in the global environment and `exp(1)` in a newly created environment `env`:

```{r}
x <- 1
env <- new.env()
env$x <- exp(1)
```

and an expression `log(x)` 

```{r}
expr <- expression(log(x))
```

Expression `log` when evaluated in the global environment returns `0`:

```{r}
eval(expr, env = globalenv())
```

when evaluated in environment `env` returns `1`: 

```{r}
eval(expr, env = env)
```

Because of the way `R` works, evaluating expressions is, except few exceptions, about evaluating functions calls. This is clearly true when we call any a standard function in `R` as:

```{r howRworks-007, eval = FALSE}
mean(x = 1:10) 
```

but, this is also true when we write any assignment statement. In fact `R` translates:

```{r howRworks-008, eval = FALSE}
x <- 0
```

into a function call:

```
`<-`(x, 0)
```

and even a conditional construct such as:

```{r howRworks-009}
if ( pi > 0) 1 else  0
```

translates into a call to a function

```
`if`( pi > 0 , 1 , 0)
```

The evaluation mechanism has at least three exceptions: 

* constants
* names 
* promises:


Constants in `R` are evaluated into themselves independently of the environment they are evaluated in. Any expression as:

```{r howRworks-010}
1
```

is the evaluation of a constant:

```{r}
eval(0, env = globalenv())
eval(1, env = new.env())
```

while

```{r howRworks-011}
-1
```

turns into a call to a function:

```
`-`(1)
```

More on how `R` evaluates function in the chapter dedicated to functions

Evaluating a names or symbol is about getting the value binded to that name in the specified environment. Possibly the global environment:

```{r}
x <- 0
name <- as.name("x")
eval(expr = name )
````

or any other environment:

```{r}
env <- new.env()
env$x <- 1
eval(expr = name , env = env)
```


A promise is an `R` object made of two components:

* An expression giving the delayed computation
* The environment where the expression was created 
* The environment where it should be evaluated


The importance of promises evaluation will be become clear in the chapter dedicated to function. During the use of `R` interactively, we can take advantage of function `delayedAssign()` that simulate the behaviour of a promise.

We can create a promise in the global environment that executes in the same environment:


```{r}
delayedAssign("promise", x+y, eval.env  =  globalenv(), assign.env = globalenv() )
```

We than define `x` and `y`

```{r}
x <- 1
y <- 2
````

finally we evaluate the promise

```{r}
eval(promise)
```

Suppose we now change the value of `x` and `y`

```{r}
x <- 2
y <- 3
````

and evaluate the promise again:

```{r}
eval(promise)
```


the promise evaluation does not reflects the changes in `x` and `y`. 

This happens as when the promise is eventually evaluated, it is evaluated within the environment specified by eval.env. After that, the value is fixed and the expression will not be evaluated again.

As a more sophisticated example we may consider a promise created in an environment and evaluated in a second environment:

The delayed assignemnt mechanism keeps working  


```{r}
rm(list = ls())
env <- new.env()
env$y <- 2
x <- 3
delayedAssign("promise", x+y, eval.env  = env, assign.env = globalenv() )
eval(promise)
```

and the promise will not eavaluate again:

```{r}
env$y <- 0
eval(promise)
```

## The _''read parse evaluate''_ loop

The _''read parse evaluate''_ loop is at the core of the  `R` system. Understanding this mechanism and being able to manage and control it is a key point for writing efficient `R` codes.

When we type `R` commands, two things happen:

 * those characters are parsed into an `R` expression 
 * the expression is then evaluated by the internal evaluator
 
This process, known as the  _''read parse evaluate''_ loop, is internally performed by the `R` system but, the same process is available to the end user by mean of two functions: `parse() ` and `eval()` .

Effectively, when typing any `a <-  1`, what happens is

```{r howRworks-001}
eval(parse (text = "a <-  1"))
```

The inner parse section returns an object of class `expression` and afterward the expression is evaluated by the evaluator. 

When we call functions `eval()` and `parse()` directly, we generally pass character strings as arguments to the  `parse()` function  either from quoted text strings or external files

```{r howRworks-002}
parse(text = "a <- 1")
```

```{r howRworks-003, eval=FALSE}
parse(file = './input.R')
```




When we ask `R` to evaluate a symbol, `R` looks for the value associated to that symbol, first in the current environment and, in case the symbol is not found within current environment, `R` looks progressively in all the parents environments until the object value is returned or an error occurs as the symbol is not found. This key idea will be fully discussed in the chapter dedicated to environments.


## Assignment

When typing `a = 1` at the command prompt, the value `1` in assigned to the symbol `a`. The `=` operator is used to perform the assignment. In fact, `R` provides three operators for assignments: `=`, `<-` and `<<-` the last two being bi-directional.

Operators `=` and `<-` assign into the environment in which they are evaluated. Therefore, at the command prompt `a = 1` is equivalent to `a <- 1`. 

When an assignment is done on formal parameter lists within functions calls, assignment is performed in the environment where the function is evaluated if the `=` operator is used while the same assignment occurs in the local environment in case the of the `<-` operator. As a simple example, we can consider a simple call to any function i.e. `median()`. 
First we clean up our workspace:

```{r howRworks-015}
rm(list = ls())
```

Then we call `median()` using both `=` and `<-` operators for parameters assignement:

```{r howRworks-016}
median(x = 1:10)
exists("x")
median(x <- 1:10)
exists("x")
x
```



In practice, the way the evaluator understands assignment is:

```{r howRworks-017}
'='(a, 1)
a
'<-'(b, 2)
b
```

`R` supports multiple assignments with both operators.

```{r howRworks-018}
x = xx = 1
y <- yy <- 0 
c(x, xx, y, yy)
```

Attention should be paid as:
  
```{r howRworks-019}  
k = p <- 0  
c(k, p)
```

works correctly but: 

```{r howRworks-020, eval=FALSE}
k <- p = 0  
```

returns an error. This happens as 

`k = p <- 0`  translates to  `'='(k,'<-'(p, 0))` 

while 

`k <- p = 0` is interpreted as `'='('<-'(k, p), 0)` 

as the `<-` operator takes precedence on the `=` operator.

Finally, operator `<<-` is used to assign into the parent environment. As an example consider:
  
```{r howRworks-021}
env <-new.env()  
parent.env(env) 
with(env, x <<- 8)
```

In this case the assignment `x = 8` is performed within the parent frame of `env`, that is `R_GlobalEnv`. Thus:

```{r howRworks-022}
ls(env = env)
```

does not show any  `x` symbol while `x` is still available in `env`:

```{r howRworks-023}
get("x", env = env)
```

as, since the evaluator does not find `x` in the local frame, it looks for `x` in the parent frame. In fact:

```{r howRworks-024}
x
```

## Removing objects

To remove objects, the function `rm()` can be used. The function `remove()` may be considered as an alias for the `rm()` function.

As seen above, `ls()` returns a vector containing all objects in the current environment. To remove all objects in the current environment, all you need is

```{r howRworks-025}
rm(list = ls())
ls()
```

Of course, the `list` argument can contain any character vector with object names.

```{r howRworks-026}
x <- 1; y <- 2; z <- 3
ls()
rm(list = c("x", "y", "z"))
ls()
```

When argument are not already in a vector, they can be passed directly:

```{r howRworks-027}
x <- 1; y <- 2; z <- 3
ls()
rm("x", "y", "z")
ls()
```

When arguments are passed directly, and not in the character vector `list`, it is not mandatory to quote them.

```{r howRworks-028}
x <- 1; y <- 2; z <- 3
ls()
rm(x, y, z)
ls()
```


## Garbage collection

When objects are no longer used, and this clearly happens when objects are deleted. `R` releases immediately the memory they filled in the system. This is done automatically by the garbage collector `gc()`.

We can call `gc()` to see how much memory `R` is using for allocating objects

```{r howRworks-029}
gc()
```

and as a proof, we can create `100x10^7` elements matrix

```{r howRworks-030}
n <- 100*10^7
big_matrix <-  matrix(1:n, ncol = 100)
```

and check how much memory `R` is using:

```{r howRworks-031}
gc()
```

The increase of memory usage is related to the newly created matrix that takes:

```{r howRworks-032}
print(object.size(big_matrix), units = "Gb")
```

When this matrix is removed, the memory is immediately released to the operating system. 

```{r howRworks-033}
rm(big_matrix)
gc()
```


```{r}
rm(list = ls())

mem_available <- function(){
  mem_available <- system("cat /proc/meminfo | grep MemAvailable", intern = T )
  mem_available <- sub("^\\s+", "", strsplit(mem_available, "\\s+")[[1]][2])
  mem_available <- as.numeric(mem_available) * 1024
  class(mem_available) <- "object_size"
  mem_available
}

gc()
format(mem_available(), "Gb")

X <- matrix(1:10^9, ncol = 10^4)

format(mem_available(), "Gb")

gc()

format(mem_available(), "Gb")

rm(X)

format(mem_available(), "Gb")

gc()


format(mem_available(), "Gb")


```

<!---
## References
Ref: http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/
Ref: http://yihui.name/knitr/options
--->



