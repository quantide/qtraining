---
title: "Base programming in R"
---

## Conditionals in R

### The `if` statement
Conditionals are very useful when programming, as they allow to execute some code when a condition is satisfied.

The `if` statement is the most used conditionals. Its use is quite simple:

```{r if0, eval = FALSE}
if(condition) code to be executed
```

The condition ought be a lenght-one logical vector. Conditions of length greater than one are accepted with a warning, but only the first element is used. If condition is `TRUE` then the code is executed.
```{r if}
x <- 2
if (x > 0) print("x greater than zero")
```

The code above print the text, because the condition is satisfied. When the condition is false, the code is ignored.
```{r iffalse}
x <- -4
if (x > 0) print("x greater than zero")
```

When condition is longer than a one line of code, the code to be executed ought be enclosed in braces (`{...}`). 
```{r ifline}
x <- 2
if (x > 0) {
  print("x greater than zero")
  return(x)
}
```

The `if` statement allows an `else` condition that will be executed when the condition is false.
```{r else0, eval=FALSE}
if(condition) code-when-true else code-when-false
```

As an example:
```{r ifelse}
x = -4
if (x > 0) print("x greater than zero") else print("x is not greater than zero")
```

In this case, it is strongly suggested to always use braces.
```{r ifelsebraces}
x <- -4
if (x > 0) {
  print("x greater than zero")
} else {
  print("x is not greater than zero")
}
```

Of course, the `if` statement can be used to assign values to an object.
```{r ifassignement}
x <- -4
if (x > 0) {
  y <- 1
} else {
  y <- -1
}
y
```

### The `ifelse()` function

As seen above, the `if` statement applies only to a length-one logical vector. If applied to vectors with length greater than one, only the first element is used and a warning message is returned. 

```{r structures-008}
if(x < 5){"LESS"} else {"GREATER"}
```

The `ifelse()` function allows us to deal with vectors of any length. Its arguments are: a test condition, a return value when the test returns TRUE, a return value when the test returns FALSE.

```{r structures-009}
x = 1:10
ifelse(x < 5, "LESS", "GREATER")
```

Moreover, the `ifelse()` function return a vector, so it can be assigned to an object.
```{r ifelsefunction}
x <- -4
y <- ifelse(x > 0, 1, -1)
y
```

### Select one of a list of alternatives: `switch`

The `switch()` function evaluates an expression and accordingly chooses one of the further arguments. It is usually used inside a function to select from a list of alternatives.

The following code, provide a self-written `centre()` function, that accepts two input arguments: a numeric vector and a centroid function  (mean, median, trimmed mean) to be applied to the numeric vector.

The `switch` read the string with the centroid function (`type`) and applies the accordingly function.

```{r switch, tidy=FALSE}
centre <- function(x, type) {
  switch(type,
    mean = mean(x),
    median = median(x),
    trimmed = mean(x, trim = .1)
  )
}
```

```{r centre, echo=2:100}
set.seed(355)
x <- rcauchy(10)
centre(x, "mean")
centre(x, "median")
centre(x, "trimmed")
```



## Loops in R

### `for` loops

`for` loops, as any other iterators, are common components of almost any programming language. The common structure of a `for` loop in `R` is:
```{r programming-for-01}
languages <- c("C", "C++", "R", "Java", "Python")
for(lang in languages) {
  cat("I love ", lang, "\n")

}
```

or alternatively:
```{r programming-for-02}
languages <- c("C", "C++", "R", "Java", "Python")
n <- length(languages)
for(i  in 1:n) {
  cat("I love ", languages[i], "\n")

}
```


### Good programming practices with `for` loops

#### Pre-allocating memory

`for` loops, as any equivalent iterator structure may require quite a long time to complete. Long computing time is quite natural as computational effort linearly increases with the number of iterations in the loop. 

Nevertheless, few little cautions may help to save a sensible amount of time.

As an example, we may calculate the `95%` quantile of the distribution of the correlation coefficient between two `N(0,1)` vectors of given sizes `n=10` by using a simple for loop over `k = 100,000` iterations.

```{r programming-for-03, include =FALSE}
rm(list = ls())
g = gc()
```

```{r programming-for-04, cache=TRUE}
k = 100000
n = 10
z = NULL 
system.time({
    for (i in 1:k) {
    x = rnorm(n , 0, 1)
    y = rnorm(n , 0, 1)
    z = c(z , cor(x, y))
  }
  cat ("95th quantile = " , quantile(z , .95), "\n")
})[3]
```

We can gain a first improvement by _'pre-allocating'_, the vector of results, We tell `R` what the size of the vector is before we begin filling it up. The wrong way to fill in a vector is to allow it to grow dynamically as it happens in the above loop. 

In the above case, R has to store a vector of one element than a second vector of two elements and so on up to a vector of `100,000` elements. As each new vector can't fit inside the RAM allocated to the previous vector, R has to use a  ''new'' bit of contiguous RAM for new vector. 

Thus, instead of using just one chunk of RAM that it takes to make a vector of `k=100,000` and filling it up with one more element at each iteration, R is forced to write the new enlarged vector in Ram at each iteration. Clearly, all of this memory writing takes up time.

Fortunately, R has a quite efficient mechanism for garbage collection and, as a result, memory usage is kept under control. Otherwise, looping without _pre-allocating_ may also cause serious memory usage problems.

Running the previous example, by simply pre-allocating vector `z` before looping, reduces computing time to about half of the previous time. 

```{r programming-for-05, cache=TRUE}
k = 100000
n = 10
z = numeric(k)
system.time({
  for ( i in 1:k){
    x = rnorm(n , 0, 1)
    y = rnorm(n , 0, 1)
    z[i] = cor(x, y)
  }
  cat ("95th quantile = " , quantile(z , .95), "\n")
})[3]
```

Clearly, pre-allocation requires to know in advance the size of the output vector. Whenever this is not possible, as it may happen in while loops, computing time may noticeably increase.

#### Vectorized `for` loops

Whenever possible, loops should be replaced with vectorized calculation. This approach improve both performance and clarity.

As an example, we examine a double for loop:

```{r structures-006, cache=TRUE}
slow =  function(x, y) {  
  nx = length(x)
  ny = length(y)  
  xy = numeric(nx + ny - 1)  
  
  for(i in 1:nx) {  
         for(j in 1:ny) {  
              ij = i+j-1  
              xy[ij] = xy[ij] + x[i] * y[j]  
          }  
      }  
      xy  
}  


system.time(slow(runif(1000), runif(1000)))[3]
```

An attempt to vectorize the previous code leads to:

```{r structures-007, cache=TRUE}
fast =  function(x, y) {  
  nx = length(x)
  ny = length(y)  
  xy = numeric(nx + ny - 1)  
  j = 1:ny
  for(i in 1:nx) {  
              ij = i+j-1  
              xy[ij] = xy[ij] + x[i] * y  
      }  
      xy  
}
system.time(fast(runif(1000), runif(1000)))[3]
```

Simply working with vectorized dimensions drastically reduce computing time. Note that `j` index is computed within the `i` loop  and that `y[j]` has been replaced with `y`, as a result, a single for loop is required.


### `while` loops

`for` loops apply when the number of loops is known. Sometimes, one wants to loop until a condition is satisfied. In this case, the `while` statement should be used. Its use is quite simple:
```
while(condition) code-to-be-execute
```

If the code is more than one row long, than it must be placed between braces (`{...}`).

The following code, generates random numbers from a Normal Distribution and stops when a value greater than 2 is obtained. The number is assigned to `x` and a message with the number of loops is printed.

```{r programming-while, echo=2:100}
set.seed(355)
n <- 0
x <- 0
while(x <= 3) {
  x <- rnorm(1)
  n <- n + 1
}
cat(n, "loops were executed")
```
