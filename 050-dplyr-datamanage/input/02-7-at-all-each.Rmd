---
title: "Each, At, All"
---

```{r options, include=FALSE, purl=FALSE}
options(width = 108)
```

```{r first, include=TRUE, purl=TRUE, message=FALSE}
# load packages and data
require(tidyverse)
require(qdata)
data(mtcars)
```

# Controlling `dplyr`

When using `dplyr` to manipulate data, you have three factors to control:

1. how many variables to manipulate
2. how many functions to apply to each variable 
3. the length of functions results 

In more details:

1. how many variables to manipulate:
  + 1A. single variable
  + 1B. more than a variable 

2. how many functions to apply to each variable :
  + 2A. single function  
  + 2B. more than one function 

3. the length of functions results :
  + 3A. a single value: i.e. `mean()`, `max()`, `min()`, etc ... 
  + 3B. `n` values: i.e. `order()`, `rescale()`, etc ...

For a totale result of eigth cases.

<!--------------------- res == 1 ------------------------------------>
## Functions Returning Results of Length One

There are four cases:

* case 1: apply one function to one variable
* case 2: apply many functions to one variable
* case 3: apply one function to many variables
* case 4: apply many functions to many variables

We will test them by using three `dplyr` verbs:

1. `summarise()`
2. `summarise_each()`
3. `summarise_at()`

We will also test them under the three options provided by the `group_by()` verb: 

A.  `group_by()` is not used group: no groups 
B.  `group_by(g)` is used on a single variable: one group 
C.  `group_by(g1, g2, ..., gk)` is used on more than one variables: many groups 

For a total of $8 \times 3 = 24$ tests.


### Case 1: Apply One Function to One Variable

In this case, `summarise()` results the simplest candidate:

```{r}
# without groups
mtcars %>% 
  summarise(mean_mpg = mean(mpg))

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise(mean_mpg = mean(mpg))

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise(mean_mpg = mean(mpg))
```

You could use function `summarise_each()` as well, but its usage results in a loss of clarity:

```{r}
# without groups
mtcars %>% 
  summarise_each(funs(mean), mean_mpg = mpg)

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise_each(funs(mean), mean_mpg = mpg)

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise_each(funs(mean), mean_mpg = mpg)
```

You may also instead use the function `summarise_at()`:

```{r}
# without groups
mtcars %>% 
  summarise_at(vars(mean_mpg = mpg), funs(mean))

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise_at(vars(mean_mpg = mpg), funs(mean))

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise_at(vars(mean_mpg = mpg), funs(mean))
```

Notice that, opposite to `summarise_each()`, in `summarise_at()` the first argument refers to the set of selected variables and the second argument refers to the set of functions to be applied.


### Case 2: Apply Many Functions to One Variable

In this case you can use both functions `summarise()` and `summarise_each()`.  

Function `summarise()` has a more intuitive syntax:

```{r}
# without groups
mtcars %>% 
  summarise(min_mpg = min(mpg), max_mpg = max(mpg))

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise(min_mpg = min(mpg), max_mpg = max(mpg))

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise(min_mpg = min(mpg), max_mpg = max(mpg))
```

The names of the output variables can be easily specified as follows: `max_mpg = max(mpg)`.

When you apply many functions to one variable, the use of `summarise_each()` provides a more compact and tidy notation:

```{r}
# without groups
mtcars %>% 
  summarise_each(funs(min, max), mpg)

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise_each(funs(min, max), mpg)

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise_each(funs(min, max), mpg)
```

The default names of the output variables are given by the names of the functions: `min` and `max`.

In this case you lose track of the name of the variable the functions are applied to.

If you prefer something like `min_mpg` and `max_mpg`, you shall appropriately rename the __functions__ you call within `funs()`:

```{r}
# without groups
mtcars %>% 
  summarise_each(funs(min_mpg = min, max_mpg = max), mpg)

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise_each(funs(min_mpg = min, max_mpg = max), mpg)

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise_each(funs(min_mpg = min, max_mpg = max), mpg)
```

Alternatively to the function `summarise_each`, you can use `summarise_at`:

```{r}
# without groups
mtcars %>% 
  summarise_at(vars(mpg), funs(min_mpg = min, max_mpg = max))

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise_at(vars(mpg), funs(min_mpg = min, max_mpg = max))

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise_at(vars(mpg), funs(min_mpg = min, max_mpg = max))
```



### Case 3: Apply One Function to Many Variables

This case is very similar to case 2. Functions `summarise()`, `summarise_at()` and `summarise_each()` can be used.

Function `summarise()` has again a more intuitive syntax and the names of output variables can be specified in the usual simple form: `max_mpg = max(mpg)`.

```{r}
# without groups
mtcars %>% 
  summarise(mean_mpg = mean(mpg), mean_disp = mean(disp))

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise(mean_mpg = mean(mpg), mean_disp = mean(disp))

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise(mean_mpg = mean(mpg), mean_disp = mean(disp))
```

When you apply one function to many variables, the use of `summarise_each()` provides a more compact and tidy notation:

```{r}
# without groups
mtcars %>% 
  summarise_each(funs(mean), mpg, disp)

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise_each(funs(mean), mpg, disp)

# with  more than group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise_each(funs(mean), mpg, disp)
```

The default names of the output variables are given by the names of the variables: `mpg` and `disp`.

In this case you lose track of the name of the function applied to the variables.

If you prefer something like `mean_mpg` and `mean_disp`, you shall appropriately rename the __variables__ you pass to `...` within `summarise_each()`:

```{r}
# without groups
mtcars %>% 
  summarise_each(funs(mean), mean_mpg = mpg, mean_disp = disp)

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise_each(funs(mean), mean_mpg = mpg, mean_disp = disp)

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise_each(funs(mean), mean_mpg = mpg, mean_disp = disp)
```


Alternatively you may use the function `summarise_at` and you appropriately rename the __variables__ you pass to `...` within `summarise_at()`:

```{r}
# without groups
mtcars %>% 
    summarise_at(vars (mean_mpg = mpg, mean_disp = disp), funs(mean))

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise_at(vars(mean_mpg = mpg, mean_disp = disp), funs(mean))

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise_at(vars(mean_mpg = mpg, mean_disp = disp), funs(mean))
```

If you want to apply a function to all of your variables, for example you want to calculate the mean of all numeric variables in your dataset, a quick way for doing it is to use the function `summarise_all()`:

```{r}
# without groups
mtcars %>% 
  select_if(is.numeric) %>%
  summarise_all(mean)

# with one group
mtcars %>% 
  select_if(is.numeric) %>%
  group_by(cyl) %>% 
  summarise_all(mean)

# with more than one group
mtcars %>% 
  select_if(is.numeric) %>%
  group_by(cyl, carb) %>% 
  summarise_all(mean)
```

Notice that the default names of the output variables are given by the names of the variables: `carb`, `cyl`, `mpg` and `disp`. Hence you lose track of the name of the function applied to the variables. In order to change the default variables names you need an additional command:

```{r}
# without groups
mtcars %>% 
  select_if(is.numeric) %>%
  summarise_all(mean) %>%
  setNames(c("mean_cyl", "mean_carb", "mean_mpg", "mean_disp"))

# with one group
mtcars %>% 
  select_if(is.numeric) %>%
  group_by(cyl) %>% 
  summarise_all(mean) %>%
  setNames(c("mean_cyl", "mean_carb", "mean_mpg", "mean_disp"))

# with more than one group
mtcars %>% 
  select_if(is.numeric) %>%
  group_by(cyl, carb) %>% 
  summarise_all(mean) %>%
  setNames(c("mean_cyl", "mean_carb", "mean_mpg", "mean_disp"))
```



### Case 4: Apply Many Functions to Many Variables

As in the previous cases functions `summarise()`, `summarise_each()`  and `summarise_at()` provide a valid alternative.

Function `summarise()` has again a more intuitive syntax and the names of output variables can be specified in the usual simple form: `max_mpg = max(mpg)`. 

```{r}
# without groups
mtcars %>% 
  summarise(min_mpg = min(mpg), min_disp = min(disp), max_mpg = max(mpg), max_disp = max(disp))

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise(min_mpg = min(mpg), min_disp = min(disp), max_mpg = max(mpg), max_disp = max(disp))

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise(min_mpg = min(mpg), min_disp = min(disp), max_mpg = max(mpg), max_disp = max(disp))
```

When you apply many functions to many variables, the use of `summarise_each()` provides a more compact and tidy notation:

```{r}
# without groups
mtcars %>% 
  summarise_each(funs(min, max), mpg, disp)

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise_each(funs(min, max), mpg, disp)

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise_each(funs(min, max), mpg, disp)
```

The names of the output variables are given by the notation `variable_function`, i.e. `mpg_min`, `disp_min`, etc.

Naming output variables with a different notation, i.e. `function_variable`, does not appear to be possible within the call to `summarise_each()`.

This goal has to be achieved with a separate instruction:

```{r}
# without groups
mtcars %>% 
  summarise_each(funs(min, max), mpg, disp) %>%
  setNames(c("min_mpg", "min_disp", "max_mpg", "max_disp"))

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise_each(funs(min, max), mpg, disp) %>%
  setNames(c("cyl", "min_mpg", "min_disp", "max_mpg", "max_disp"))

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise_each(funs(min, max), mpg, disp) %>%
  setNames(c("cyl", "carb", "min_mpg", "min_disp", "max_mpg", "max_disp"))
```

An alternative to `summarise_each()` is  `summarise_at()`.

```{r}
# without groups
mtcars %>% 
  summarise_at(vars(mpg, disp), funs(min, max))

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise_at(vars(mpg, disp), funs(min, max))

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise_at(vars(mpg, disp), funs(min, max))
```

As for `summarise_each`, the names of the output variables are given by the notation `variable_function`, i.e. `mpg_min`, `disp_min`, etc.

Naming output variables with a different notation has to be achieved with a separate instruction:

```{r}
# without groups
mtcars %>% 
  summarise_at(vars(mpg, disp), funs(min, max)) %>%
  setNames(c("min_mpg", "min_disp", "max_mpg", "max_disp"))

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise_at(vars(mpg, disp), funs(min, max)) %>%
  setNames(c("cyl", "min_mpg", "min_disp", "max_mpg", "max_disp"))

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise_at(vars(mpg, disp), funs(min, max)) %>%
  setNames(c("cyl", "carb", "min_mpg", "min_disp", "max_mpg", "max_disp"))
```

Last, suppose you want to apply many functions to all of you variables. For example you may want to calculate the mean and the standard deviation of all the numeric variables in your dataset. A quick way of doing it is to use the function `summarise_all()`:

```{r}
# without groups
mtcars %>% 
  select_if(is.numeric) %>%
  summarise_all(c("mean","sd"))

# with one group
mtcars %>% 
  select_if(is.numeric) %>%
  group_by(cyl) %>% 
  summarise_all(c("mean","sd"))

# with more than one group
mtcars %>% 
  select_if(is.numeric) %>%
  group_by(cyl, carb) %>% 
  summarise_all(c("mean","sd"))
```

The default output variables names are `variable_function`. If you want to change them, you need to specify the new names with an additional command:

```{r}
# without groups
mtcars %>% 
  select_if(is.numeric) %>%
  summarise_all(c("mean","sd")) %>%
  setNames(c("mean_cyl", "mean_carb", "mean_mpg", "mean_disp", "sdev_cyl", "sdev_carb", "sdev_mpg", "sdev_disp"))

# with one group
mtcars %>% 
  select_if(is.numeric) %>%
  group_by(cyl) %>% 
  summarise_all(c("mean","sd")) %>%
setNames(c("cyl", "mean_carb", "mean_mpg", "mean_disp",  "sd_carb",  "sd_mpg",  "disp_sd"))

# with more than one group
mtcars %>% 
  select_if(is.numeric) %>%
  group_by(cyl, carb) %>% 
  summarise_all(c("mean","sd")) %>%
  setNames(c("cyl","carb","mean_mpg", "mean_disp", "sdev_mpg", "sdev_disp"))
```




<!--------------------- res == n ------------------------------------>

## Functions Returning Results of Length `n`

Also here there are four cases: 

* Case 5: apply one function to one variable
* Case 6: apply many functions to one variable
* Case 7: apply one function to many variables
* Case 8: apply many functions to many variables

We will test them by using two `dplyr` verbs:

1. `mutate()`
2. `mutate_each()`
3. `mutate_all()`

Each of them tested under the three options provided by the `group_by()` verb: 

A.  `group_by()` is not used: no groups 
B.  `group_by(g)` is used on a single variable: one group 
C.  `group_by(g1, g2, ..., gk)` is used on more than one variables: many groups 

For a total of $8 \times 3 = 24$ tests.


### The Value of `n`

The `group_by()` option has an impact on the value of `n`:

* when there is no group variable `n` is the number of records in the whole data frame:

```{r}
mtcars %>% summarise(n = n())
```

* when there is one group variable `n` is the number of records within each level of the group variable:

```{r}
mtcars %>% group_by(carb) %>% summarise(n = n())
```

* when there are many group variables `n` is the number of records within each combination of levels of group variables:

```{r}
mtcars %>% group_by(carb, cyl) %>% summarise(n = n())
```

For the next examples we will use two functions: 

* `order()`: as from base `R` 
* `rescale()`: defined as:

```{r}
rescale <- function(x){
  x <- x - min(x, na.rm = TRUE)
  x/max(x)
}
```

Both functions take `x` of length `n` as input and return a new vector of length `n`. 


### Case 5: Apply One Function to One Variable

As you expect results of length `n`, function `mutate()` is the candidate function:

```{r}
# without groups
mtcars %>% 
  mutate(rescale_mpg = rescale(mpg))

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate(rescale_mpg = rescale(mpg)) 

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate(rescale_mpg = rescale(mpg))
```

You could use function `mutate_each()` as well, but its usage results in a loss of clarity:

```{r}
# without groups
mtcars %>% 
  mutate_each(funs(rescale), rescale_mpg = mpg)

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_each(funs(rescale), rescale_mpg = mpg)

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_each(funs(rescale), rescale_mpg = mpg)
```

In addition you could use function `mutate_at()` as well, but its usage results in a loss of clarity:

```{r}
# without groups
mtcars %>% 
  mutate_at(vars(rescale_mpg = mpg), funs(rescale))

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_at(vars(rescale_mpg = mpg), funs(rescale))

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_at(vars(rescale_mpg = mpg), funs(rescale))
```

Notice that, opposite to `mutate_each()`, in `mutate_at()` the first argument refers to the set of selected variables and the second argument refers to the set of functions to be applied.


### Case 6: Apply Many Functions to One Variable

In this case you can use functions `mutate()`, `mutate_each()` and `mutate_at()`.  

Function `mutate()` has a more intuitive syntax:

```{r}
# without groups
mtcars %>% 
  mutate(rescale_mpg = rescale(mpg), order_mpg = order(mpg))

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate(rescale_mpg = rescale(mpg), order_mpg = order(mpg)) 

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate(rescale_mpg = rescale(mpg), order_mpg = order(mpg))
```

The names of the output variables can be specified in simple forms like `order_mpg = order(mpg)`.

When you apply many functions to one variable, the use of `mutate_each()` provides a more compact and tidy notation:

```{r}
# without groups
mtcars %>% 
  mutate_each(funs(rescale, order), mpg)

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_each(funs(rescale, order), mpg) 

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_each(funs(rescale, order), mpg)
```

The default names of the output variables are given by the names of the functions: `order` and `rescale`.

In this case you lose track of the name of the variable the functions are applied to.

If you prefer something like `rescale_mpg` and `order_mpg`, you shall appropriately rename the __functions__ you call within `funs()`:

```{r}
# without groups
mtcars %>% 
  mutate_each(funs(rescale_mpg = rescale, order_mpg = order), mpg)

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_each(funs(rescale_mpg = rescale, order_mpg = order), mpg)

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_each(funs(rescale_mpg = rescale, order_mpg = order), mpg)
```


An alternative to `mutate_each` is `mutate_at`, that provides a compact notation as well:

```{r}
# without groups
mtcars %>% 
  mutate_at(vars(mpg), funs(rescale, order))

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_at(vars(mpg), funs(rescale, order))

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_at(vars(mpg), funs(rescale, order))
```

As in `mutate_each()`, if you wish to assign a variable name different from the default one, you shall appropriately rename the __functions__ you call within `funs()`:

```{r}
# without groups
mtcars %>% 
  mutate_at(vars(mpg), funs(rescale_mpg = rescale, order_mpg = order))

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_at(vars(mpg), funs(rescale_mpg = rescale, order_mpg = order))

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_at(vars(mpg), funs(rescale_mpg = rescale, order_mpg = order))
```


### Case 7: Apply One Function to Many Variables

This case is very similar to case 6. Functions `mutate()`, `mutate_each()` and  `mutate_at()` may all be used.

Function `mutate()` has again a more intuitive syntax and the names of output variables can be specified in the usual simple form: `rescale_mpg = rescale(mpg)`.

```{r}
# without groups
mtcars %>% 
  mutate(rescale_mpg = rescale(mpg), rescale_disp = rescale(disp))

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate(rescale_mpg = rescale(mpg), rescale_disp = rescale(disp))

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate(rescale_mpg = rescale(mpg), rescale_disp = rescale(disp))
```

When you apply one function to many variables, the use of `mutate_each()` provides a more compact and tidy notation:

```{r}
# without groups
mtcars %>% 
  mutate_each(funs(rescale), mpg, disp)

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_each(funs(rescale), mpg, disp)

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_each(funs(rescale), mpg, disp)
```

The default names of the output variables are given by the names of the variables: `mpg` and `disp`.

In this case you lose track of the name of the function applied to the variables.

If you prefer something like `rescale_mpg` and `rescale_disp`, you shall appropriately rename the __variables__ you pass to `...` within `mutate_each()`:

```{r}
# without groups
mtcars %>% 
  mutate_each(funs(rescale), rescale_mpg = mpg, rescale_disp = disp)

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_each(funs(rescale), rescale_mpg = mpg, rescale_disp = disp)

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_each(funs(rescale), rescale_mpg = mpg, rescale_disp = disp)
```

Alternatively you may use `mutate_at()`:

```{r}
# without groups
mtcars %>% 
  mutate_at(vars(mpg, disp), funs(rescale))

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_at(vars(mpg, disp), funs(rescale))

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_at(vars(mpg, disp), funs(rescale))
```

and if you wish to customise the new variables names:

```{r}
# without groups
mtcars %>% 
  mutate_at(vars(rescale_mpg = mpg, rescale_disp = disp), funs(rescale))

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_at(vars(rescale_mpg = mpg, rescale_disp = disp), funs(rescale))

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_at(vars(rescale_mpg = mpg, rescale_disp = disp), funs(rescale))
```

In case you want to apply `mutate()` to all of your variables, for instance you want to use the function `rescale()` on all of your numeric variables, you may use the function `mutate_all()`: 

```{r}
# without groups
mtcars %>%
  select_if(is.numeric) %>%
  mutate_all(rescale)

# with one group
mtcars %>% 
  select_if(is.numeric) %>%
  group_by(carb) %>% 
  mutate_all(rescale)

# with more than one group
mtcars %>% 
  select_if(is.numeric) %>%
  group_by(carb, cyl) %>% 
  mutate_all(rescale)
```

The default column names are again given by the original names: `carb`, `cyl`, `mpg` and `disp`. To add a different variable name an additional command is needed:

```{r}
# without groups
mtcars %>%
  select_if(is.numeric) %>%
  mutate_all(rescale) %>%
  setNames(c("rescaled_cyl", "rescaled_carb", "rescaled_mpg", "rescaled_disp"))

# with one group
mtcars %>% 
  select_if(is.numeric) %>%
  group_by(carb) %>% 
  mutate_all(rescale) %>%  
  setNames(c("rescaled_cyl", "rescaled_carb", "rescaled_mpg", "rescaled_disp"))

# with more than one group
mtcars %>% 
  select_if(is.numeric) %>%
  group_by(carb, cyl) %>% 
  mutate_all(rescale) %>%
    setNames(c("rescaled_cyl", "rescaled_carb", "rescaled_mpg", "rescaled_disp"))
```


### Case 8: Apply Many Functions to Many Variables

As in the previous cases functions `mutate()`, `mutate_each()` and `mutate_at()` provide valid alternatives.

Function `mutate()` has again a more intuitive syntax and the names of output variables can be specified in the usual simple form: `rescale_mpg = rescale(mpg)`.

```{r}
#  without groups
mtcars %>% 
  mutate(rescale_mpg = rescale(mpg),  order_disp = order(disp))

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate(rescale_mpg = rescale(mpg),  order_disp = order(disp))

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate(rescale_mpg = rescale(mpg),  order_disp = order(disp))
```

When you apply many functions to many variables, the use of `mutate_each()` provides a more compact and tidy notation:

```{r}
# without groups
mtcars %>% 
  mutate_each(funs(rescale, order), mpg,  disp)

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_each(funs(rescale, order), mpg,  disp)

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_each(funs(rescale, order), mpg,  disp)
```

The names of the output variables are given by the notation `variable_function`, i.e. `mpg_rescale`, `disp_rescale`, etc.

Naming output variables with a different notation, i.e. `function_variable`, does not appear to be possible within the call to `mutate_each()`.

This goal has to be achieved with a separate instruction:

```{r}
# without groups
mtcars %>% 
  mutate_each(funs(rescale, order), mpg,  disp) %>% 
  rename(rescale_mpg = mpg_rescale, rescale_disp = disp_rescale, order_mpg = mpg_order, order_disp = disp_order)

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_each(funs(rescale, order), mpg, disp) %>% 
  rename(rescale_mpg = mpg_rescale, rescale_disp = disp_rescale, order_mpg = mpg_order, order_disp = disp_order)

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_each(funs(rescale, order), mpg, disp) %>%
  rename(rescale_mpg = mpg_rescale, rescale_disp = disp_rescale, order_mpg = mpg_order, order_disp = disp_order)
```


The alternative to `mutate_each()` is `mutate_at()`:

```{r}
# without groups
mtcars %>% 
  mutate_at(vars(mpg,  disp), funs(rescale, order))

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_at(vars(mpg,  disp), funs(rescale, order))

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_at(vars(mpg,  disp), funs(rescale, order))
```

and for customising the names of the new variables:

```{r}
# without groups
mtcars %>% 
  mutate_at(vars(mpg,  disp), funs(rescale, order)) %>% 
  rename(rescale_mpg = mpg_rescale, rescale_disp = disp_rescale, order_mpg = mpg_order, order_disp = disp_order)

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_at(vars(mpg,  disp), funs(rescale, order)) %>% 
  rename(rescale_mpg = mpg_rescale, rescale_disp = disp_rescale, order_mpg = mpg_order, order_disp = disp_order)

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_at(vars(mpg,  disp), funs(rescale, order)) %>%
  rename(rescale_mpg = mpg_rescale, rescale_disp = disp_rescale, order_mpg = mpg_order, order_disp = disp_order)
```


`mutate_all()` can be used also when you want to apply many functions to many variables:

```{r}
# without groups
mtcars %>%
  select_if(is.numeric) %>%
  mutate_all(c("rescale", "order")) 

# with one group
mtcars %>% 
  select_if(is.numeric) %>%
  group_by(carb) %>% 
  mutate_all(c("rescale", "order"))

# with more than one group
mtcars %>% 
  select_if(is.numeric) %>%
  group_by(carb, cyl) %>% 
  mutate_all(c("rescale", "order"))
```


The default name of the new variables is given by the notation `variable_function`. In order to name output variables with a different notation, a separate instruction is needed:

```{r}
# without groups
mtcars %>%
  select_if(is.numeric) %>%
  mutate_all(c("rescale", "order"))  %>%
  rename(rescale_carb = carb_rescale, rescale_cyl = cyl_rescale, rescale_mpg = mpg_rescale, rescale_disp = disp_rescale, order_carb = carb_order, order_cyl = cyl_order, order_mpg = mpg_order, order_disp = disp_order)

# with one group
mtcars %>% 
  select_if(is.numeric) %>%
  group_by(carb) %>% 
  mutate_all(c("rescale", "order")) %>%
  rename(rescale_cyl = cyl_rescale, rescale_mpg = mpg_rescale, rescale_disp = disp_rescale, order_cyl = cyl_order, order_mpg = mpg_order, order_disp = disp_order)

# with more than one group
mtcars %>% 
  select_if(is.numeric) %>%
  group_by(carb, cyl) %>% 
  mutate_all(c("rescale", "order")) %>%
  rename(rescale_mpg = mpg_rescale, rescale_disp = disp_rescale, order_mpg = mpg_order, order_disp = disp_order)
```


# Conclusions

You have two alternatives to functions `summarise()` and `mutate()`: `summarise_each()` and `summarise_at()`, and `mutate_each()` and `mutate_at()`.

Functions `summarise()` and `mutate()` have a simpler syntax while functions `summarise_each()`, `summarise_at()`, `mutate_each()` and `mutate_at()` have a more compact notation. 

As a consequence, `summarise()` and `mutate()`  seem more appropriate when dealing with a single variable or a single function. 

Notice that, in a future release, the functions `summarise_each()` and `mutate_each()` will be depreacted in favour of the families of functions 1) `summarise_all()` and `mutate_all()` that apply a function to all columns of a data frame and 2) `summarise_at()` and `mutate_at()` that operate on a subset of columns.

Functions `summarise_each()`, `mutate_each()`, `summarise_at()` and `mutate_at()` have their own way to assign names to output variables:

* apply many functions to one variable: the names of the output variables are given by the name of the __functions__.  In this case you lose the name of the variable the function is applied to;

* apply one function to many variables: the names of the output variables are given by the name of the __variables__.  In this case you lose track of the name of the function applied to the variables;

* apply many functions to many variables: the names of the output variables are given by the notation: __variable_function__. Naming output variables with a different notation does not appear to be possible within the call to `summarise_each()` or `mutate_each()` and `summarise_at()` or `mutate_at()`.

