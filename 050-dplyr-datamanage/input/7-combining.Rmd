---
title: "Combining Data"
---

```{r options, include=FALSE, purl=FALSE}
#source("options.R")
```

```{r first, include=FALSE, purl=FALSE, message=FALSE}
require(dplyr)
require(qdata)
data(italia)
data(tennis)
```


# Introduction

Very often you will have to deal with many tables that contribute to the analysis you are performin and you need flexible tools to combine them. 

Supposing that the two tables are already in a tidy form: the rows are observations and the columns are variables, `dplyr` provides three families of verbs that work with two tables at a time:

* __mutating joins__, which add new variables to one table from matching rows in another;
* __filtering joins__, which filter observations from one table based on whether or not they match an observation in the other table;
* __set operations__, which combine the observations in the data sets as if they were set elements.

All these verbs work similarly: the first two arguments, `x` and `y`, provide the tables to combine. The output is always a new table with the same type as `x`.


## Mutating Join

Mutating joins allow you to combine variables from multiple tables.  

There are four types of mutating join, which differ in their behaviour when a match is not found: 

* `inner_join(x, y)`
* `left_join(x, y)`
* `right_join(x, y)`
* `outer_join(x, y)`

For the next examples I will consider these two small data frames:

```{r}
df1 <- data.frame(id = 1:4, x1 = letters[1:4])
df2 <- data.frame(id = 3:5, x2 = letters[3:5])
```


* `inner_join(x, y)` only includes observations that match in both x and y:

```{r}
inner_join(df1, df2)
```


* `left_join(x, y)` includes all observations in `x`, regardless of whether they match or not. This is the most commonly used join because it ensures that you don’t lose observations from your primary table:

```{r}
left_join(df1, df2)
```


* `right_join(x, y)` includes all observations in `y`. It’s equivalent to `left_join(y, x)`, but the columns will be ordered differently:

```{r}
right_join(df1, df2)
left_join(df2, df1)

```

* `full_join()` includes all observations from `x` and `y`:

```{r}
full_join(df1, df2)
```


The left, right and full joins are collectively know as outer joins. When a row doesn’t match in an outer join, the new variables are filled in with missing values.

While mutating joins are primarily used to add new variables, they can also generate new observations. If a match is not unique, a join will add all possible combinations (the Cartesian product) of the matching observations:



# Example: the Italia data frame

Data frame `comuni` contains several variables detected on Italian "comuni", in particular the codes of the Italian "province" and "regioni" relative to the "comuni", but not their names. 

You don't know which "provincia" or "regione" each "comune" belongs to but, in data frames `province` and `regioni` you have the codes for "province" and "regioni" along with their names.

Let's keep only a few variables of these datasets in order to better understand the join results:

```{r}
comuni <- comuni %>% select(cod_comune:pop_legale, cod_provincia, cod_regione)
province <- province %>% select(cod_provincia:sigla_auto)
```

You can use a join to add "provincia" and "regione" to the Italian "comuni":

```{r}
comuni %>% left_join(province)
comuni %>% left_join(regioni)
comuni %>% left_join(province) %>% left_join(regioni)
```

As well as `x` and `y`, each mutating join takes an argument `by` that controls which variables are used to match observations in the two tables and there are few ways to specify it:

* `NULL`, the default. `dplyr` will use all variables that appear in both tables, a natural join. For example, the `comuni` and `province` tables match on their common variable `cod_provincia`:

```{r}
comuni %>% left_join(province)
```

* A character vector, `by = "x"`. It is like a natural join, but uses only some of the common variables. For example, when joining `comuni` and `province`, you will see that `R` will tell you that it's joining the two data frames by both `cod_provincia` and `cod_citta_metro`:

```{r}
comuni %>% left_join(province)
```

But we only want to join by `cod_provincia` not  by `cod_citta_metro`. As only some of the "province" have a "città metropolitana" (9 of them: Torino, Milano, Venezia, Genova, Bologna, Firenze, Roma, Napoli, Bari):

```{r}
comuni %>% left_join(province, by = "cod_provincia")
```

Note that the `cod_citta_metro` columns in the output are disambiguated with a suffix.

* A named character vector: `by = c("x" = "a")`. This will match variable `x` in table `x` to variable `a` in table `b`. For example, suppose the `regioni2` table is equal to `regioni` except for that its id variable is called `id_regione` and not `cod_regione` and suppose we want to use `regioni2` to associate the "regione" to each "comune":

```{r}
regioni2 <- regioni %>% rename(id_regione = cod_regione)
```

Then, in this case

```{r}
comuni %>% left_join(regioni2, c("cod_regione" = "id_regione"))
``` 


## A Pretty Example

With the commands you have seen so far, with very few lines of `R` code you can for example:

* calculate the population living in the Italian "province" and sort by legal population:

```{r}
  province %>%
  left_join(comuni) %>%
  group_by(provincia) %>%
  summarise(pop_legale = sum(pop_legale)) %>% 
  arrange(desc(pop_legale))
```


* calculate the population living in the Italian "regioni" and sort by legal population:

```{r}
  regioni %>%
  left_join(comuni) %>%
  group_by(regione) %>%
  summarise(pop_legale = sum(pop_legale)) %>%
  arrange(desc(pop_legale))
```


* calculate the population living in the "comuni" which are administrative centers of their "province" * and sort by `pop_legale`:

```{r}
  comuni %>%
  filter(comune_cap_prov == TRUE) %>%
  select(comune, pop_legale) %>% 
  arrange(desc(pop_legale))
```


# Filtering Joins

Filtering joins match observations in the same way as mutating joins, but affect the observations, not the variables. There are two types:

* `semi_join(x, y)` keeps all observations in `x` that have a match in `y`;
* `anti_join(x, y)` drops all observaitons in `x` that have a match in `y`.

These are most useful for diagnosing join mismatches.

Let's recall the small examle data frames:

For the next examples I will consider these two small data frames:

```{r}
df1 <- data.frame(id = 1:4, x1 = letters[1:4])
df2 <- data.frame(id = 3:5, x2 = letters[3:5])
```

All observations in `df1` also in `df2`

```{r}
df1 %>% semi_join(df2)
```

All observations in `df1` not in `df2`

```{r}
df1 %>% anti_join(df2)
```


## The tennis example

If you want to know something about the _US Open_ and _Wimbledon_ tennis tournements:

```{r}
data(tennis) 
```

Data frames `wimbledon` and `usopen` are related to the tow tennis tournament and contain the following variables:

* year
* champion_country
* champion
* runner up country
* runner up

If you want to know who won the US open and never won Wimbledon

```{r}
usopen %>% 
  anti_join(wimbledon, by = "champion") %>%
  select(year, champion_country, champion)
```

If you want to know who won both the US open and Wimbledon

```{r}
usopen %>% 
  semi_join(wimbledon, by = "champion") %>%
  select(year, champion_country, champion)
```

If you want to know who won both the US open and Wimbledon in the same year


```{r}
usopen %>% 
  semi_join(wimbledon, by = c("champion", "year")) %>%
  select(year, champion_country, champion)
```

If you want to know who won both the US open and Wimbledon more than once

```{r}
# who won the US open more than once
super_usopen <- usopen %>% 
  group_by(champion) %>%
  summarise (n_us = n()) %>%
  filter(n_us > 1)

# who won Wimbledon more than once
super_wimbledon <- wimbledon %>% 
  group_by(champion) %>%
  summarise (n_wb = n()) %>%
  filter(n_wb > 1)

# semi join
super_usopen %>% 
  semi_join(super_wimbledon, by = "champion") %>%
  select(champion)
```

Finally, if you wish to know who was the best player in the two tournaments:

```{r}
super_usopen %>% 
  inner_join(super_wimbledon, by = "champion") %>%
  mutate ( n = n_us+n_wb) %>%
  arrange(desc(n))
```
 

# Binding

`bind_rows` and `bind_cols` allow to bind data frames by rows and by columns, respectively:

Variables names in the two data frames to bind play a crucial role in the outcome type:

When binding rows and both data frames have the same columns: 

```{r}
df1 <- data.frame(x = 1:3, y = 3:1)
df2 <- data.frame(x = 4:6, y = 6:4)
df1 %>% bind_rows(df2)
```

When binding rows and data frames do not have the same columns: 

```{r}
df1 <- data.frame(x1 = 1:3, y1 = 3:1)
df2 <- data.frame(x2 = 4:6, y2 = 6:4, z2 = 0)
df1 %>% bind_rows(df2)
```

When binding columns and both data frames have the same columns: 

```{r}
df1 <- data.frame(x = 1:3, y = 3:1)
df2 <- data.frame(x = 4:6, y = 6:4)
df1 %>% bind_cols(df2)
```

When binding columns and data frames do not have the same columns: 

```{r}
df1 <- data.frame(x1 = 1:3, y1 = 3:1)
df2 <- data.frame(x2 = 4:6, y2 = 6:4, z2 = 0)
df1 %>% bind_cols(df2)
```




<!---


# Set Operations

Set operations expect the `x` and `y` inputs to have the same variables, and treat the observations like sets:

* `intersect(x, y)`: return only observations in both `x` and `y`;
* `union(x, y)`: return unique observations in `x` and `y`;
* `setdiff(x, y)`: return observations in `x`, but not in `y`.

Given this simple data:

```{r}
ripartizioni2 <-
  data.frame(cod_rip_geo = c("1","2"), rip_geo = rep("Nord",2)) %>%
  bind_rows(ripartizioni)
ripartizioni3 <- ripartizioni2 %>% slice(c(1,5,6))
ripartizioni3$rip_geo[3] <- "Mezzogiorno"
ripartizioni
ripartizioni3
```

The four possibilities are:

```{r}
intersect(ripartizioni, ripartizioni3)
union(ripartizioni, ripartizioni3) # Note that we get 7 rows, not 8
setdiff(ripartizioni, ripartizioni3)
setdiff(ripartizioni3, ripartizioni)
```

-->

<!---
# Coercion Rules

When joining tables, `dplyr` is a little more conservative than base `R` about the types of variable that it considers equivalent. This is mostly likely to surprise you when working with factors:

* Factors with different levels are coerced to character with a warning:

```{r}
# First data frame
ripartizioni4 <- ripartizioni
ripartizioni4$rip_geo <- factor(ripartizioni4$rip_geo)
ripartizioni4
ripartizioni4 %>% str
# Second data frame
ripartizioni5 <- ripartizioni3
ripartizioni5$rip_geo <- factor(ripartizioni5$rip_geo)
ripartizioni5
ripartizioni5 %>% str
# Join
(joined_df <- ripartizioni4 %>% full_join(ripartizioni5))
joined_df %>% str()
```

* Factors with the same levels in a different order are coerced to character with a warning:

```{r}
# First data frame
ripartizioni4$rip_geo <- factor(ripartizioni4$rip_geo,
                                levels = c("Centro","Isole","Nord-est","Nord-ovest","Sud",
                                           "Nord","Mezzogiorno"))
ripartizioni4
ripartizioni4 %>% str
# Second data frame
ripartizioni5$rip_geo <- factor(ripartizioni5$rip_geo,
                                levels = c("Nord","Centro","Mezzogiorno",
                                           "Isole","Nord-est","Nord-ovest","Sud"))
ripartizioni5
ripartizioni5 %>% str
# Join
(joined_df <- ripartizioni4 %>% full_join(ripartizioni5))
joined_df %>% str()
```

* Factors are preserved only if the levels match exactly:

```{r}
# First data frame
ripartizioni4$rip_geo <- factor(ripartizioni4$rip_geo,
                                levels = c("Nord","Centro","Mezzogiorno",
                                           "Nord-est","Nord-ovest","Sud","Isole"))
ripartizioni4
ripartizioni4 %>% str
# Second data frame
ripartizioni5$rip_geo <- factor(ripartizioni5$rip_geo,
                                levels = c("Nord","Centro","Mezzogiorno",
                                           "Nord-est","Nord-ovest","Sud","Isole"))
ripartizioni5
ripartizioni5 %>% str
# Join
(joined_df <- ripartizioni4 %>% full_join(ripartizioni5))
joined_df %>% str()
``` 

* A factor and a character are coerced to character with a warning:

```{r}
# First data frame
ripartizioni
ripartizioni %>% str
# Second data frame
ripartizioni4
ripartizioni4 %>% str
# Join
(joined_df <- ripartizioni %>% full_join(ripartizioni4))
joined_df %>% str()
```

* Otherwise logicals will be silently upcast to integer, and integer to numeric, but coercing to character will raise an error:

```{r}
# First data frame
ripartizioni6 <- ripartizioni3
ripartizioni6$cod_rip_geo <- as.numeric(ripartizioni6$cod_rip_geo)
ripartizioni6
ripartizioni6 %>% str
# Second data frame
ripartizioni7 <- ripartizioni6
ripartizioni7$cod_rip_geo[3] <- 4.5
ripartizioni7
ripartizioni7 %>% str
# Join
(joined_df <- ripartizioni6 %>% full_join(ripartizioni7))
joined_df %>% str()
```

```{r, error=TRUE}
# First data frame
ripartizioni6
ripartizioni6 %>% str
# Second data frame
ripartizioni3
ripartizioni3 %>% str
# Join
(joined_df <- full_join(ripartizioni6, ripartizioni3))
```
-->


