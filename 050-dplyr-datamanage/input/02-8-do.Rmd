---
title: "Generic Do"
---

```{r options, include=FALSE, purl=FALSE}
options(width = 108)
```

```{r first, include=TRUE, purl=TRUE, message=FALSE}
# load packages and data
require(tidyverse)
require(broom)
require(qdata)
data(people)
```


# `do()`: a General Purpose Verb

Function `do()` is a general purpose complement to the specialized manipulation functions `filter()`, `select()`, `mutate()`, `summarise()` and `arrange()`. You can use `do()` to perform arbitrary computation, returning either a data frame or arbitrary objects which will be stored in a list. 

For example, it may be interesting to compute quartiles for variable `Weight` grouped by `Gender` in the `people` dataset:

```{r}
people %>% group_by(Gender) %>%
  do(data.frame(p = (1:3)/4, quantile = quantile(.$Weight, probs = (1:3)/4, na.rm = TRUE)))            
```

Note the use of function `data.frame()` within function `do()`. This is required as `do()` expects a data frame as first argument.

On a similar basis, you can define a function `qq()`:

```{r}
qq <- function(x, probs = seq(0, 1, 0.25), ...){
  
  data <- data.frame(prob = probs,  
  quantile = quantile(x, probs, ...))
    
  return(data)
  
}
```

that returns a data frame of quantiles along with the corresponding probabilities

You can then use function `qq()` with function `do()`:

```{r}
people %>% group_by(Gender) %>%
  do(qq(.$Weight, probs = (1:3)/4, na.rm = TRUE))
```



Function `do()` can manage functions that return results of any length. Similarly, the same function can help when applying multiple functions to the same variable.  


Suppose you want to compute, mean and standard deviation for `Height` grouped by `Area`; in this case you first define a function that returns mean and standard deviation:

```{r}
fun <- function(x, ...)  c(mean = mean(x, ...), sd = sd(x, ...))
```

and then you use it with `do()`:

```{r}
people %>% group_by(Area) %>%
  do(data.frame(stats = c("mean", "sd") , value = fun(.$Height, na.rm = TRUE)))
```

Note that this is equivalent to:

```{r}
people %>% group_by(Area) %>%
  summarise_each(funs("mean", "sd") , Height) %>%
  gather(key = stat, value = value, -Area)
```

Function `do()`, along with some _hidden_ proprieties of data frames objects, allows very powerful computation:

Formally a data.frame is a list made of equal length vectors but, data frames can store a lists in place of columns as long as the number of elements of the list matches the number of rows in the data frame:


```{r}
data.frame(id  = 1:3, what = I(list(4:6, 7:9, 10:12)))
```

The use of function `I()` forces `R` to treat the list `as.is` without attempting any transformation.


By using this property of data frames, you can compute a liner model on data frame `people` for any level of factor `Gender`:

```{r}
models <- people %>% group_by(Gender) %>% 
  do(mod = lm(Weight~Area, data = .))
```


Afterward, you can summarise basic model statistics in a tabular form:

```{r}
mutate(models, intercept  = coefficients(mod)[[1]], slope = coefficients(mod)[[2]], Rsq = summary(mod)$r.squared)
```

Possibly, using a different approach:


```{r}
intercept <- function(model) coefficients(model)[[1]]
slope <- function(model) coefficients(model)[[2]]
RSq <- function(model, i) summary(model)$r.squared

models %>% mutate_each(funs(intercept, slope , RSq), mod)
```

Finally, by using function `tidy()` from package `broom`:

```{r}
people %>% group_by(Gender) %>% 
  do(tidy(lm(Weight~Area, data = .)))
```

