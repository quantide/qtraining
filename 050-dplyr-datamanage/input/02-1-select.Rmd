---
title: "Select Data"
---


```{r options, include=FALSE, purl=FALSE}
options(width = 108)
```


```{r first, include=TRUE, purl=TRUE, message=FALSE}
require(dplyr)
require(qdata)
data(bank) 
```

# Introduction to `dplyr`

The `dplyr` package for `R` is very powerful for data management since:

* it simplifies how you can think about common data manipulation tasks;
* it provides simple “verbs”, functions that correspond to the most common data manipulation tasks;
* it uses efficient data storage backends, so you spend less time waiting for the computer.

## Verb functions

`dplyr` aims to provide a function for each basic verb of data manipulating.

All these functions are very similar:

* the first argument is a data frame;
* the subsequent arguments describe what to do with it, and you can refer to columns in the data frame directly without using $;
* the result is a new data frame.

Together these properties make it easy to chain together multiple simple steps to achieve a complex result.

These five functions provide the basis of a language of data manipulation. At the most basic level, you can only alter a tidy data frame in five useful ways: 

1. select variables of interest: `select()`;
2. filter records of interest: `filter()`;
3. reorder the rows: `arrange()`;
4. add new variables that are functions of existing variables: `mutate()`;
5. collapse many values to a summary: `summarise()`. 

The remainder of the language comes from applying these five functions to different types of data, like grouped data, which will be described after.


# `select()`

Often you work with large datasets with many columns where only a few are  of actual interest to you. 

`select()` allows you to rapidly zoom in on a useful subset of columns by using a set of useful helper functions.

![](images/sel.png) 

```{r bank}
# Select columns: year, month and day of bank data frame
select(bank, year, month, day)
# Select columns: year, month and day of bank data frame
bank %>% select(year:day)
# Select all columns of bank data frame apart from: year, month and day
bank %>% select(-(year:day))
```

This function works similarly to the select argument of the `base::subset()`. It has its own function in `dplyr`, because the `dplyr` philosophy is to have small functions that each do one thing well.

You can also rename variables with `select()` by using named arguments:

```{r}
# Rename id variable as ID
bank %>% select(ID = id)
```


## Helper Functions for `select()`

`select()` offer a wide set of helper functions:

* `contains(x)` selects all variables whose name contains `x`
* `ends_with(x)` selects all variables whose name ends in `x`
* `starts_with(x)` selects all variables whose name starts with `x`
* `everything()` selects all variables:
* `matches`: selects all variables whose name matches the regular expression `.x`:
* `num_range(x)` selects all variables starting with `x` and ending with a number:
* `one_of(x)` selects variables provided in a character vector `x`:
* `x:y` allows you to select a subset of adiacent variables from `x` to `y`:
* `-x` allows you to exclude variable `x` from the dataset

* `contains` selects all variables whose name contains "d":

```{r}
bank %>% select(contains("d"))
```
 
* `ends_with` selects all variables whose name ends in "tion":

```{r}
bank %>% select(ends_with("tion"))
```

* `starts_with` selects all variables whose name starts with "d":

```{r}
bank %>% select(starts_with("d"))
```

* `everything()` selects all variables:

```{r}
bank %>% select(everything())
# change the order of columns
bank %>% select(ends_with("tion"), everything() ) 
```

* `matches()` selects all variables whose name matches the regular expression ".r":

```{r}
# match all variables containing "r", but not at the first place
bank %>% select(matches(".r")) 
```


* `num_range` selects all variables starting with "x" and ending with a number:

```{r}
data(tennis)
wimbledon
wimbledon %>% select(num_range("s", c(1:3, 5)))
```


* `one_of` selects variables provided in a character vector:

```{r}
bank %>% select(one_of(c("marital","education")))
vars <- c("marital","education")
bank %>% select(one_of(vars))
```

* `:` allows you to select a subset of variables from `job` to `balance`:

```{r}
bank %>% select(job:balance)
```

* `-` allows you to specify which variables exclude from the dataset:

```{r}
bank %>% select(-job)
bank %>% select(-starts_with("d"))
```

Notice that all helpers functions are also real exported functions, that means that you can use them also outside the 'select()' function:

```{r}
starts_with("b", vars=names(bank))
```


## `select_if()`
This verb allows you to use a predicate on the columns of a data frame. Only those columns for which the predicate returns TRUE will be selected:

```{r}
select_if(bank, is.factor)    # select only string variables
select_if(bank, is.numeric)   # select only numeric values
```


# `distinct()`

A common use of `select()` is to find out which values a set of variables takes. This is particularly useful in conjunction with the `distinct()` verb which only returns the unique values in a table.

```{r}
# find out unique values of housing variable of bank data frame
distinct(select(bank, housing))
# find out combinations of unique values of housing and loan variables of bank data frame
distinct(select(bank, housing, loan))
```

This is very similar to `base::unique()` but should be much faster.


# `rename()`

As seen previously, you can rename the variables using `select()`, however it drops all the variables not explicitly mentioned so it’s not that useful. 
Instead, use `rename()`:

```{r}
# Rename id variable as ID
bank %>% rename(ID = id)
```
