---
title: "Manipulating strings with stringr"
---

```{r options, include=FALSE, purl=FALSE}
require(knitr)
options(width = 108)
opts_chunk$set(echo = TRUE)
opts_knit$set(root.dir = "../data")
```


```{r first, include=TRUE, purl=TRUE, message=FALSE}
require(tidyverse)
require(stringr)
require(forcats)
require(qdata)
```

# Introduction

In this chapter you will learn about string manipulation in `R` with the package `stringr`. You don't always work with textual data, hence this package is installed when you install `tidyverse` but you need to load it explicitely.

At the end of this chapter you will also work with factors with the package `forcats` which, just like `stringr`, is part of the tidyiverse but it is not part of the core, hence you need to load it explicitely as well.


Strings are textual data and they are created by using either single quotes or double quoutes, as you have already seen at the beginning of this course. You can store strings in a character vector:

```{r}
# character vector
char_vector <- c("Hello", "Andrea", "Spanò")
```

With the function `str_length()` you can see the length of each string:

```{r}
# character vector
str_length(char_vector)
```


## Combining strings

Suppose you do not need to store separately name and surname. Hence you would like to "combine" name and surname into the same string:

```{r}
# character vector
str_c("Andrea", "Spanò", sep = " ")
```

The argument `sep` tells the software if and how you should separate the two parts of the new string. You can also add more words and your string gets longer:

```{r}
# character vector
str_c("Hello", "Andrea", "Spanò", sep = " ")
str_length(str_c("Hello", "Andrea", "Spanò", sep = " "))
```

In the above code, you have collapsed the whole character vector into one string. In these cases you may want to use the argument `collapse` that collapses all the strings in the character vector:

```{r}
str_c(char_vector, collapse = " ")
```


Now let us make this a bit more interesting. Let us import the file `tennis.txt`:


```{r setwd, eval=FALSE}
setwd("./data")
```

```{r}
tennis <- read_table("tennis.txt", col_names = TRUE)
head(tennis)
```

First names and surnames are stored in two different variables. Suppose you want one single variable for both:

```{r}
tennis %>% 
  mutate_at(vars(Name), funs(str_c(First.Name, Name, sep = " "))) %>%
  select(-First.Name)   # drop the column "First.Name"
```

You have obtained a tibble with only one column containing the name and surname of each tennis player.

## Splitting

Similarly, you may want to go the other way around: you have a string containing different parts separated by, for instance, a space, and you want to divide it into many strings:

```{r}
char_vector <- c("Hello Andrea !")
str_split(char_vector, " " )
```

Let us make it a bit more interesting and suppose you have the tennis data with name and surnames of each tennis player in the same variable. 

```{r}
tennis_new <- tennis %>% 
  mutate_at(vars(Name), funs(str_c(First.Name, Name, sep = " "))) %>%
  select(-First.Name)   # drop the column "First.Name"
```


You may want to split the into two strings so that you have one variable for names and one for surnames:

```{r}
str_split(tennis_new$Name, " ")
```

The function `str_split()` returns a list. This is because different strings may be composed by a different numbers of words. In order to work with a matrix you can set `simplify = TRUE`:

```{r}
str_split(tennis_new$Name, " ", simplify = TRUE)
```

You can easily see that there is one tennis player with a double name, but the function `str_split()` does not aggregate the two names as they are devided by a space.

## Subsetting

Another useful manipulation you may need/want to do on strings, is to extract part of it. For instance, suppose you have the following data frame containing some Italian cities and their province:

```{r}
df <- tibble(comune = c('Legnano', 'Parabiago', 'Alpette', 'Andezano'),
                 provincia = c('Milano', 'Mi', 'Torino', 'To'))
```

Some provinces are stored using an abbrvation (only the first two letters as it is often the case) and others are stored using the full name of the city. Milano and Mi are the same province as well as Torino is the same as To. However the software reads them as four different values. 

```{r}
df %>% distinct(provincia) # 4 different values
```


To let `R` know that it is not 4 differenct cities, we may give them the same name by taking the first two letters of each province:

```{r}
df %>% 
  mutate_at(vars(provincia), funs(str_sub(provincia, 1, 2)))
```


The function `str_sub` takes the input character vector followed by two integer vectors. The first one indicates the position of the first character and the second indicates the position of the last character to select.


## Change cases

Another important operation on strings is changing the text to lowercase/uppercase. In `R` uppercases and lowercases are not equivalent:

```{r}
"hello" == "hello"
"hello" == "HELLO"
```

It may be useful to let `R` know that they are equivalent by modifying one of the two words to upper or lower case:

```{r}
str_to_upper(c("hello"))
str_to_lower(c("HELLO"))
```

Let us make this a bit more interesting and consider again the example with provinces and municipalities. As we often write provinces with the upper first two letters, let us first select the first two letters and secondly change them to uppercase:

```{r}
df %>% 
  mutate_at(vars(provincia), funs(str_sub(provincia, 1, 2))) %>%
  mutate_at(vars(provincia), funs(str_to_upper(provincia)))
```

Notice that changing cases may be more complicated than it looks. In fact different languages may have different rules for changing cases. You can choose the language by specifying `locale = `. The suggestion is that if you are working with foreign languages you should check additional documentation on the functions `str_to_upper()` and `str_to lower()`.


# Identifying string patterns


## Detect matches

To check whether a character vector matches a pattern, you can use the function `str_detect()`, where you need to specify the vector in which to look for and the pattern to be found. Moreover you may specify whether you want to look for the pattern at the beginning or at the end. 


1. Contains a (set of) letter(s):

```{r}
province <- c("milano", "milan", "mi", "milano", "torino", "to", "agrigento")
str_detect(province, c("to"))
```



2. Starts with: 

```{r}
province <- c("milano", "milan", "mi", "milano", "torino", "to", "agrigento")
str_detect(province, c("^to"))
```



3. Ends with: 

```{r}
province <- c("milano", "milan", "mi", "milano", "torino", "to", "agrigento")
str_detect(province, c("to$"))
```


## Extract match

Once you have found a match you may want to extract it so that you can additionally manipulate them:

```{r}
province <- c("milano", "milan", "mi", "milano", "torino", "to", "agrigento")
str_extract(province, c("to$"))
```


## Replace match

Suppose the match you have found corresponds to a typos hence you just want to find it and replace it with the correct word:

```{r}
colors <- c("gray", "gray", "grey", "white", "white", "white")
str_replace(colors, c("gray"), "grey")
```


# Factors with forcats

Suppose you have a variable to record the colors of a car available only in the following five colors:


```{r}
colors <- c("grey", "blue", "dark blue", "black", "white")
```

Using a string for this variable may not be the best choice. In fact two problems arise:

* Only five colors are possible and there is nothing saving you from typos (for instance typing "gray" instead of "grey" is often the case!)
* The values are sorted in alphabetical order, however you may want them from the darkest to the ligthest:

```{r}
sort(colors)
```

Both problems may be solved creating a factor that contains all the desired levels:


```{r}
color_levels <- c("black", "dark blue", "blue", "grey", "white")
```

And you then apply it to your character vector:

```{r}
colors <- c("gray", "blue", "dark blue", "black", "white", "grey", "white")
colors2 <- factor(colors, levels = color_levels)
colors2
```

Notice that strings that do not match one of the levels are assigned a "NA". This helps you avoid the first of the two problems.



