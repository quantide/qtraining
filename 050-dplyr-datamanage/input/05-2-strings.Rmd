---
title: "Manipulating strings with stringr"
---

```{r options, include=FALSE, purl=FALSE}
require(knitr)
options(width = 108)
opts_chunk$set(echo = TRUE)
opts_knit$set(root.dir = "../data")
```


```{r first, include=TRUE, purl=TRUE, message=FALSE}
# load packages
require(tidyverse) # alternatively: require(dplyr), require(tidyr)
require(stringr)
require(qdata)
```

# Introduction

In this chapter you will learn about string manipulation in `R` with the package `stringr`. As you don't always work with textual data, `stringr` is not part part of the tidyverse core. Thus you need to lead it explicitely.

Strings are textual data and they are created by using either single quotes or double quoutes, as you have already seen at the beginning of this course. You store strings in a character vector:

```{r}
# character vector
char_vector <- c("Hello", "Andrea", "Spanò")
```

With the function `str_length()` you can see the length of each string:

```{r}
# character vector
str_length(char_vector)
```


## Combining strings

Suppose you do not need to store separately name and surname. Hence you would like to "combine" name and surname into the same string:

```{r}
# character vector
str_c("Andrea", "Spanò", sep = " ")
```

The argument `sep` tells the software if and how you should separate the two parts of the new string. You can also add more words and your string gets longer:

```{r}
# character vector
str_c("Hello", "Andrea", "Spanò", sep = " ")
str_length(str_c("Hello", "Andrea", "Spanò", sep = " "))
```

In the above code, you have collapsed the whole character vector into one string. In these cases you may want to use the argument `collapse` that collapses all the strings in the character vector:

```{r}
str_c(char_vector, collapse = " ")
```


Now let us make this a bit more interesting. Let us import the file `tennis.txt`:


```{r setwd, eval=FALSE}
setwd("./data")
```

```{r}
tennis <- read_table("tennis.txt", col_names = TRUE)
head(tennis)
```

First names and surnames are stored in two different variables. Suppose you want one single variable for both:

```{r}
tennis %>% 
  mutate_at(vars(Name), funs(str_c(First.Name, Name, sep = " "))) %>%
  select(-First.Name)   # drop the column "First.Name"
```

You have obtained a tibble with only one column containing the name and surname of each tennis player.

## Splitting

Similarly, you may want to go the other way around: you have a string containing different parts separated by, for instance, a space, and you want to divide it into many strings:

```{r}
char_vector <- c("Hello Andrea !")
str_split(char_vector, " " )
```

Let us make it a bit more interesting and suppose you have the tennis data with name and surnames of each tennis player in the same variable. 

```{r}
tennis_new <- tennis %>% 
  mutate_at(vars(Name), funs(str_c(First.Name, Name, sep = " "))) %>%
  select(-First.Name)   # drop the column "First.Name"
```


You may want to have one variable storing names and one storing surnames:

```{r}
str_split(tennis_new$Name, " ")
```

The function `str_split()` returns a list. This is because different strings may be composed by a different numbers of words. In order to work with a matrix you can set `simplify = TRUE`:

```{r}
str_split(tennis_new$Name, " ", simplify = TRUE)
```

You can easily see that there is one tennis player with a double name, but the function `str_split()` does not aggregate the two names as they are devided by a space. 


## Subsetting

Another useful manipulation you may need/want to do on strings, is to extract part of it. For instance, suppose you have the following data frame containing some Italian cities and their "provincia":

```{r}
df <- tibble(comune = c('Legnano', 'Parabiago', 'Alpette', 'Andezano'),
                 provincia = c('Milano', 'Mi', 'Torino', 'To'))
```

Some "province" are stored using an abbrvation (only the first two letters as it is often the case) and others are stored using the full name of the city. Milano and Mi are the same province as well as Torino is the same as To. However the software reads them as four different values. 

```{r}
df %>% distinct(provincia) # 4 different values
```


To let `R` know that it is not 4 differenct cities, you may give them the same name by taking the first two letters of each "provincia":

```{r}
df %>% 
  mutate_at(vars(provincia), funs(str_sub(provincia, 1, 2)))
```


The function `str_sub` takes the input character vector followed by two integer vectors. The first one indicates the position of the first character and the second indicates the position of the last character to select.


## Change cases

Another important operation on strings is changing the text to lowercase/uppercase. In `R` uppercases and lowercases are not equivalent:

```{r}
"hello" == "hello"
"hello" == "HELLO"
```

It may be useful to let `R` know that they are equivalent by modifying one of the two words to upper or lower case:

```{r}
str_to_upper(c("hello"))
str_to_lower(c("HELLO"))
```

Let us make this a bit more interesting and consider again the example with provinces and municipalities. As we often write provinces with the upper first two letters, let us first select the first two letters and secondly change them to uppercase:

```{r}
df %>% 
  mutate_at(vars(provincia), funs(str_sub(provincia, 1, 2))) %>%
  mutate_at(vars(provincia), funs(str_to_upper(provincia)))
```

Notice that changing cases may be more complicated than it looks. In fact different languages may have different rules for changing cases. You can choose the language by specifying `locale = `. If you are working with foreign languages you better check additional documentation on the functions `str_to_upper()` and `str_to lower()`.


# Identifying string patterns


## Detect matches

To check whether a character vector matches a pattern, you can use the function `str_detect()`, where you need to specify the vector in which to look for and the pattern to be found. Moreover you may specify whether you want to look for the pattern at the beginning or at the end of the string. 


1. Contains a (set of) letter(s):

```{r}
province <- c("milano", "milan", "mi", "milano", "torino", "to", "agrigento")
str_detect(province, c("to"))
```



2. Starts with: 

```{r}
province <- c("milano", "milan", "mi", "milano", "torino", "to", "agrigento")
str_detect(province, c("^to"))
```



3. Ends with: 

```{r}
province <- c("milano", "milan", "mi", "milano", "torino", "to", "agrigento")
str_detect(province, c("to$"))
```


## Extract match

Once you have found a match you may want to extract it so that you can additionally manipulate it:

```{r}
province <- c("milano", "milan", "mi", "milano", "torino", "to", "agrigento")
str_extract(province, c("to$"))
```


## Replace match

Suppose the match you have found corresponds to a typo hence you just want to find it and replace it with the correct word:

```{r}
colors <- c("gray", "gray", "grey", "white", "white", "white")
str_replace(colors, c("gray"), "grey")
```

If you have only a defined set of possible strings, you may also set levels and read strings as factors. This will avoid typos as strings that do not belong to the defined levels will be assigned `NA`.

```{r}
colors <- c("gray", "gray", "grey", "white", "white", "white")
colors_levels <- c("gray", "white")
factor(colors, levels = colors_levels)
```

