---
title: "Add placeholders for outputs to the UI"
output: html_document
---

```{r options, include=FALSE, purl=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, fig.pos = 'H', fig.width = 4, fig.height = 3)
options(width = 108)
```


## Introduction

So far we have layed out the shiny app so that inputs can be hosted. We now should add elements to the UI to display the outputs. 

Outputs are objects that R creates and that we want to display in our app. In this situation, we want the user to be able to explore the data, so you can think of the output as anything that can help users get better insights of the data, such as plots and tables. 

Note that in this secton we are still building the UI, so at this point we only add _placeholders_ for the outputs. _placeholders_ determine where an output will be and what its ID is, but they do not show anything. Each output must be built in the server code later.

Similarly to the input section Shiny provides different output functions for different type of output. In this section we give details of the major Shiny functions useful for representing the major output types, that are plots and tables. 

All the ouput functions have the first same argument, that is `outputId`. It is used to identify each output, and it must be unique for each output.


## Plots

As mentioned, it may be intersting to show a plot representing the number of new comic charecters coming out each year. In the previous sections, we have also thought of filtering the data by character type and by sex, to better study the differences between these variables.

One of the outputs we want to show is hence a line plot/time series. Since we want a plot, the function we use is `plotOutput()`:

```{r plotOutput}
plotOutput("timeSeries")
```

Again, note that this will only add a _placeholder_ in the UI for a plot named `timeSeries`.

Additional arguments for `plotOutput` function are width and height of the output, but, more importantly there are some additonal arguments that allow the user to further interact with the app by clicking on it. For instance, the argument `click` can be used so that the plot sends coordinates to the server whenever it is clicked, and the value is showed. We will come back to this argument later on.



## Summary tables

Below the plot, we may want to have a table that shows all the results. In order to add the table placeholder, we use the `tableOutput()` function:

```{r tableOutput}
tableOutput("tableResults")
```

Alternatively to `tableOutput`, you may use `dataTableOutput` to create interactive tables with more features:

```{r tableOutput2}
dataTableOutput("tableResults")
```


## Final UI 

At this point, we can add the output to the `mainPanel()` just after the input functions. In order to have a better lay out, you can also choose to add a couple of brakes in between outputs and in between inputs. So that your final user interface shoud look like this:


```{r finalUI}
library(shiny)
df <- read_csv("../data/marvel-wikia-data.csv")

ui <- fluidPage(
  titlePanel("Comic Characters"),
  em("Here is a visualisation of Comic Characters Data"), 
      br(), 
      br(),
  sidebarLayout(
    sidebarPanel(
      radioButtons("publisherInput", "Publisher",
                  choices = c("DC", "Marvel"),
                  selected = "DC"),
      br(),
      br(),
      selectInput("alignInput", "Character Type",
                  choices = c("Good Characters", "Bad Characters", "Neutral Characters")),
      br(),
      br(),
      sliderInput("yearInput", "Year", 1939, 2013, c(1990, 1995))),
    mainPanel(plotOutput("timeSeries"),
              br(),
              br(),
              dataTableOutput("tableResults"))
  )
)

server <- function(input, output) {}

shinyApp(ui = ui, server = server)
```

Note that we added `br()` now and then. It is just  a coule of line brekas with the only purpose to leave some space between outputs so that the overall app can be better visualised. If you like, you can choose to remove it or add more/less space.


## Shinydashboard

Suppose again, we want to use shinydashboard. As usual, not much changes: the only difference is the way the overall space is managed with the use of boxes. 

Output placeholders will be placed in `dashboardBody()` as here is where the plots and tables will go. Note that every output is inside a `box()` and note also that the box width may be customised setting `width` argument. Setting `width = 12` is equals to expanding the box to the whole length of the page: remember that Shiny works on a _12-unit wide grid_:


```{r shinydashboard}

library(shiny)
library(shinydashboard)

load("../data/comics_data.RData")


ui <- dashboardPage(
    dashboardHeader(title = "Comic characters Data"),
    ## Sidebar content
    dashboardSidebar(
      sidebarMenu(
        menuItem("Plot", tabName = "plot", icon = icon("th")),
        menuItem("Summary", tabName = "summary", icon = icon("th"))
        )
      ),

## Body content
  dashboardBody(
    tabItems(
      # First tab content
      tabItem(tabName = "plot",
        fluidRow(
          box(title = "Choose publisher", radioButtons( "publisherInput", "Publisher",
                  choices = c("DC", "Marvel"),
                  selected = "DC")),
          box(title = "Select year", sliderInput("yearInput", "Year", 1939, 2013, c(1990, 2013))
              ),
          box(plotOutput("timeSeries"), width = 12)
        )),
      # Second tab content
      tabItem(tabName = "summary",
        h2(box(dataTableOutput("tableResults"))))
      )
    )
  )

server <- function(input, output) {}

shinyApp(ui = ui, server = server)
```


