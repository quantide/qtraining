---
title: "Creating a Histogram"
output: html_document
---

```{r options, include=FALSE, purl=FALSE}
options(width = 108)
```

```{r first, include=TRUE, purl=TRUE, message=FALSE}
require(dplyr)
require(ggplot2)
require(qdata)
data(bands)
```

Histograms are used to summarize a continuous variable into classes, called _bins_. The area (and not the height) of each bin is proportional to the frequency of cases in the bin. The vertical axis is not frequency but density. When bins are equal size, a rectangle is erected over the bin with height proportional to the frequency. As the adjacent bins leave no gaps, the rectangles of a histogram touch each other to indicate that the original variable is continuous.

```{r histograms, message=FALSE, warning=FALSE, echo=FALSE, purl=FALSE}
ggp <- ggplot(data=bands, aes(x=ink_pct)) + 
  xlab("Continuous variable\n(x)") +
  theme(axis.text.x = element_blank(), axis.text.y = element_blank())

ggp1 <- ggp + geom_histogram(fill="#2B4C6F") + ylab("Frequency\n(y)")

ggp2 <- ggp + geom_histogram(fill="#2B4C6F", colour="#3690c0", bins = 8) + ylab("Density\n(y)")

gridExtra::grid.arrange(ggp1, ggp2, ncol=2)
```

This chapter presents how to build histograms and introduces a basic concepts of `ggplot2` graphics: faceting. It shows also how to build density curves and plots and frequency polygons. 


## The first histogram

As a quality engineer, you are interested to the distribution of ink percentage in `bands` data.

```{r histogram_first, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) + 
  geom_histogram()
```

As usual,  aesthetics can be set to modify the appearance of plot.

```{r histogram_aes, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) + 
  geom_histogram(fill="#2B4C6F", colour="#3690c0")
```

By default, the data is grouped into 30 bins. You can modify the number of bins:

 - setting the number of bins:
    ```{r histogram_bins, message=FALSE, warning=FALSE}
    ggplot(data=bands, mapping=aes(x=ink_pct)) + 
      geom_histogram(fill="#2B4C6F", colour="#3690c0", bins=6)
    ```
    
 - setting the width of each bin:
    ```{r histogram_binwidth, message=FALSE, warning=FALSE}
    ggplot(data=bands, mapping=aes(x=ink_pct)) + 
      geom_histogram(fill="#2B4C6F", colour="#3690c0", binwidth=7)
    ```  
    
## Mapping variables to histograms and faceting

May be interesting analysing the distribution of ink percentage for each level of `band_type`. 

```{r histogram_mapping, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) +
  geom_histogram(mapping=aes(fill=band_type))
```

Mapping the grouping variable to `fill`, two overlapped distributions are shown. In some cases, as shown above, this solution may work. In other cases, the result may be very difficult to be understood. Suppose you are in the distribution of ink percentage for each level of `press_type`

```{r histogram_mapping_hide, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) +
  geom_histogram(mapping=aes(fill=press_type))
```

In this case, four different histograms may produce a more readable result.

```{r histogram_facetgrid_col, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) +
  geom_histogram(fill="#2B4C6F") +
  facet_grid(. ~ press_type)
```

`facet_grid()` produces a different panel for each level of `press_type`. It requires a formula style: `rows ~ columns`. The dot in the formula is used to indicate there should be no faceting on this dimension (either row or column). The following example shows faceting on rows.

```{r histogram_facetgrid_row, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) +
  geom_histogram(fill="#2B4C6F") +
  facet_grid(band_type ~ .)
```

Faceting on both dimensions:

```{r histogram_facetgrid_row_col, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) +
  geom_histogram(fill="#2B4C6F") +
  facet_grid(band_type ~ press_type)
```

When you have a categorical variable with many levels, it does not make sense to try and display them all in one row (or one column) and you may want to wrap it. `facet_wrap(~ variable)` wraps a sequence of panels into rows and columns, to better fit screen.

```{r histogram_facetwrap, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) +
  geom_histogram(fill="#2B4C6F") +
  facet_wrap(~ press_type)
```

<!--

Lo tolgo perchè si approfondirà nel capitolo facet 

Mapping `fill` to the faceting variable (`press_type`) returns a different coloured histogram for each panel.

```{r histogram_facetwrap_fill, message=FALSE, warning=FALSE, purl=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) +
  geom_histogram(mapping=aes(fill=press_type)) +
  guides(fill=FALSE) +
  facet_wrap(~ press_type)
```

-->

## Making a density histogram

To show densities instead than count (frequencies) on the y axis, the special variable `..density..` must be used.

```{r histogram_density, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct, y=..density..)) +
  geom_histogram(fill="#74a9cf")
```

The special variables in `ggplot` with double periods around them, as `..density..`, are returned by a `stat` transformation of the original dataset. 

A density curve can be added to compare the theoretical and observed distributions.

```{r density_curve, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct, y=..density..)) +
  geom_histogram(fill="#74a9cf") + 
  geom_density(colour="#034e7b")
```

`geom_density()` function draws a kernel density curve, which is an estimate of the population distribution, based on the sample
data. 

`geom_density()` function draws a closed polygon. If you do not like the lines along the side and bottom, you can draw a density curve using `geom_line` with `stat="density"`.

```{r density_line, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct, y=..density..)) +
  geom_histogram(fill="#74a9cf") + 
  geom_line(stat="density", colour="#034e7b")
```

In particular, `geom_line()`is used with `"density"` statistical transformation, which means that a statistical transformation is applied to data, in particular `ink_pct` density is estimated. 

<!--
This is essentially the same as using `geom_density()`, except the former draws it with a closed polygon.
-->

<!--
sistemare la frase sopra
-->

## Making a Density curve 

As we said, a density curve, in particular a kernel density curve, is an estimate of the population distribution, based on the sample data.

We have already seen how `geom_density()` works. Let us deepen its functionalities.

Suppose we want to analyze the density distribution estimation of `ink_pct` variable. To better visualize the area under the curve you can customize it by setting `fill` and `alpha` arguments:

```{r density_curve_fill, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) + 
  geom_density(fill = "red", alpha = 0.6)
```

The amount of smoothing depends on the kernel bandwidth: the larger the bandwidth, the more smoothing there is. The bandwidth can be set with the adjust parameter, which has a default value of 1:

```{r density_curve_smooth, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) + 
  geom_density(adjust = 0.5)
```

<!--
You can set a value for `adjust` also by using `geom_line(stat="density")`.
-->

`geom_density()` can be used also to compare density distribution estimations of grouped data. The grouping variable must be map to an aesthetic like `colour` or `fill`. The grouping variable must be a factor or character vector. In this case we consider `band_type` variable:    

```{r density_curve_groups, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct, colour = band_type)) + 
  geom_density()
```

## Frequency polygon

A frequency polygon appears similar to a kernel density estimate curve, see in the previous examples, but it work in the same way and it shows the same information as an histogram. In particular, both bin the data and then count the number of observations in each bin. The only difference is the display: histograms use bars and frequency polygons use lines. 

<!--
That is, like a histogram, it shows what is in the data, whereas a kernel density estimate is just that an estimate and requires you to pick some value for the bandwidth.
-->

Suppose we want to analyze the distribution of `ink_pct` variable. `ggplot2` function that draws a frequency polygon is `geom_freqpoly()`:

```{r frequency_polygon, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) +
  geom_freqpoly(col = "darkgreen")
```

Also like a histogram, you can control the bin width for the frequency polygon:

```{r frequency_polygon_binwidth, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) +
  geom_freqpoly(col = "darkgreen", binwidth=10)
```

If you don't want evenly spaced bins you can set the `breaks` arguments:

```{r frequency_polygon_breaks, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) +
  geom_freqpoly(col = "darkgreen", breaks=c(30, 32, 36, 41, 45, 53, 59, 64, 72, 77, 81, 87, 91))
```



