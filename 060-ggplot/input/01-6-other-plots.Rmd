---
title: "Creating other plots"
output: html_document
---

```{r options, include=FALSE, purl=FALSE}
options(width = 108)
```

```{r first, include=TRUE, purl=TRUE, message=FALSE}
require(ggplot2)
require(qdata)
data(bands)
```


## Making a Density Curve

A Density Curve, in particular a kernel density curve, is an estimate of the population distribution, based on the sample data.

Let us consider the distribution of `ink_pct` variable of `bands` dataset.

As seen in "How to make an Histogram" chapter a density curve can be plotted by using two methods:

* with `geom_density()`:

```{r histogram_geomdensity, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) + 
  geom_density()
```
  Like `geom_histogram()`, `geom_density()` requires just one column from a dataframe.

* with `geom_line(stat="density")`:

```{r , message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) + 
  geom_line(stat="density")
```

<!--.
The difference between the two methods is that of `geom_line(stat="density")` don’t draw the lines along the side and bottom. 
-->

In particular, `geom_line()` and is used with `"density"` statistical transformation, which means that a statistical transformation is applied to data, in particulare `ink_pct` density is estimated. This is essentially the same as the first method, using `geom_density()`, except the former draws it with a closed polygon.

To better visualize the area under the curve you can customize it by setting `fill` and `alpha` arguments:

```{r , message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) + 
  geom_density(fill = "red", alpha = 0.6)
```

The amount of smoothing depends on the kernel bandwidth: the larger the bandwidth, the more smoothing there is. The bandwidth can be set with the adjust parameter, which has a default value of 1:

```{r , message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) + 
  geom_density(adjust = 0.5)
```

You can set a value for `adjust` also by using `geom_line(stat="density")`.

You can also making multiple density curves from grouped data with `geom_density()`. The grouping variable must be map to an aesthetic like colour or fill. The grouping variable must be a factor or character vector. In this case we consider `band_type` variable:

```{r , message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct, colour = band_type)) + 
  geom_density(adjust = 0.5)
```

## Making a Violin Plot

Suppose we want to compare the distribution of `ink_pct` by `press_type`: 

```{r}
ggplot(data=bands, mapping=aes(x=ink_pct, colour = press_type)) + 
  geom_density()
```

You can see that with ordinary density curves, it is difficult to compare more than just a few distributions because the lines visually interfere with each other. 

A solution can be the violin plot, which is another way of comparing multiple density estimates of data distributions. In particular, a violin plot is a kernel density estimate, mirrored so that it forms a symmetrical shape.

```{r}
ggplot(data=bands, mapping=aes(x = press_type, y=ink_pct)) + 
  geom_violin()
```

As you can see, with a violin plot, it's easier to compare several distributions since they’re placed side by side.

`geom_violin()` is the function that draws violin plot and unlike `geom_density()` it needs the mapping of both axis. Like a boxplot, usually the continuous variable is mapped on `y` axis and the categorical variable on `x` axis.

The default range of violin plot goes from the minimum to maximum data values; the flat ends of the violins are at the extremes of the data. It’s possible to keep the tails, by setting `trim=FALSE`:

```{r}
ggplot(data=bands, mapping=aes(x = press_type, y=ink_pct)) + 
  geom_violin(trim=FALSE)
```

By default, the violins are scaled so that the total area of each one is the same. Instead of equal areas, you can use `scale="count"` to scale the areas proportionally to the number of observations in each group:

```{r}
ggplot(data=bands, mapping=aes(x = press_type, y=ink_pct)) + 
   geom_violin(scale="count")
```

To change the amount of smoothing, use the `adjust` parameter. The default value is 1; use larger values for more smoothing and smaller values for less smoothing:

```{r}
ggplot(data=bands, mapping=aes(x = press_type, y=ink_pct)) + 
   geom_violin(adjust=0.5)
```

## Making a Density Plot of Two-Dimensional Data

Density plots can be realized also for two-dimensional (2D) data, making a 2D kernel density estimate. 
A two-dimensional kernel density estimate is generated by `geom_density2d()`, which is analogous to the one-dimensional density estimate generated by `geom_density()`, but of course, it needs to be viewed in a different way. 
The default is to use contour lines. 

Suppose we are interested in the relationship between `humidity` and `viscosity` in bands dataset:

```{r}
ggplot(data=bands, mapping=aes(x = humidity, y=viscosity)) + 
  geom_density2d()
```

The density contour can be plotted also along with the data points:

```{r}
ggplot(data=bands, mapping=aes(x = humidity, y=viscosity)) + 
  geom_point() +
  geom_density2d()
```

It’s also possible to map the height of the density curve to the color of the contour lines, by mapping `..level..` to `colour` scale:

```{r}
ggplot(data=bands, mapping=aes(x = humidity, y=viscosity)) + 
  stat_density2d(aes(colour=..level..))
```

Besides contour lines it is also possible to use tiles and map the density estimate to the fill color, or to the transparency of the tiles.

Let us see two examples, in which we use `stat_density2d()` which is the analogous of `geom_density2d()`:

<!--
modificare la frase sopra
-->

```{r}
ggplot(data=bands, mapping=aes(x = humidity, y=viscosity)) + 
  stat_density2d(aes(fill=..density..), geom="raster", contour=FALSE)
```


```{r}
ggplot(data=bands, mapping=aes(x = humidity, y=viscosity)) + 
  geom_point() +
  stat_density2d(aes(alpha=..density..), geom="tile", contour=FALSE)
```


We used `geom="raster"` in the first of the preceding examples and `geom="tile"` in the second. The main difference is that the `"raster"` geom renders more efficiently than the `"tile"` geom. In theory they should appear the same, but in practice they often do not. If you are writing to a PDF file, the appearance depends on the PDF viewer. On some viewers, 
when tile is used there may be faint lines between the tiles, and when raster is used the edges of the tiles 
may appear blurry (although it doesn’t matter in this particular case).

As with the one-dimensional density estimate, you can control the bandwidth of the estimate. 
To do this, pass a vector for the x and y bandwidths to `h` argument. This argument gets passed on to the function that actually generates the density estimate, `kde2d()`. In the following example, we use a smaller bandwidth in the x and y directions, so that the density estimate is more closely fitted (perhaps overfitted) to the data:

```{r}
ggplot(data=bands, mapping=aes(x = humidity, y=viscosity)) + 
  stat_density2d(aes(fill=..density..), geom="raster", contour=FALSE, h=c(.5,5))
```



