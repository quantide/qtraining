---
title: "Reactive Programming"
output: html_document
---

```{r options, include=FALSE, purl=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, fig.pos = 'H', fig.width = 4, fig.height = 3)
options(width = 108)
```


## What is reactive programming?

In Shiny Apps, when you change the input your output updates. For example when you select a shorter time span, the time series updates and a shorter time span is showed in the plot.

Reactivity is complex, but we'll try to make it as simple as possible here. In simple words, it means that when the value of a variable `x` changes, then anything that relies on x gets re-evaluated. This is not as obvious in `R`. As an example, suppose you assign a value to a variable `x` and then build an object `y` that depends on it:

```{r reactivity}
x <- 10
y <- 10*2
```

If you change the values assigned to `x`, `y` is not re-evaluated:


```{r reactivity2}
x <- 20
y
```

If `x` and `y` are reactive variables, then the value of `y` would be 40 because it would be updated whenever `x` is changed. Only reactive variables behave this way, and in Shiny all inputs are automatically reactive. So, if you use `input$x` in render functions, you can be sure that whatever output depends on `x` will use the updated value of `x` whenever `x` changes.


You can think of reactivity as a process that starts a chain reaction: when one reactive value changes, anything that depends on it will get updated. If any of the updated values are themselves reactive variables, then any reactive contexts that depend on those variables will also get updated in turn. 


## Reactive variables and reactive context in Shiny

Reactivity in Shiny is made of two sides: _reactive variables_ and _reactive contexts_. Reactive variables can be used only inside reactive contexts.


The input list in Shiny is a reactive variable and as so, it can only be used inside reactive contexts. Any `render` function is a reactive context in Shiny. So whenever you place `input$my_input` inside a render function, you know you are doing right. 


Note that if you try to access a reactive variable outside a reactive context, you will get an error when running the app:

```{r reactivity3}
print(input$yearInput)
```

`Operation not allowed without an active reactive context. (You tried to do something that can only be done from inside a reactive expression or observer.)`

So how can you, for example, print the value of a reactive variable? The `observe({})` function allows you to access reactive variables. So, if you now run the following code, inside your server function in your App, everything should work smoothly:

```{r reactivity4}
observe({print(input$yearInput)})
```


Now the `print()` function works just as you expected and it also updates when the input changes. In other words, the `observe({})` function makes the code inside of it running again, and the new value will then be printed. The `observe({})` function creates a reactive context: the code inside it, will get re-run whenever any of the reactive variables in it gets updated.


This may be useful when you are debugging your code and you want to know what value a reactive variable holds: you need to wrap `cat(input$x)` or `print(input$x)` in an `observe({})` function.


So, with regards to reactive content, we have so far seen "the natural" reactive content with `render` and how to create reactive contents with the `observe({})` function.

<!-- todo: correct the terminology here -->

With regards to reactive variables, "the natural" reactive variable is `input$`, but you can also create your own reactive variables. To do so, you need to use the `reactive({})` function. 


The `reactive({})` function is similar to `observe({})` as it is also a reactive content, but it is different because `reactive({})` returns a value.


Let us see it in action and create a variable called `timeSpan` that will be the difference between the maximum and minimum year selected. One may simply try to define:

```{r reactive5}

timeSpan <- diff(input$yearInput)

```

and if you insert it in your server function and run it, you get the same error as before about doing something outside a reactive context. This is because `input$yearInput` is a reactive variable, and we can’t use a reactive variable outside a reactive context. Since we want to assign a value, we use the reactive({}) function. Try adding the following line to your server:

```{r reactive6}
timeSpan <- reactive({
  diff(input$yearInput)
})
```

Now if you insert the above code in your app and run, it will work just as fine. 

If you want to access a reactive variable defined with `reactive({})`, you must add parentheses after the variable name, as if it was a function. So, for example, if you would like to print `timeSpan`:

```{r reactive7}
observe({ print(timeSpan()) })
```

So, basically to acces the variable you just created you simply use `timeSpan()` instead of `timeSpan`, just as if, in base `R` you were accessing a function instead of a variable.


To learn more about reactivity visit the [RStudio website](https://shiny.rstudio.com/articles/reactivity-overview.html).


## Dealing with code duplication

Now that we have learned the concept of reactivity, we may make a step forward and see how we can use reactivity to deal with some other problems that do not seem explicitely related to it.


Consider now the code for producing the shiny app (not that we used for shinydashboard). 

```{r}


require(tidyverse)
require(shiny)

load("../data/comics_data.RData")

ui <- fluidPage(
	titlePanel("Comic Characters"),
	em("Here is a visualisation of Comic Characters Data"), 
	br(), 
	br(),
	sidebarLayout(
		sidebarPanel(
			radioButtons("publisherInput", "Publisher", choices = c("DC", "Marvel"),
									 selected = "DC"),
			br(),
			br(),
			selectInput("alignInput", "Character Type",
									choices = c("Good Characters", "Bad Characters", "Neutral Characters")),
			br(),
			br(),
			sliderInput("yearInput", "Year", 1939, 2013, c(1990, 1995))),
		mainPanel(plotOutput("timeSeries"),
							br(),
							br(),
							dataTableOutput("tableResults"))
	)
)

server <- function(input, output) {
	output$timeSeries <- renderPlot({
		filtered <- comics_data %>% 
			filter(year >= input$yearInput[1],
						 year <= input$yearInput[2],
						 align == input$alignInput,
						 publisher == input$publisherInput) %>%
			group_by(year, sex) %>%
			summarise(new_chars = n())
		ggplot(filtered, aes(x = year, y = new_chars, group = sex)) +
			geom_line(aes(colour = sex))
	})
	output$tableResults <- renderDataTable({
		filtered <- comics_data %>% 
			filter(year >= input$yearInput[1],
						 year <= input$yearInput[2],
						 align == input$alignInput,
						 publisher == input$publisherInput) %>%
			group_by(year, publisher) %>%
			summarise(new_chars = n())
		filtered
	})
	
}

shinyApp(ui = ui, server = server)
```


You may have noticed that we have the exact same code filtering the dataset in two places, once in each render function. One way to solve solve this problem may be to define a reactive variable that will hold the filtered dataset, and then use that variable in the render functions.

Let us start by creating the reactive variable, by adding the following code to the server function:

<!-- todo: Here add the function before the reactive (app2-function) only server modified-->

```{r reactivity8}
filtered <- reactive({
  comics_data %>% 
    filter(year >= input$yearInput[1],
           year <= input$yearInput[2],
					 align == input$alignInput,
					 publisher == input$publisherInput) %>%
    group_by(year, publisher) %>%
    summarise(new_chars = n())
})
```

The filtered datset is being defined like before but the body is wrapped by the `reactive({})` function, and it’s defined outside the individual `render` functions. 

Now, we can use it in the output render functions so that your server function looks like this:

```{r reavtivity9}

server <- function(input, output) {
	filtered <- reactive({
		comics_data %>% 
			filter(year >= input$yearInput[1],
						 year <= input$yearInput[2],
						 align == input$alignInput,
						 publisher == input$publisherInput) %>%
			group_by(year, sex) %>%
			summarise(new_chars = n())
	})
	output$timeSeries <- renderPlot({
		ggplot(filtered(), aes(x = year, y = new_chars, group = sex)) +
			geom_line(aes(colour = sex))
	})
	output$tableResults <- renderDataTable({
		filtered()
	})
}

shinyApp(ui = ui, server = server)
```

<!-- 

Questo file lo chiamerei 06-02-reactive.Rmd

add app1-isolate.R

add app3-eventReactive.R 

---

Nuovo file 06-03-observe.Rmd

add app4-observeEvent-and-reactiveValues.R

add app5-observe.R

-->

