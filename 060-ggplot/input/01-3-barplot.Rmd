---
title: "Creating a Bar Plot"
output: html_document
---

```{r options, include=FALSE, purl=FALSE}
options(width = 108)
```

```{r first, include=TRUE, purl=TRUE, message=FALSE}
require(dplyr)
require(ggplot2)
require(qdata)
data(bands)
```

Bar plots are used to display numeric values for different categories. Although they appears similar to Histograms, these plots are very different: bar plots are used for categorical x values, bars should be spaced and the weight of the bar has no meaning while histograms are used for continuous x values, bars (that are called _bins_) must not be spaced and the weight of bins depends on data.

To avoid confusion between bar plots and histograms, some authors suggest to build bars horizontally.

```{r bargraphs, message=FALSE, echo=FALSE, purl=FALSE}
ds = data.frame(x=factor(1:4), y=c(4,2,6,5))

ggp <- ggplot(data=ds, aes(x=x, y=y)) +
  geom_bar(stat="identity", fill=c("#74a9cf", "#3690c0", "#0570b0", "#034e7b")) + 
  theme(axis.text.x = element_blank(), axis.text.y = element_blank())

ggp1 <- ggp +
  xlab("Discrete variable\n(x)") + ylab("Frequencies\n(y)")

ggp2 <- ggp +
  xlab("Discrete variable\n(y)") + ylab("Frequencies\n(x)") +
  coord_flip()

gridExtra::grid.arrange(ggp1, ggp2, ncol=2)
```

This chapter presents how to build bar plots and introduces other basic concepts of `ggplot2` grammar: `stat` (layers) and positioning. 

## The first bar plot

As seen in the previous chapter, chicks receive one of four diets (see `ChickWeight` data set). A graphical summary about how chicks receive each diet can be obtained.

```{r bargraph_first, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) + 
  geom_bar()
```

If you prefer horizontal bars, just flip the plot with `coord_flip()`.

```{r bargraph_coordflip, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) + 
  geom_bar() + 
  coord_flip()
```

Another way to distinguish bar plots and histograms are tiny bars, to increase the space among bars.

```{r bargraph_width, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) + 
  geom_bar(width=0.5)
```

## Setting and mapping variables to bar plots

Colours and other available aesthetic settings (`linetype` and `size`) can be set or mapped as usual. Remember that `colour` controls the bar outline, while `fill` controls the bar colour.

```{r bargraph_setcolour, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) +
  geom_bar(fill=c("#74a9cf", "#3690c0", "#0570b0", "#034e7b"))
```

```{r bargraph_scalefill, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) +
  geom_bar(mapping=aes(fill=Diet)) +
  scale_fill_manual(values=c("#74a9cf", "#3690c0", "#0570b0", "#034e7b"))
```

These plots are identical except that for legend, but they are based on two different approaches. In the first plot, fill colours are set. If you do not set four different fill colours, all bars have the same colours as shown above. In the second plot, fill colours are mapped to the levels of `Diet`. Since each bar represents a different type of diet, each bar has a different colour also when you do not set manually fill colours with `scale_fill_manual()`.

```{r bargraph_mapping, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) +
  geom_bar(mapping=aes(fill=Diet))
```

The use of `scale_fill_manual()` allows you to choose which colours should be used. Since fill colours are mapped with a variable, in this case the legend will be shown. In this case the legend is useless, because the same aesthetic is mapped to `x` and you already know which Diet refer to each colour. You can hide the legend in `scale_fill_manual()`.

```{r bargraph_nolegend_scale, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) +
  geom_bar(mapping=aes(fill=Diet)) +
  scale_fill_manual(values=c("#74a9cf", "#3690c0", "#0570b0", "#034e7b"), guide=FALSE)
```

<!--

giÃ  scritto nel capitolo legende
Alternatively, you can use the `guides` function to hide the legend, just setting to `FALSE` the related aesthetic, in this case `fill`.

```{r bargraph_nolegend_guides, message=FALSE, purl=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) +
  geom_bar(mapping=aes(fill=Diet)) +
  scale_fill_manual(values=c("#74a9cf", "#3690c0", "#0570b0", "#034e7b")) +
  guides(fill=FALSE)
```

-->

`ggplot2` provides some functions (e.g. `scale_*_brewer` or `scale_*_gradient`) to choose a palette (i.e. a set of coherent colours), but these functions will be shown in _Mapped Aestethics Customization_ chapter. You can still use `scale_*_manual` functions and refer to some on-line tool like [Color Brewer](http://colorbrewer2.org/) or [Paletton](http://paletton.com/) for a better choice of colours.


## Summarized data and `stat`s

Sometimes data comes already summarized. As an example, you can have the following frequency tables without the original data.

```{r bargraph_ChickWeightFreq, message=FALSE}
ChickWeightFreq <- ChickWeight %>% 
  group_by(Diet) %>% 
  summarize(n=n())

ChickWeightFreq
```

You can try to build the previous plot in the same way.

```{r bargraph_error, message=FALSE}
ggplot(data=ChickWeightFreq, mapping=aes(x=Diet)) + 
  geom_bar()
```

The result is a plot with four bars of length 1. Why? The reason is quite simple. By default, `geom_bar()` scans the `Diet` column counting how many observations have Diet=1, how many have Diet=2 and so on. In this case, you must tell `ggplot` you already have the count.

```{r bargraph_identity, message=FALSE}
ggplot(data=ChickWeightFreq, mapping=aes(x=Diet, y=n)) + 
  geom_bar(stat="identity")
```

Since you have an `y` variable containing frequencies, you tell `ggplot` the variable containing counts (`y=n` in the example) and to `geom_bar` that `stat="identity"` must be used. 

A statistical transformation, or `stat`, transforms the data, typically by summarizing it in some manner. All `geom`s are based on a statistical transformation. By default, almost all `geom`s seen until now uses `stat="identity"`, that do not transform data. As just seen, by default `geom_bar()` uses `stat="count"` that counts the number of cases at each `x` position. If you do not want to transform your data, `stat="identity"` must be supplied.


## Stacked and grouped bar plots

If you are a quality engineer analysing the `bands` data, you may be interested to the number of presses for each type, distinguishing them by the cylinder size.

```{r bargraph_stack, message=FALSE}
ggplot(data=bands, mapping=aes(x=press_type, fill=cylinder_size)) + 
  geom_bar()
```

Mapping `fill` to `cylinder_size` does the job. Notice a small gray area at the top of the last two bars: this means there are few cases in which `cylinder_size` is missing. 

Sometimes you may be interested at the distribution of `cylinder_size` for each `press_type`.

```{r bargraph_fill, message=FALSE}
ggplot(data=bands, mapping=aes(x=press_type, fill=cylinder_size)) + 
  geom_bar(position="fill")
```

In the case you prefer a bar for each combination of `press_type` and `cylinder_size`, you can `dodge` the bars.

```{r bargraph_dodge, message=FALSE}
ggplot(data=bands, mapping=aes(x=press_type, fill=cylinder_size)) + 
  geom_bar(position="dodge")
```

Notice that `position="dodge"` is a short key for `position=position_dodge()` with its default value and you can modify this value to add space between bars. In the case you want to add space between bars, you probably want also to modify the `width` in order to add spaces among each group of bars.

```{r bargraph_manualdodge, message=FALSE}
ggplot(data=bands, mapping=aes(x=press_type, fill=cylinder_size)) +
  geom_bar(position=position_dodge(0.85), width=0.6)
```

The `width` in `geom_bar()` determines the width of the bar; the `width` in `position_dodge()` determines the position of each bar. Probably you can easily understand their behaviour after you play with them for a while.

All data related to `MOTTER70` press has `CATALOG` as `cylinder_size`. In this case, the bars related to other `cylinder_size` are missing and the `MOTTER70` bar will expand to fill the whole space.

To avoid this behaviour you must have at least a `NA` value for each combination of factors. Since both `ggplot2` when you plot and `dplyr` when you build a frequency table, do not show the count for missing combinations, you should manually build a frequency table like the following one.

```{r bargraph_bands_freq_na, message=FALSE}
bands_freq_na <- bands %>% group_by(press_type, cylinder_size) %>% summarise(n = n()) %>%
  right_join(
    expand.grid(
      press_type = bands %>% magrittr::use_series(press_type) %>% levels,
      cylinder_size = c(bands %>% magrittr::use_series(cylinder_size) %>% levels, NA)
    )
  )
bands_freq_na
```

At this point, you can easily build the plot starting from frequency table. Just remember to map the counts to `y` and to add `stat="identity"` to `geom_bar()`.

```{r bargraph_stack_na, message=FALSE}
ggplot(data=bands_freq_na, mapping=aes(x=press_type, y=n, fill=cylinder_size)) +
  geom_bar(stat="identity", position="dodge")
```

As you see in the previous plots, `cylinder_size` is a factor variable with three levels: `CATALOG`, `SPIEGEL` and `TABLOID` but it has also missing values (`NA`).   
To visualize also missing values (`NA`) as `cylinder_size` level in plots legend, you have to recode its levels, adding also `NA` as level.  

```{r bargraph_na_as_level, message=FALSE}
bands <- bands %>% 
  mutate(cylinder_size = as.character(cylinder_size), 
         cylinder_size =ifelse(is.na(cylinder_size),"NA",cylinder_size), 
         cylinder_size = factor(cylinder_size, 
                                levels= c("CATALOG", "SPIEGEL", "TABLOID", "NA"), 
                                labels = c("CATALOG", "SPIEGEL", "TABLOID", "NA")))

ggplot(data=bands, mapping=aes(x=press_type, fill=cylinder_size)) +
  geom_bar() 
```


## Adding text to plots

Plots are useful to catch the eye of your audience but sometimes they cannot replace numbers or text. Adding text to a plot can help you to integrate information in your plot.

```{r bargraph_geomtext, message=FALSE}
bands_freq <- bands %>% group_by(press_type) %>% summarize(n=n())
  
ggplot(data=bands, mapping=aes(x=press_type)) +
  geom_bar() +
  geom_text(data=bands_freq, mapping=aes(y=n, label=n), vjust=1.5, colour="white")
```

`geom_text()` works as any other `geom` seen until now. It requires `x` and `y` coordinates; in this case, `x` is `press_type` and it is inherited from `ggplot()`, while `y` should be passed. Since `bands` data do not contains the count, that is computed by `stat_count` inside `geom_bar()`, default data are overwritten in `geom_text()` in order to use frequencies. `geom_text()` requires `label` that is the text to be written. Outside `aes()`, `vjust` move down (or up) the text and `colour` set text colour.

