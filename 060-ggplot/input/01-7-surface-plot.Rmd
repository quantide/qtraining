---
title: "Creating a Surface plot"
output: html_document
---

```{r, first, include=TRUE, purl=TRUE, message=FALSE}
require(ggplot2)
require(dplyr)
require(qdata)
require(MASS)
data(bands)
```

`ggplot2` does not support true 3d surfaces. However it does support many common tools for representing 3d surfaces in 2d: contours, coloured raster (tiles) and bubble plots. These all works similarly, differing only in the aesthetic used for the third dimension.  

```{r surface_plots, message=FALSE, warning=FALSE, echo=FALSE, purl=FALSE, fig.width=10}
# excude NA
bands_na_rm <- bands %>% na.omit() 
# compute bivariate density
f2d <- kde2d(bands_na_rm$humidity, bands_na_rm$viscosity, n =100)

bands_d <- expand.grid(humidity = f2d$x, viscosity = f2d$y) %>%
  tbl_df() %>%
  mutate(density = as.vector(f2d$z))
# data
bands_d_sample <- bands_d %>% sample_n(size = 500)

# Plots
ggp1 <- ggplot(bands_d, aes(humidity, viscosity, z = density)) + 
  geom_contour(aes(colour = ..level..)) + 
  scale_color_continuous("z") +
  ggtitle("Contour Plot") +
  xlab("x") + ylab("y") +
  theme(axis.ticks = element_blank(),
        axis.text = element_blank())
  
ggp2 <- ggplot(bands_d, aes(humidity, viscosity)) +
 geom_raster(aes(fill = density)) +
  scale_fill_continuous("z") +
  ggtitle("Raster (Tiles) Plot") +
  xlab("x") + ylab("y") +
  theme(axis.ticks = element_blank(),
        axis.text = element_blank())

ggp3 <- ggplot(bands_d_sample, aes(humidity, viscosity)) +
  geom_point(aes(size = density), alpha =1/3, colour = "blue", fill = "lightblue") +
  scale_size_area("z") +
  ggtitle("Bubble Plot") +
  xlab("x") + ylab("y") +
  theme(axis.ticks = element_blank(),
        axis.text = element_blank())


gridExtra::grid.arrange(ggp1, ggp2, ggp3,ncol=3)
```

This chapter explains how to build contours, coloured raster (tiles) and bubble plots.

## Contour 

A contour plot is a graphical technique for representing a 3-dimensional surface by plotting constant z slices, called contours, on a 2-dimensional format. That is, given a value for z, lines are drawn for connecting the (x,y) coordinates where that z value occurs.


Suppose we want to analize the relationship between `humidity` and `viscosity` variables of `bands` dataset considering also the bivariate density estimate between these variables.

First of all let us compute bivariate density estimate between `humidity` and `viscosity`: 

```{r bivariate_density_computation, eval=FALSE}
# remove NA from bands dataset 
bands_na_rm <- bands %>% na.omit() 

# Compute bivariate density estimate
f2d <- kde2d(bands_na_rm$humidity, bands_na_rm$viscosity, n =100)

# Generate a new dataset including also the newly created variable  
bands_d <- expand.grid(humidity = f2d$x, viscosity = f2d$y) %>%
  tbl_df() %>%
  mutate(density = as.vector(f2d$z))
```

Contour can be plotted by `geom_contour()` function:

```{r contour_first}
ggplot(bands_d, aes(humidity, viscosity, z = density)) + 
  geom_contour()
```

The third dimension is mapped to `z` aestethic of `ggplot()` function. In this case, `z` is set to `density`. 

<!--
```{r, echo=FALSE, purl=FALSE}
data("faithfuld")
ggplot(faithfuld, aes(waiting, eruptions, z = density)) + 
  geom_contour()
```


A similar plot can be represented also by using `geom_density_2d()` function:

```{r, purl=FALSE}
ggplot(bands, aes(humidity, viscosity)) +
  geom_density_2d()
```

The difference between `geom_contour()` and `geom_density_2d()` is that `geom_density_2d()` doesn't need the definition of the third dimension as it automathically computes a two-dimensional kernel density estimate and countour is its default representation.  


```{r, purl=FALSE}
ggplot(faithful, aes(waiting, eruptions)) +
  geom_density_2d()
```
-->

You can set bins, by using `bins` argument, to generate evenly spaced contours in the range of the data:

```{r contour_bins}
ggplot(bands_d, aes(humidity, viscosity, z = density)) + 
  geom_contour(bins = 2)

ggplot(bands_d, aes(humidity, viscosity, z = density)) + 
  geom_contour(bins = 10)
```

<!--
```{r, purl=FALSE}
ggplot(faithfuld, aes(waiting, eruptions, z = density)) + 
  geom_contour(bins = 2)

ggplot(faithfuld, aes(waiting, eruptions, z = density)) + 
 geom_contour(bins = 10)
```
-->

You can also parameterize the distance between contours setting `binwidth` argument, which represent the binwidth of countour lines:

```{r contour_bindwidth}
ggplot(bands_d, aes(humidity, viscosity, z = density)) + 
  geom_contour(binwidth = 0.0001)
```


<!--
```{r, purl=FALSE}
ggplot(faithfuld, aes(waiting, eruptions, z = density)) + 
  geom_contour(binwidth = 0.01)
```
-->

We can customize the countour plot by changing `colour`, `linetype` or line `size`: 

```{r, contour_settings}
ggplot(bands_d, aes(humidity, viscosity, z = density)) + 
  geom_contour(colour = "darkgreen", linetype = 6, size = 1)
```


It is also possible to map the height of the density curve to the color of the contour lines, by mapping `..level..` to `colour` scale:

```{r, contour_colour_mapped}
ggplot(bands_d, aes(humidity, viscosity, z = density)) + 
  geom_contour(aes(colour = ..level..))
```

`..level..` is a variables generated by the statistical transformation used by `geom_contour()` function.

Mapping `..level..` to `colour` a legend is automathically produced.  

<!--
```{r, purl=FALSE}
ggplot(faithfuld, aes(waiting, eruptions, z = density)) + 
  geom_contour(aes(colour = ..level..))
```
-->


<!--
```{r, purl=FALSE}
ggplot(faithfuld, aes(waiting, eruptions, z = density)) + 
  geom_contour(colour = "green", linetype = 4, size = 1)
```
-->

You can also customize your plot by adding in background another `geom` which draws surfaces: `geom_raster()` in order to increase the 3d effect.

```{r contour_raster_plot}
ggplot(bands_d, aes(humidity, viscosity, z = density)) + 
  geom_raster(aes(fill = density)) +
  geom_contour(colour = "white")
```

<!--
```{r, purl=FALSE}
# Customize
ggplot(faithfuld, aes(waiting, eruptions, z = density)) + 
  geom_raster(aes(fill = density)) +
  geom_contour(colour = "white")
```
-->

## Raster (Tiles) Plot

A raster (tiles) plot is a scan pattern in which an area is scanned from side to side in lines from top to bottom. It can be defined also as  a pattern of closely spaced rows of dots that form an image.

As you saw in the previous example, raster plot is generated by `geom_raster()`.  
`geom_raster()` is a function for drawing rectangles. The most common use for rectangles is to draw a surface. If you want to draw surfaces you have to map the variable that represent the third dimension, in this case `density`, to `fill` aestethic:

```{r rasterplot_first}
ggplot(bands_d, aes(humidity, viscosity)) + 
   geom_raster(aes(fill = density))
```

<!--
```{r, purl=FALSE}
ggplot(faithfuld, aes(waiting, eruptions)) +
 geom_raster(aes(fill = density))
```
-->

You can also add an interpolation to smooth the surface, by setting `interpolate = TRUE`. It is useful when rendering images.


```{r rasterplot_interpolate}
ggplot(bands_d, aes(humidity, viscosity)) + 
   geom_raster(aes(fill = density), interpolate = TRUE)
```

<!--
```{r, purl=FALSE}
ggplot(faithfuld, aes(waiting, eruptions)) +
 geom_raster(aes(fill = density), interpolate = TRUE)
```
-->

A similar result can be achieved by using `geom_tile()` function. `geom_tile()` is similar to `geom_raster()` as both draw rectangles.
The main difference is that `geom_raster()` renders more efficiently than `geom_tile()`. In theory they should appear the same, but in practice they often do not. If you are writing to a PDF file, the appearance depends on the PDF viewer. On some viewers, 
when tile is used there may be faint lines between the tiles, and when raster is used the edges of the tiles may appear blurry.

```{r tileplot}
ggplot(bands_d, aes(humidity, viscosity)) + 
   geom_tile(aes(fill = density))
```

<!--
```{r, purl=FALSE}
ggplot(faithfuld, aes(waiting, eruptions)) +
 geom_tile(aes(fill = density))
```
-->


## Bubble Plot

A bubble plot is another type of plot that displays three dimensions of data. Each entity with its triplet (x, y, z) of associated data is plotted as a disk that expresses x and y through the disk's xy location and z through its size. Bubble charts can be considered a variation of the scatter plot, in which the data points are replaced with bubbles.

It works better with fewer observations so we grab a sample of the original dataset:

```{r sample_dataset, eval = FALSE}
bands_d_sample <- bands_d %>% sample_n(size = 500)
```

```{r bubbleplot_first}
ggplot(bands_d_sample, aes(humidity, viscosity)) +
  geom_point(aes(size = density)) +
  scale_size_area()
```


<!--
```{r, eval=FALSE, purl=FALSE}
small <- faithfuld[seq(1, nrow(faithfuld), by = 10), ]
```

```{r, eval=FALSE, purl=FALSE}
ggplot(small, aes(eruptions, waiting)) +
  geom_point(aes(size = density)) +
  scale_size_area()
```
-->

To generate a bubble plot you have to map the third variable, in this case `density` to `size` aestethic of `geom_point()` function. Then you have to add `scale_size_area()` function to render the area of points proportional to `density`, this means that `scale_size_area()` ensures that a value of 0 is mapped to a size of 0.

You can also specify an `alpha` level, a `colour` and `fill` for bubbles as `geom_point()` settings:

```{r bubbleplot_settings}
ggplot(bands_d_sample, aes(humidity, viscosity)) +
  geom_point(aes(size = density), alpha = 0.4, colour = "blue", fill = "lightblue") +
  scale_size_area()
```

<!--

```{r, eval=FALSE, purl=FALSE}
ggplot(small, aes(eruptions, waiting)) +
  geom_point(aes(size = density), alpha =1/3, colour = "blue", fill = "lightblue") +
  scale_size_area()
```
-->


