---
title: "The server side functions"
output: html_document
---

```{r options, include=FALSE, purl=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, fig.pos = 'H', fig.width = 4, fig.height = 3)
options(width = 108)
```


## Introduction

In this section we will walk you through writing the server functions, which will be responsible for listening to changes to the inputs and creating outputs to show in the app.

As for input and output functions, server functions have quite a standardised structure, i.e. they are always defined with the following two arguments: 

* _input_ : the values of all the different inputs at any given time
* _output_ : a list where output objects (such as tables and plots) will be saved to be then displayed in your app

Each output will be created separately, so as we put placeholders for two types of outputs, we will create two outputs separately.

In general, the steps to build an output in Shiny are the following:

1. Save the output object into the _output_ list
2. Build the object with a `render` function (for example `renderPlot` or `renderTable`)
3. Access input values using the `input` list


## Rendering plots

If we want to render a plot, for example the line plot with the number of new characters as a function of the year, we write the following lines:

```{r output}
output$timeSeries <- renderPlot({
  plot(rnorm(100))
})

```

Since `timeSeries` was defined as a `plotOutput`, we must use the renderPlot function, and we must create a plot inside the renderPlot function. We set `output$object_name` with `object_name` being equal to the object name chosen in the placeholder.


Note that all we are doing is creating a plot inside the `renderPlot()` function, and assigning it to `timeSeries` which is an element in the output list. 


As you may have noticed, the code above just plots a sample of size 100 from a standard normal distribution. We were aiming for something a bit more complicated: we wanted to plot the number of new comic characters created each year from 1938, possibly filtered by sex and character type (bad/good/neutral character). Also, it would be nicer to do so using `ggplot2` package. 

Let us create the visualision the way we like and then embed it in the server function.


First we need to make sure `ggplot2` is loaded together with `dplyr` that we'll use for some data manipulation, so add a `require(tidyverse)`, then we go on with the data visualisation:

```{r}
require(tidyverse)

ggplot(df %>% 
       group_by(year) %>%
       summarise(new_chars = n()), aes(x = year, y = new_chars)) +
  geom_line()

```

And now we embed it in the Shiny app, so that the overall code looks like this:

```{r}
require(tidyverse)
require(shiny)

df <- read_csv("../data/marvel-wikia-data.csv")

ui <- fluidPage(
  titlePanel("Comic Characters"),
  em("Here is a visualisation of Comic Characters Data"), 
      br(), 
      br(),
  sidebarLayout(
    sidebarPanel(
      radioButtons("genderInput", "Gender",
                  choices = c("Female Characters", "Male Characters"),
                  selected = "Female Characters"),
      br(),
      br(),
      selectInput("alignInput", "Character Type",
                  choices = c("Good Characters", "Bad Characters", "Neutral Characters")),
      br(),
      br(),
      sliderInput("yearInput", "Year", 1939, 2013, c(1990, 1995))),
    mainPanel(plotOutput("timeSeries"),
              br(),
              br(),
              dataTableOutput("tableResults"))
  )
)

server <- function(input, output) {
  output$timeSeries <- renderPlot({
    new_df <- df %>% 
         group_by(year) %>%
         summarise(new_chars = n())
    ggplot(new_df, aes(x = year, y = new_chars)) + 
      geom_line()
})
}

shinyApp(ui = ui, server = server)

```

If you run the Shiny app, you will see that the plot is there, but it does not react to your inputs: if you change a different time range, the plot does not update, and so is for comic character gender and character type. Indeed, we have not considered filtering variables yet.


Reall that we have 3 inputs: genderInput, alignInput, and yearInput. We will filter the data based on the values of these three inputs. Weâ€™ll use `dplyr` functions to filter the data and then we will simply plot the filtered data instead of the original data. Your server function should now look like this:


```{r}

server <- function(input, output) {
output$timeSeries <- renderPlot({
  filtered <-df %>% 
    filter(year >= input$yearInput[1],
           year <= input$yearInput[2],
           align == input$alignInput,
           sex == input$genderInput) %>%
    group_by(year) %>%
    summarise(new_chars = n())
  ggplot(filtered, aes(x = year, y = new_chars)) +
    geom_line()
})
}

```

If you replace the old server function with the one above, your Shiny app will contain a time series that updates according to the input!

Of course you can further customise the plot, to add different colours, change the font or change axis names.


## Rendering tables

In the UI we defined the other output as `tableResults`. It is meant to represent just a table with the values showed in the plot. 

This time, we are working with a table output, more specifically, we defined the output as a datatable output. So we use the `renderDataTable()` function. We will do the exact same filtering on the data, and then simply return the data as a `data.table`. 

Again, we first create the filtered dataset, just as we did before, and then ask to just print the datatable:

```{r}

  output$tableResults <- renderDataTable({
    filtered <-df %>% 
      filter(year >= input$yearInput[1],
             year <= input$yearInput[2],
             align == input$alignInput,
             sex == input$genderInput) %>%
      group_by(year) %>%
      summarise(new_chars = n())
    filtered
})

```


## Final UI

Last, let us embed everything into the Shiny app and your code should look like this:

```{r}

require(tidyverse)
require(shiny)

df <- read_csv("../data/marvel-wikia-data.csv")

ui <- fluidPage(
  titlePanel("Comic Characters"),
  em("Here is a visualisation of Comic Characters Data"), 
      br(), 
      br(),
  sidebarLayout(
    sidebarPanel(
      radioButtons("genderInput", "Gender",
                  choices = c("Female Characters", "Male Characters"),
                  selected = "Female Characters"),
      br(),
      br(),
      selectInput("alignInput", "Character Type",
                  choices = c("Good Characters", "Bad Characters", "Neutral Characters")),
      br(),
      br(),
      sliderInput("yearInput", "Year", 1939, 2013, c(1990, 1995))),
    mainPanel(plotOutput("timeSeries"),
              br(),
              br(),
              dataTableOutput("tableResults"))
  )
)

server <- function(input, output) {
output$timeSeries <- renderPlot({
  filtered <-df %>% 
    filter(year >= input$yearInput[1],
           year <= input$yearInput[2],
           align == input$alignInput,
           sex == input$genderInput) %>%
    group_by(year) %>%
    summarise(new_chars = n())
  ggplot(filtered, aes(x = year, y = new_chars)) +
    geom_line()
})
  output$tableResults <- renderDataTable({
    filtered <-df %>% 
      filter(year >= input$yearInput[1],
             year <= input$yearInput[2],
             align == input$alignInput,
             sex == input$genderInput) %>%
      group_by(year) %>%
      summarise(new_chars = n())
    filtered
})
}

shinyApp(ui = ui, server = server)

```




