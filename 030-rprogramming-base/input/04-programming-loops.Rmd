---
title: "Loops in R"
---


## `for` loops

`for` loops, as any other iterators, are common components of almost any programming language. The common structure of a `for` loop in `R` is:

```{r programming-for-01}
languages <- c("C", "C++", "R", "Java", "Python")
for(lang in languages) {
  cat("I love ", lang, "\n")

}
```

or alternatively:
```{r programming-for-02}
languages <- c("C", "C++", "R", "Java", "Python")
n <- length(languages)
for(i  in 1:n) {
  cat("I love ", languages[i], "\n")

}
```


## Good programming practices with `for` loops

### Pre-allocating memory

`for` loops, as any equivalent iterator structure may require quite a long time to complete. Long computing time is quite natural as computational effort linearly increases with the number of iterations in the loop. 

Nevertheless, few little cautions may help to save a sensible amount of time.

As an example, we may calculate the `95%` quantile of the distribution of the correlation coefficient between two `N(0,1)` vectors of given sizes `n=10` by using a simple for loop over `k = 100,000` iterations.

```{r programming-for-03, include =FALSE}
rm(list = ls())
g = gc()
```

```{r programming-for-04, cache=TRUE}
k = 100000
n = 10
z = NULL 
system.time({
    for (i in 1:k) {
    x = rnorm(n , 0, 1)
    y = rnorm(n , 0, 1)
    z = c(z , cor(x, y))
  }
  cat ("95th quantile = " , quantile(z , .95), "\n")
})[3]
```

We can gain a first improvement by _'pre-allocating'_, the vector of results, We tell `R` what the size of the vector is before we begin filling it up. The wrong way to fill in a vector is to allow it to grow dynamically as it happens in the above loop. 

In the above case, R has to store a vector of one element than a second vector of two elements and so on up to a vector of `100,000` elements. As each new vector can't fit inside the RAM allocated to the previous vector, R has to use a  ''new'' bit of contiguous RAM for new vector. 

Thus, instead of using just one chunk of RAM that it takes to make a vector of `k=100,000` and filling it up with one more element at each iteration, R is forced to write the new enlarged vector in Ram at each iteration. Clearly, all of this memory writing takes up time.

Fortunately, R has a quite efficient mechanism for garbage collection and, as a result, memory usage is kept under control. Otherwise, looping without _pre-allocating_ may also cause serious memory usage problems.

Running the previous example, by simply pre-allocating vector `z` before looping, reduces computing time to about half of the previous time. 

```{r programming-for-05, cache=TRUE}
k = 100000
n = 10
z = numeric(k)
system.time({
  for ( i in 1:k){
    x = rnorm(n , 0, 1)
    y = rnorm(n , 0, 1)
    z[i] = cor(x, y)
  }
  cat ("95th quantile = " , quantile(z , .95), "\n")
})[3]
```

Clearly, pre-allocation requires to know in advance the size of the output vector. Whenever this is not possible, as it may happen in while loops, computing time may noticeably increase.

### Vectorized `for` loops

Whenever possible, loops should be replaced with vectorized calculation. This approach improve both performance and clarity.

As an example, we examine a double for loop:

```{r structures-006, cache=TRUE}
slow =  function(x, y) {  
  nx = length(x)
  ny = length(y)  
  xy = numeric(nx + ny - 1)  
  
  for(i in 1:nx) {  
         for(j in 1:ny) {  
              ij = i+j-1  
              xy[ij] = xy[ij] + x[i] * y[j]  
          }  
      }  
      xy  
}  


system.time(slow(runif(1000), runif(1000)))[3]
```

An attempt to vectorize the previous code leads to:

```{r structures-007, cache=TRUE}
fast =  function(x, y) {  
  nx = length(x)
  ny = length(y)  
  xy = numeric(nx + ny - 1)  
  j = 1:ny
  for(i in 1:nx) {  
              ij = i+j-1  
              xy[ij] = xy[ij] + x[i] * y  
      }  
      xy  
}
system.time(fast(runif(1000), runif(1000)))[3]
```

Simply working with vectorized dimensions drastically reduce computing time. Note that `j` index is computed within the `i` loop  and that `y[j]` has been replaced with `y`, as a result, a single for loop is required.



## `while` loops

`for` loops apply when the number of loops is known. Sometimes, one wants to loop until a condition is satisfied. In this case, the `while` statement should be used. Its use is quite simple:

```{r, while0, eval=FALSE}
while(condition) code-to-be-execute
```

If the code is more than one row long, than it must be placed between braces (`{...}`).

The following code, generates random numbers from a Normal Distribution and stops when a value greater than 2 is obtained. The number is assigned to `x` and a message with the number of loops is printed.

```{r programming-while, echo=2:100}
set.seed(355)
n <- 0
x <- 0
while(x <= 3) {
  x <- rnorm(1)
  n <- n + 1
}
cat(n, "loops were executed")
```



