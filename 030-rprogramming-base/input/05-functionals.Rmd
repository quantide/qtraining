---
title: "Functionals"
output: html_document
---

```{r options, include=FALSE, purl=FALSE}
options(width = 108)
```

> "To become significantly more reliable, code must become more transparent. In particular, nested conditions and loops must be viewed with great suspicion. Complicated control flows confuse programmers. Messy code often hides bugs."  
 — Bjarne Stroustrup

`for` loops are quite often nested and mixed up with `if` statements. As a result, the whole coding structure may result in a complicated muddle to understand and, as a consequence, the objective of our coding may get lost within the code itself. `for` loops do have a bad reputation of being slow especially when compared with equivalent functionals structures as `lapply()`. Nowadays, speed is no more a crucial point when dealing with `for` loops. In other words, `for` loops, whenever possible, should be avoided not mainly because of a performance issue but to achieve modularity and clarity in our codes. 

_Functionals_ are functions that take a function as input and return a data object as output. Functionals are very often excellent substitutes to `for` loops as they allow to communicate the objective of our code in a more clear and concise manner as the code will be cleaner and it will more closely adhere to `R`'s idioms.

In this chapter the most important functionals will be analyzed, in particular:

* `lapply()`, which can be consider as the main functional
* `lapply()` friends as `sapply()` and `vapply()`, which perform as `lapply()` but return a simplified output  
* Functionals for matrices and data frames manipulation, as `apply()` and `tapply()`

## `lapply`

`lapply()` is, possibly, the most used functional. `lapply()` takes a function and applies it to each element of a list, saving the results back into a result list. `lapply()` is the building block for many other functionals. In principle, `lapply()` is a wrapper around a standard `for` loop. The wrapper is written in `C` to increase performance. 

`lapply()` takes three arguments: 

* a list `X`, or anything that can be coerced to a list by `as.list()`
* a function `FUN` that takes, as first argument, each element of `X`
* the `''...''` argument that can be any argument to be passed to `FUN`

Suppose we want to gain the maximum of each column for the `airquality` data frame, included in `datasets` package. By using a `for` loop we could write:

```{r functionals-002}
n_col <- ncol(airquality)
out <- numeric(n_col)

for (i in 1:n_col){
 out[i] <- max(airquality[,i], na.rm = TRUE)
}
out
```

alternatively, as a data frame is a list:

```{r functionals-003}
lapply(X = airquality, FUN = max, na.rm = TRUE)
```

The second chunk of code is by far more clear and concise than the first one even though a vector would be preferable than a list as output.

Moreover, `lapply()` as opposite to `for` loops does not produce any intermediate result when running. In the above `for` loop, the value of the result of the loop, vector `out`, changes at each iteration. The result of `lapply()`, instead, can be assigned to a variable but does not produce any intermediate result.

By default `lapply()` takes each element of list `X` as the first argument of function `FUN`. This works perfectly, as long as each element of `X` is the first of `FUN`. This is true in case we want to compute the mean of each column of a data frame as each column is passed as first argument to function `mean()`.

But, suppose we want to compute various trimmed means of the same vector, `trim` is the second parameter of `mean()`, so we want to vary `trim`, keeping the first argument `x` fixed.  

This can be easily achieved by observing that the following two calls are equivalent:

```{r functionals-004}
mean(1:100, trim = 0.1)
mean(0.1, x = 1:100)
```

This is possible because `R` first matches formals by name and afterword by position.

As a result, in order to use `lapply()` with the second argument of function `FUN`, we just need to name the first argument of `FUN` and pass it to `lapply()` as part as the `''...''` argument:

```{r functionals-005}
x <- rnorm(100)
lapply(X = c(0.1, 0.2, 0.5), mean, x = x)
```



## `lapply` friends: `sapply` and `vapply`

`sapply()` and `vapply()` are variants of `lapply()` that produce vectors, matrices and arrays as output, instead of lists.

`lapply()` returns a list as output, in order to get a vector, the previous examples could be written by using `sapply()`, a simple variant of `lapply()`, that tries to return an atomic vector instead of a list. 

```{r functionals-006}
sapply(X = airquality, FUN = max, na.rm = TRUE)
```

Note that `sapply()` is a simple wrapper around `lapply()` that uses `simplify2array()`. 

Unfortunately, `simplify2array()` and therefore `sapply()` offer very little control on the type of output that is returned:

```{r functionals-007}
sapply(list(), is.numeric)
```

In this case we would expect `sapply()` to return a empty logical vector, not an empty list.

As a result, `sapply()` may represent a excellent shortcut when working with R in interactive mode but not a good function to be used when developing serious R code.

A better alternative to `sapply()` is provided by `vapply()` a second variant of `lapply()` that allows to specify, by mean of argument `FUN.VALUE`, the kind of output we want the functional to return. In fact, 

```{r functionals-008}
vapply(list(), is.numeric, FUN.VALUE = logical(1))
vapply(X = airquality, FUN = max, na.rm = TRUE, FUN.VALUE = numeric(1))
```

In this case the `FUN.VALUE` argument specify what kind of output each element of the result should be.
`vapply()` improves consistency by providing either the return type we were expecting or error. This is a clear advantage, as it helps catch errors before they happen and leads to more robust code. 

<!--
As an example, suppose we have a list of data frames:

```{r functionals-009}
df_list <- list(cars, airquality, trees) 
```

and that we need to know the number of columns of each data frame returned in a vector. We can easily achieve this goal by:

```{r functionals-010}
sapply(df_list, ncol)
```

Nevertheless, suppose we want to apply the same function to a very large list of data frame and, by chance, one of them happens to be `NULL`.

```{r functionals-011}
df_list <- list(df1 = cars, df2 = NULL, df3 = trees) 
```

When using `sapply()` a `list`, instead of a `vector` is returned  

```{r functionals-012}
sapply(df_list, ncol)
```

If we use `vapply()` instead:

```{r functionals-013, error=TRUE}
vapply(df_list, ncol, FUN.VALUE = numeric(1))
```

`R` returns an error. 

Clearly this second behavior is more coherent and, within the frame of a large project, possibly helps to avoid annoying hours of debugging
-->

Finally, `vapply()` is  faster that `sapply()` as `R` does not have to _guess_ the kind of output `sapply()` needs to return.

## Functionals for matrices and data frames manipulation

Functionals can also be used to eliminate loops in common data manipulation tasks.   
In this section, we’ll give a brief overview of the available options, hint at how they can help you, and point you in the right direction to learn more. We’ll cover two categories of data structure functionals:

* Apply a Function over Data Frame Margins with `apply()` 
* Apply a Function to each group of values with `tapply()` and with its user-friendly version `aggregate()`

### Apply a Function over Data Frame Margins

#### apply

The `apply()` function applies a function over rows or columns of a data frame and it returns a vector or array or list of values.

The `Airline` data contain monthly airline passenger numbers between 1949 and 1960. Data are provided as a single time series, so some preprocessing is required to transform them to a data frame.

```{r datamanagement-applying-df}
df <- as.data.frame(matrix(AirPassengers, ncol=12))
names(df) <- c("Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")
row.names(df) <- 1949:1960
df
```

To get the mean number of passengers for each month, it suffices to apply the `mean()` function to the columns of the matrix. 

```{r datamanagement-applying-applycol}
apply(df, MARGIN = 2, FUN = mean)
```

The first argument of `apply()` is the data frame. `MARGIN` gives the subscripts which the function will be applied over: 1 for rows and 2 for columns. `FUN` is the function to be applied.

Similarly, to get the mean number of passengers for each year, it suffices to apply the `mean()` function to the rows of the matrix. 

```{r datamanagement-applying-applyrow}
apply(df, MARGIN = 1, FUN = mean)
```

If the function requires further argument they can be provided.

```{r datamanagement-applying-applyrowargs}
apply(df, MARGIN = 1, FUN = quantile, probs=c(0.05, 0.10, 0.25, 0.50, 0.75, 0.90, 0.95))
```

### Apply a Function to each group of values

#### tapply

The `tapply()` function applies a function to each cell of a ragged array, that is to each (non-empty) group of values given by a unique combination of the levels of certain factors. 

The `warpbreaks` data set, included in `datasets` package, gives the number of warp breaks per loom, where a loom corresponds to a fixed length of yarn. The data frame contains the number of `breaks`, the type of `wool` (`A` or `B`) and the level of `tension` (`L`, `M`, `H`).

```{r datamanagement-applying-warpbreaks}
data(warpbreaks)
head(warpbreaks)
```

The following example returns the number of breaks for each level of tension.

```{r datamanagement-applying-tapply1}
tapply(warpbreaks$breaks, INDEX = warpbreaks[, 3], FUN = sum)
```

The first argument is the data frame columns on which the function has to be applied, `INDEX` represents a list of factor columns by which the "ragged" data structure is created and `FUN` is the function to be applied.  

The following example returns a contingency table of the number of breaks for each type of wool and level of tension.

```{r datamanagement-applying-tapply2}
tapply(warpbreaks$breaks, INDEX = warpbreaks[,-1], FUN = sum)
```

The famous (Fisher's or Anderson's) `iris` data set, included in `datasets` package, gives the measurements in centimeters of the variables sepal length and width and petal length and width, respectively, for 50 flowers from each of 3 species of iris. The species are Iris setosa, versicolor, and virginica. 

```{r, tapply3}
head(iris)
```

Means of sepal length for each species can be computed in the following way.

```{r, tapply4}
tapply(iris[, 1], INDEX = iris[, 5], FUN = mean)
```

#### aggregate

The `aggregate()` function splits the data into subsets, computes summary statistics for each, and returns the result in a convenient form.

To compute the mean of each of the four variables (Sepal Length, Sepal Width, Petal Length, Petal Width) for the three Species the `aggregate()` function can be used. Please note that the `by` argument ought be a list and a name can be assigned to each grouping variable.

```{r, aggregate}
aggregate(iris[, 1:4], by = list(Species = iris[, 5]), FUN = mean)
```


