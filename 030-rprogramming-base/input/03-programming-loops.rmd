# Loops in R

## `for` loops

`for` loops, as any other iterators, are common components of almost any programming language. The common structure of a `for` loop in `R` is:

```{r programming-for-01}
languages <- c("C", "C++", "R", "Java", "Python")
for(lang in languages) {
  cat("I love ", lang, "\n")

}
```

or alternatively:
```{r programming-for-02}
languages <- c("C", "C++", "R", "Java", "Python")
n <- length(languages)
for(i  in 1:n) {
  cat("I love ", languages[i], "\n")

}
```


## Good programming practices with `for` loops

### Pre-allocating memory

`for` loops, as any equivalent iterator structure may require quite a long time to complete. Long computing time is quite natural as computational effort linearly increases with the number of iterations in the loop. 

Nevertheless, few little cautions may help to save a sensible amount of time.

As an example, we may calculate the `95%` quantile of the distribution of the correlation coefficient between two `N(0,1)` vectors of given sizes `n=10` by using a simple for loop over `k = 100,000` iterations.

```{r programming-for-03, include =FALSE}
rm(list = ls())
g = gc()
```

```{r programming-for-04, cache=TRUE}
k = 100000
n = 10
z = NULL 
system.time({
    for (i in 1:k) {
    x = rnorm(n , 0, 1)
    y = rnorm(n , 0, 1)
    z = c(z , cor(x, y))
  }
  cat ("95th quantile = " , quantile(z , .95), "\n")
})[3]
```

We can gain a first improvement by _'pre-allocating'_, the vector of results, We tell `R` what the size of the vector is before we begin filling it up. The wrong way to fill in a vector is to allow it to grow dynamically as it happens in the above loop. 

In the above case, R has to store a vector of one element than a second vector of two elements and so on up to a vector of `100,000` elements. As each new vector can't fit inside the RAM allocated to the previous vector, R has to use a  ''new'' bit of contiguous RAM for new vector. 

Thus, instead of using just one chunk of RAM that it takes to make a vector of `k=100,000` and filling it up with one more element at each iteration, R is forced to write the new enlarged vector in Ram at each iteration. Clearly, all of this memory writing takes up time.

Fortunately, R has a quite efficient mechanism for garbage collection and, as a result, memory usage is kept under control. Otherwise, looping without _pre-allocating_ may also cause serious memory usage problems.

Running the previous example, by simply pre-allocating vector `z` before looping, reduces computing time to about half of the previous time. 

```{r programming-for-05, cache=TRUE}
k = 100000
n = 10
z = numeric(k)
system.time({
  for ( i in 1:k){
    x = rnorm(n , 0, 1)
    y = rnorm(n , 0, 1)
    z[i] = cor(x, y)
  }
  cat ("95th quantile = " , quantile(z , .95), "\n")
})[3]
```

Clearly, pre-allocation requires to know in advance the size of the output vector. Whenever this is not possible, as it may happen in while loops, computing time may noticeably increase.

### Vectorized `for` loops

Whenever possible, loops should be replaced with vectorized calculation. This approach improve both performance and clarity.

As an example, we examine a double for loop:

```{r structures-006, cache=TRUE}
slow =  function(x, y) {  
  nx = length(x)
  ny = length(y)  
  xy = numeric(nx + ny - 1)  
  
  for(i in 1:nx) {  
         for(j in 1:ny) {  
              ij = i+j-1  
              xy[ij] = xy[ij] + x[i] * y[j]  
          }  
      }  
      xy  
}  


system.time(slow(runif(1000), runif(1000)))[3]
```

An attempt to vectorize the previous code leads to:

```{r structures-007, cache=TRUE}
fast =  function(x, y) {  
  nx = length(x)
  ny = length(y)  
  xy = numeric(nx + ny - 1)  
  j = 1:ny
  for(i in 1:nx) {  
              ij = i+j-1  
              xy[ij] = xy[ij] + x[i] * y  
      }  
      xy  
}
system.time(fast(runif(1000), runif(1000)))[3]
```

Simply working with vectorized dimensions drastically reduce computing time. Note that `j` index is computed within the `i` loop  and that `y[j]` has been replaced with `y`, as a result, a single for loop is required.

### Functionals: `lapply`

`for` loops are quite often nested and mixed up with `if()` statements. As a result, the whole coding structure may result in a complicated muddle to understand and, as a consequence, the objective of our coding may get lost within the code itself.

`for()` loops do have a bad reputation of being slow especially when compared with equivalent functionals structures as `lapply()`. Nowadays, speed is no more a crucial point when dealing with `for()` loops  

In other words, `for()` loops, whenever possible, should be avoided not mainly because of a performance issue but to to achieve modularity and clarity in our codes.

_Functionals_ are functions that take a function as input and return a data object as output. Functionals are very often excellent substitutes to `for` loops as they allow to communicate the objective of our code in a more clear and concise manner as the code will be cleaner and it will more closely adhere to `R`'s idioms.

`lapply()` is, possibly, the most used functional. `lapply()` takes a function and applies it to each element of a list, saving the results back into a result list.  `lapply()` is the building block for many other functionals. In principle, `lapply()` is a wrapper around a standard for loop.

`lapply()` takes three arguments: 

* a list `X`, or anything that can be coerced to a list by `as.list()`
* a function `FUN` that takes, as first argument, each element of `X`
* the `''...''` argument that can be any argument to be passed to `FUN`

Suppose we want to gain the maximum of each column for the `airquality` data frame. By using a `for` loop we could write:

```{r programming-lapply-02}
n <- ncol(airquality)
out <- numeric(n)
for (i in 1:n){
 out[i] <- max(airquality[,i], na.rm = TRUE)
}
out
```

alternatively, as a data frame is a list:

```{r programming-lapply-03}
lapply(X=airquality, FUN = max, na.rm = TRUE)
```

The second chunk of code is by far more clear and concise than the first one even though a vector would be preferable than a list as output.

Moreover, `lapply()` as opposite to `for` loops does not produce any intermediate result when running. In the above `for` loop, the value of the result of the loop, vector `out`, changes at each iteration. The result of `lapply()`, instead, can be assigned to a variable but does not produce any intermediate result.

By default `lapply()` takes each element of list `X` as the first argument of function `FUN`. This works perfectly, as long as each element of `X` is the first of `FUN`. This is true in case we want to compute the mean of each column of a data frame as each column is passed as first argument to function `mean()`.

But, suppose we want to compute various trimmed means of the same vector, `trim` is the second parameter of `mean()`, so we want to vary `trim`, keeping the first argument `x` fixed.  

This can be easily achieved by observing that the following two calls are equivalent:

```{r programming-lapply-04}
mean(1:100, trim = 0.1)
mean(0.1, x = 1:100)
```

So, in order to use `lapply()` with the second argument of unction `FUN`, we just need to name the first argument of `FUN` and pass it to `lapply()` as part as the `''...''` argument:

```{r programming-lapply-05}
x <- rnorm(100)
lapply(X = c(0.1, 0.2, 0.5), mean, x = x)
```



## `while` loops

`for` loops apply when the number of loops is known. Sometimes, one wants to loop until a condition is satisfied. In this case, the `while` statement should be used. Its use is quite simple:
```
while(condition) code-to-be-execute
```

If the code is more than one row long, than it must be placed between braces (`{...}`).

The following code, generates random numbers from a Normal Distribution and stops when a value greater than 2 is obtained. The number is assigned to `x` and a message with the number of loops is printed.

```{r programming-while, echo=2:100}
set.seed(355)
n <- 0
x <- 0
while(x <= 3) {
  x <- rnorm(1)
  n <- n + 1
}
cat(n, "loops were executed")
```



