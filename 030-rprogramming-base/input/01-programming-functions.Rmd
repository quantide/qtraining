# Functions in R

## Introduction to functions structure

When working with R we all make constant use of functions and, when developing, we create new functions so that functions look like very familiar R objects. Nevertheless, understanding the theory and the rationals underlying R functions may help to create much more efficient and possibly elegant coding.

We can create and assign functions to a variable name as we do with any other object:

```{r functions-create}
f <- function(x, y = 0) {
  z <- x + y
  z
}
```

Eventually, we can delete any function  with the usual call to `rm()` or `remove()`

Functions are objects with three basic components: 

* a formal arguments list
* a body
* an environment. 

```{r functions-002}
formals(f)
body(f)
environment(f)
```


### Formals

Formals are the formal arguments of a function returned as an object of class `pairlist` where a `pairlist` can be thought as something similar to a list with an important difference:

```{r functions-formals-pairlist}
is.null(pairlist())
is.null(list())
```

that is: a `pairlist` of length zero is `NULL` while a `list` is not.

When we call a function, formals arguments can be specified by position or by name and we can mix positional matching with matching by name so that the following are equivalent:

```{r functions-formals-argument}

mean(x = 1:5, trim = 0.1)
mean(1:5, trim = 0.1)
mean(x = 1:5, 0.1)
mean(1:5, 0.1)
mean(trim = 0.1, x = 1:5)
```

Along with position and name, we can also specify formals by partial matching so that:

```{r functions-formals-argument2}
mean(1:5, tr = 0.1)
mean(tr = 0.1, x = 1:5)
```

would work anyway.

Functions formals may also have the construct `symbol = default`, that unless differently specified, forces any argument to be used with its default value.

Specifically, function `mean()` also have a third argument `na.rm` that defaults to `FALSE` and , as a result passing vectors with `NA` values to `mean()` returns `NA`

```{r functions-formals-arguments3}
mean(c(1, 2, NA))
```

While, by specifying `na.rm=TRUE` we get the mean of all non missing elements of vector `x`.

```{r functions-formals-arguments4}
mean(c(1, 2, NA), na.rm = TRUE)
```

The order `R` uses for matching formals against value is:

1. Check for exact match for a named argument
2. Check for a partial match
3. Check for a positional match

Formals of a function are normally used within functions by the internal `R` evaluator but, we can use function `formals()` to expose formals explicitly. 

```{r functions-formals-f}
formals(f)
```

`args()` is an other function that displays the formals in a more user friendly fashion. Actually, `args(fun)` returns a function with the same arguments as `fun` but with an empty body.  

```{r functions-formals-args}
args(f)
```

Surely, for programming purposes,  `formals()` is a better choice as it returns a simple `pairlist` that can be handled as a list:


```{r functions-formals-list}
is.list(formals(mean))
```

The "`...`" argument of a function is a special argument and can contain any number of `symbol=value` arguments .  The "`...`" argument is transformed by `R` into a list that is simply added to the `formals` list:

```{r functions-dots}
h <- function (x, ...) {0}
formals(h)
```

The "`...`" argument can be used if the number of arguments is unknown. Suppose we want to define a function that counts the number of rows of any given number of data frames we could write:

```{r functions-dots2}
count_rows <- function(...) {
  list <- list(...)
  lapply(list, nrow)
}

count_rows(airquality, cars)
```

Similarly, the "`...`" arguments becomes very handy when the "`...`" arguments will be passed on to another function as it often happened when calling `plot()` from within another function. The following example shows a basic plot function used for depths plotting where additional graphics parameters are passed via "`...`":

```{r functions-dots3, fig.height=7, fig.width=7}
time <-  1:13
depth <-  c(0,9,18,21,21,21,21,18,9,3,3,3,0)

plot_depth <-  function ( time , depth , type = "l", ...){
  plot(time, -depth, type = type, 
       ylab = deparse(substitute(depth)), ...)
}
par(mfrow = c(1, 2))
plot_depth(time, depth, lty = 2)
plot_depth(time, depth, lwd = 4, col = "red")
```

### Body of a function

The body of a function is a parsed R statement. In practice, this implies that the body of a function needs to be correct from a formal point of view but no evaluation of the body of a function occurred yet. 

As a result, this function would return an error:

```{r functions-body-wrong, eval=FALSE}
wrong <- function(x) {x =}
```

as its body is not a correct `R` statement.

While this function:

```{r functions-body-right}
right <- function(x){x+y}
```

is accepted by `R` as is formally correct even thought, except under specific circumstances, will always return an error:

```{r functions-body-right-error, error=TRUE}
right(x = 2)
```
The body of a function, is usually a collection of statements in braces but it can be a single statement, a symbol or even a constant.

### Environment of a function
Environments are a fundamental concept in R and their knowledge is essential for advanced programming.

Environments are not threated here, but the following fundamental concepts:

 * The environment of a function is the environment that was active at the time that the function was created. Generally, for user defined function, the Global environment:

    ```{r functions-environment-userdefined}
    f <- function(x){x+1}
    environment(f)
    ```
    or, when a function is defined within a package, the environment associated to that package:

    ```{r functions-environment-package}
    environment(mean)
    ```

 * Objects defined within a function, exists in the environment of the function itself.
 
    ```{r functions-environment-global, error=TRUE}
    f <- function(x){x+1}
    x
   ```

## Writing a function

A function in R can be defined with the `function()` function. Its use can be summed up as follows:
```{r functions-writing}
myFunction =  function(a, b, c) {...}
```

`myFunction` is the name of the customised function; `a`, `b` and `c` are the arguments of `myFunction()` and the part in curly brackets contains the definition of the function.

As an example, write a function which calculates taxable income and taxes, given the total and the VAT percentage.

```{r functions-writing-example, tidy=FALSE}
vat = function(amount, rate = 0.21) {
  taxable = amount / (1 + rate)
  tax = amount - taxable
  return(list(tax = tax, taxable = taxable))
}
vat(121)
vat(104, rate = 0.04)
```

The value assigned to the `rate` argument is the default value assumed by the argument itself.

It is good practice to end the function specifying its output with the `return()` or `invisible()` functions. The function output ought to be made of a single object. If there are multiple objects, they can be inserted in a list. 
