---
title: "Developing R packages"
output: html_document
---

## Introduction
A wide documentation is available on the internet providing the technical instructions to build `R` packages, starting from the manual [Writing R extensions](http://cran.r-project.org/doc/manuals/r-release/R-exts.html) at the official `R` site.
 
This section provides a general overview about R packages. The following sections try to provide some insights on the mechanism used by `R` when dealing with packages.


### Why create a `R` package?

According to Rossi[^Rossi], there are at least three good reasons to create an R package.

[^Rossi]: http://www.math.ncu.edu.tw/~chenwc/R_note/reference/package/packages.pdf

1.  Creating an R package forces the user to document the code and provide test examples to insure that it actually works. It will also be much easier to use the code as documentation will only be a `?` command away and all of functions and shared libraries will be available for use. This is a good reason to create a package, also for its own use.

2.  If the goal is disseminate a research, this is an ideal way of making sure others have access to the work. It will also increase the probability that eventually the work will be correct. This is a good reason to create a package for a team (private) use.

3.  Giving back something to this amazing community of volunteers! This is a good reason to make the package available for the whole world (e.g. through CRAN).  

## The package structure behind `R`
Packages provide a mechanism for loading optional code, data and documentation as needed. 

An R package can be thought of as the software equivalent of a scientific article: articles are the _de facto_ standard to communicate scientific results, and readers expect them to be in a certain format. R packages are a comfortable way to maintain collections of R functions and data sets (Leisch, 2009)[^Leisch].

[^Leisch]: http://cran.r-project.org/doc/contrib/Leisch-CreatingPackages.pdf

The R distribution itself includes about 30 packages that can be split into three categories.

* **Base** packages: part of the R source tree, maintained by R Core.
* **Recommended** packages: part of every R installation, but not necessarily maintained by R Core.
* **Contributed** packages: all the rest. These are necessarily of lesser quality than the above. In fact, note that many contributed packages on CRAN are written and maintained by R Core members. The goal is simply to try and keep the base distribution as lean as possible and all non-essential packages are on CRAN but are not included in base R.

The `installed.packages()` function returns a matrix with several information about installed packages. The ``Priority'' column reports the category (base, reccomended or contributed) which each package belong to.

Terms about R packages are often confused. It may be helpful to clarify this a bit:

* **Package**: a collection of R functions, data, and compiled code in a well-defined format.
* **Library**: the directory where packages are installed.
* **Repository**: A website providing packages for installation.
* **Source**: The original version of a package with human-readable text and code.
* **Binary**: A compiled version of a package with computer-readable text and code, may work only on a specific platform.


## Packages Environments 

Every R package has three associated environments:

1. package environment 
2. namespace environment 
3. imports environment 

The package environment contains all functions of the package exposed to the end user.

The namespace environment contains all functions the package including those functions included in the package environment. This is not a duplication of the functions contained in both environments as two equal functions in the two environment share the same memory address. 

As a simple proof of concept, consider a first environment `env1` with a simple function `f()` in it:

```{r packages-000A}
env1 <- new.env()
env1$f <- function() NULL
```

and a second environment `env2` with an other function `f()` that is a copy of function `f()` from `env1`:

```{r packages-000B}
env2 <- new.env()
env2$f <- env1$f
```

with the help of function `mem_add()`, we can see that `env1$f` and `env2$f` share the same memory address:

```{r packages-000C}
mem_add <- function(x) substring(capture.output(.Internal(inspect(x))), 2, 17) 
identical(mem_add(env1$f) , mem_add(env2$f))
```

Similarly, with the help of function `getAnywhere()` we can see that function `mean()` is located both in the package environment and in the namespace environment of package `base`.

```{r packages-000D}
getAnywhere(mean)$where
```

Having functions within namespaces rather than packages allows the developer to expose to the end user only those functions that are supposed to be called directly and hide all those functions that are to be internally called from exposed function.

As a common practice, namespace environments may hold a quite large number of functions. As an example we can consider package `stats`; this package contains `r length(as.environment("package:stats"))` objects exposed to the end user while the corresponding namespace has `r length(as.environment(.getNamespace("stats")))` objects:

```{r packages-000L}
length(as.environment(.getNamespace("stats")))
length(as.environment("package:stats"))
```

The imports environment of a package contains objects from other packages that are explicitly stated requirements for a package to work properly. Most packages published on CRAN are not islands; they build on functionality provided in other packages.

We can get the names of the packages any package requires by using a little variant of function `packageDescription()`:


```{r packages-000L1}
package_imports <- function(pkg){
  v <- packageDescription(pkg, fields = "Imports")
  d <- data.frame( strsplit(v, split = ",")[[1]])
  names(d) <- paste ("imports", pkg, sep = "_")
  d
}
```

and test it on package `ggplot2`

```{r packages-000L2}
package_imports(pkg = "ggplot2")
```

We can also count the functions within the imports of `ggplot2` 

```{r packages-000L3}
vapply(getNamespaceImports("ggplot2"), length, FUN.VALUE = numeric(1))
```

Notice that, `getNamespaceImports()` also shows an object from the `base` package. This object is not a function but a simple logical set to `TRUE`. 

## How to create a package

### Starting a new package
In order to create an R package, a computing environment including a number of tools is assumed. Under UNIX and UNIX-alike systems most of the tools are likely to be present by default, but Microsoft Windows will require careful setup.

The following Sections show the creation of an R package under Linux. 

As a package is a collection of R functions, data, and compiled code in a well-defined format, a new package can be started in two ways.

1. The R function `package.skeleton()` makes the structure for a new package. This function requires that all functions and data sets for the new package should be loaded into a clean R session, then the function is called. The function organizes R function and data sets, skeleton help files are created and a DESCRIPTION file is created. The function then prints out a list of things for you to do next.

2. Functions, data set, help files etc. can be organized manually. Usually this is faster for experienced users.

### Structure of a package
The sources of a R package consists of a subdirectory containing some files and directories in a well organized structure.

Files ‘DESCRIPTION’ and ‘NAMESPACE’ and subdirectories ‘R’, ‘man’, and ‘data’ are required for every package. The base `package.skeleton()` function creates all the required directories.

The ‘DESCRIPTION’ file contains basic information about the package. The ‘Package’, ‘Version’, ‘License’, ‘Description’, ‘Title’, ‘Author’, and
‘Maintainer’ fields are mandatory, all other fields are optional.

R has a namespace management system for code in packages. This system allows the package writer to specify which variables in the package should be exported to make them available to package users, and which variables should be imported from other packages. The mechanism for specifying a namespace for a package is through the ‘NAMESPACE’ file in the top level package directory.

The ‘R’ subdirectory contains R code files, only. The `package.skeleton()` function returns a .R file for each function.

The ‘man’ subdirectory should contain only documentation files for the objects in the package in R documentation (Rd) format.

The ‘data’ subdirectory contains data files in R format.

A package may also contain files ‘INDEX’, ‘configure’, ‘cleanup’, ‘LICENSE’, ‘LICENCE’, ‘COPYING’ and ‘NEWS’ and directories ‘data’, ‘exec’, ‘inst’, ‘po’, ‘src’, and ‘tests’. These subdirectories can be missing, but which should not be empty. 

The sources and headers for the compiled code are in ‘src’. The ‘demo’ subdirectory is for R scripts (for running via `demo()`) that demonstrate some of the functionality of the package. The contents of the ‘inst’ subdirectory will be copied recursively to the installation directory. Subdirectories of ‘inst’ should not interfere with those used by R. Subdirectory ‘exec’ could contain additional executables the package needs, typically scripts for interpreters such as the shell, Perl, or Tcl. This mechanism is currently used only by a very few packages, and still experimental. Subdirectory ‘tests’ is for additional package-specific test code, similar to the specific tests that come with the R distribution. Subdirectory ‘po’ is used for files related to localization.


### Creating a package
When all is well organized, the following steps are required in order to create a package:

1.  the ‘DESCRIPTION’ file ought be filled in with required information,
2.  the ‘NAMESPACE’ file ought be filled in with required information,
3.  the R documentation files ought be written,
4.  the sources and headers for the compiled code, if any, ought be contained in the ‘src’ directory.

Then, a package can be created. This requires three steps:

1. **build**: the shell command ``R CMD BUILD`` builds an R source tarball. This means that temporary files are removed from the source tree of the package and everything is packed into a single file.
2. **check**: the shell command ``R CMD CHECK`` runs a wide variety of diagnostic checks on the package. Checks may be run before or after the build step.
3. **install**: the shell command ``R CMD INSTALL`` installs the package into a library and makes it available for usage in R. The R function ```install.packages()``` can be used instead.

R package `devtools` provide a lot of useful function in order to help developers to develop their own package. Moreover, RStudio IDE integrates `devtools` providing an user interface to build packages. 

### Build the package skeleton

The current R workspace contains two functions and a data frame.

```{r packages-001}
rm(list = ls())
itself = function(x) print(x)
paste2 = function(x, y) print(paste(x, y)) 
set.seed(2012) 
df = data.frame(x = rnorm(100), y = rnorm(100))
ls()
```

The R function `package.skeleton()` makes the structure for a new package.

```{r packages-002, eval=FALSE}
package.skeleton(name = "simpleExample")
```

The `name` argument of the `package.skeleton()` function contains the name of the package. The package directory should be given the same name
as the package. Because some file systems (e.g., those on Windows and by default on Mac OS X) are not case-sensitive, to maintain portability it
is strongly recommended that case distinctions not be used to distinguish different packages. For example, if there is a package named ‘foo’, do not also create a package named ‘Foo’.

The function returns a directory ‘simpleExample’ containing:

-   the ‘DESCRIPTION’ file to be fill in;

-   the ‘NAMESPACE’ file to be fill in, if needed;

-   the ‘R’ directory with the R code, a file for each function;

-   the ‘man’ directory with the R documentation file to be fill in;

-   the ‘data’ directory with the R data, a file for each data object;

-   the file ‘Read-and-delete-me’ with basic instructions about package creation.

#### The ‘DESCRIPTION’ file
An appropriate `DESCRIPTION' file for the package is:

    Package: simpleExample
    Title: A simple example of package building
    Version: 1.0
    Date: 2014-01-30
    Author: Nicola Sturaro
    Maintainer: Nicola Sturaro <nicola.sturaro@quantide.com>
    Description: This is the first package that "Programming with R"
                 attendees will create
    License: GPL-2

#### The ‘NAMESPACE’ file
An appropriate `NAMESPACE' file for the package is:

     exportPattern("^[[:alpha:]]+")
     
that simply exports all functions whose name begin with a character or a number (and not with a dot). This is the default behaviour and it can be changed using regular expressions. Alternatively, an `export(...)` statement for each function to be exported can be created.

If the package requires external dependencies, they should be stated as follow:

    import(dependencies1, dependencies2)

If the package requires compiled code, it should be stated as follow:

    useDynLib(opVar2)


### Build the package

At this point:

1.  the package skeleton is created,

2.  the ‘DESCRIPTION’ file contains the required information,

3.  the ‘NAMESPACE’ file contains the required information,

4.  the R documentation files are written,

5.  the sources and headers for the compiled code, if any, are contained  in the ‘src’ directory.

The package can be build typing (in the shell):

    $ R CMD BUILD simpleExample/

The command returns the following output:

    * checking for file `simpleExample/DESCRIPTION' ... OK
    * preparing `simpleExample':
    * checking DESCRIPTION meta-information ... OK
    * checking for LF line-endings in source and make files
    * checking for empty or unneeded directories
    * looking to see if a `data/datalist' file should be added
    * building `simpleExample_1.0.tar.gz'

The R package has been created. The source file is a .tar.gz file. The file name contains the package name and the version number. The package
version number were provided in the ‘DESCRIPTION’ file.

### Check the package

When a package is built[^note-check], it must be checked to detect errors and warnings. The package check can be run typing, in the directory containing the source file:

    $ R CMD CHECK simpleExample_1.0.tar.gz

[^note-check]: as seen above, a package can be checked also before it is built, e.g. `R CMD CHECK simpleExample/`

The following output refers to a not working package.

    * using log directory `/path/simpleExample.Rcheck'
    * using R version 2.15.0 (2012-03-30)
    * using platform: x86_64-pc-linux-gnu (64-bit)
    * using session charset: UTF-8
    * checking for file `simpleExample/DESCRIPTION' ... OK
    * checking extension type ... Package
    * this is package `simpleExample' version `1.0'
    * checking package namespace information ... OK
    * checking package dependencies ... OK
    * checking if this is a source package ... OK
    * checking if there is a namespace ... OK
    * checking for executable files ... OK
    * checking whether package `simpleExample' can be installed ... ERROR
    Installation failed.
    See `/path/00install.out' for details.

The ‘00install.out’ file reports the trouble:

    *** installing help indices
    Error in Rd_info(db[[i]]) : 
      missing/empty \title field in 
        '/path/simpleExample.Rcheck/00_pkg_src/simpleExample/man/df.Rd'
    Rd files must have a non-empty \title.

The ‘Title’ field of the R documentation files were not filled in, as required. In fact, the above error refer to a package in which the
skeleton file of the R documentation was not filled in. After the ‘DESCRIPTION’ file is filled in and the documentation is written, the
check command returns:

    * using log directory `/path/simpleExample.Rcheck'
    * using R version 2.15.0 (2012-03-30)
    * using platform: x86_64-pc-linux-gnu (64-bit)
    * using session charset: UTF-8
    * checking for file `simpleExample/DESCRIPTION' ... OK
    * checking extension type ... Package
    * this is package `simpleExample' version `1.0'
    * checking package namespace information ... OK
    * checking package dependencies ... OK
    * checking if this is a source package ... OK
    * checking if there is a namespace ... OK
    * checking for executable files ... OK
    * checking whether package `simpleExample' can be installed ... OK
    * checking installed package size ... OK
    * checking package directory ... OK
    * checking for portable file names ... OK
    * checking for sufficient/correct file permissions ... OK
    * checking DESCRIPTION meta-information ... OK
    * checking top-level files ... OK
    * checking index information ... OK
    * checking package subdirectories ... OK
    * checking R files for non-ASCII characters ... OK
    * checking R files for syntax errors ... OK
    * checking whether the package can be loaded ... OK
    * checking whether the package can be loaded with stated dependencies ... OK
    * checking whether the package can be unloaded cleanly ... OK
    * checking whether the namespace can be loaded with stated dependencies ... OK
    * checking whether the namespace can be unloaded cleanly ... OK
    * checking for unstated dependencies in R code ... OK
    * checking S3 generic/method consistency ... OK
    * checking replacement functions ... OK
    * checking foreign function calls ... OK
    * checking R code for possible problems ... OK
    * checking Rd files ... OK
    * checking Rd metadata ... OK
    * checking Rd cross-references ... OK
    * checking for missing documentation entries ... OK
    * checking for code/documentation mismatches ... OK
    * checking Rd \usage sections ... OK
    * checking Rd contents ... OK
    * checking for unstated dependencies in examples ... OK
    * checking examples ... OK
    * checking PDF version of manual ... OK

Now, all works!

### Install the package

Finally, the package can be installed by the command

    $ R CMD INSTALL simpleExample_1.0.tar.gz

At last, the package can be used:

```{r packages-003, eval=FALSE}
library(simpleExample)
```
```{r packages-004}
itself(5)
paste2("Score", 23)
```

## Writing R documentation files

R objects are documented in files written in “R documentation” (Rd) format, a simple markup language much of which closely resembles Latex, which can be processed into a variety of formats, including Latex, HTML and plain text.

An ‘Rd’ file consists of three parts. The header gives basic information about the name of the file, the topics documented, a title, a short textual description and R usage information for the objects documented. The body gives further information; for example, on the function’s arguments and return value, as in the example. Finally, there is an optional footer with keyword information. The header is mandatory. Information is given within a series of sections with standard names (and user-defined sections are also allowed). Unless otherwise specified these should occur only once in an ‘Rd’ file (in any order).

The structure of the documentation file for the `itself()` function is:

    \name{itself}
    \alias{itself}
    %- Also NEED an '\alias' for EACH other topic documented here.
    \title{
    %%  ~~function to do ... ~~
    }
    \description{
    %%  ~~ A concise (1-5 lines) description of what the function does. ~~
    }
    \usage{
    itself(x)
    }
    %- maybe also 'usage' for other objects documented here.
    \arguments{
      \item{x}{
    %%     ~~Describe \code{x} here~~
    }
    }
    \details{
    %%  ~~ If necessary, more details than the description above ~~
    }
    \value{
    %%  ~Describe the value returned
    %%  If it is a LIST, use
    %%  \item{comp1 }{Description of 'comp1'}
    %%  \item{comp2 }{Description of 'comp2'}
    %% ...
    }
    \references{
    %% ~put references to the literature/web site here ~
    }
    \author{
    %%  ~~who you are~~
    }
    \note{
    %%  ~~further notes~~
    }

    %% ~Make other sections like Warning with \section{Warning }{....} ~

    \seealso{
    %% ~~objects to See Also as \code{\link{help}}, ~~~
    }
    \examples{
    ##---- Should be DIRECTLY executable !! ----
    ##-- ==>  Define data, use random,
    ##--  or do  help(data=index)  for the standard data sets.

    ## The function is currently defined as
    function (x) 
    {
        print(itself)
      }
    }
    % Add one or more standard keywords, see file 'KEYWORDS' in the
    % R documentation directory.
    \keyword{ ~kwd1 }
    \keyword{ ~kwd2 }% __ONLY ONE__ keyword per line

The above skeleton structure can be filled as follow:

    \name{itself}
    \alias{itself}
    \title{Print the input value}
    \description{This elementary function prints the input value}
    \usage{
    itself(x)
    }

    \arguments{
      \item{x}{input value}
    }
    \details{
    The input value can be both a numeric or a character string.
    }
    \value{
    The input value is printed
    }
    \references{
    No references for a so basic function!
    }
    \author{
    Andrea
    }

    \seealso{
    \code{\link{paste2}} for the help of the functionpaste2
    }

    \examples{
    itself(5)
    itself("Diego")
    }

### Documenting packages with ROxygen2

The `roxygen2` R package allows to get a in-source documentation. Accordint to [package vignettes](http://cran.r-project.org/web/packages/roxygen2/vignettes/roxygen2.html), Roxygen provides a number of advantages over writing .Rd files by hand:

 - Code and documentation are adjacent so when you modify your code, it's easy to remember that you need to update the documentation.
 - Roxygen dynamically inspects the objects that it's documenting, so it can automatically add data that you'd otherwise have to write by hand.
 - It abstracts over the differences in documenting S3 and S4 methods, generics and classes so you need to learn fewer details.

As well as generating .Rd files, roxygen2 will also create a `NAMESPACE` for you, and will manage the Collate field in `DESCRIPTION`.

#### Generating Rd files

There are three steps in the transformation from roxygen comments in your source file to human readable documentation:

 - You add Roxygen comments to your source file.
 - `roxygen2::roxygenise()` converts Roxygen comments to .Rd files.
 - R converts .Rd files to human readable documentation.

The process starts when you add specially formatted Roxygen comments to your source file. Roxygen comments start with `#'` so you can continue to use regular comments for other purposes.

```{r packages-roxygen1}
#' Add together two numbers
#'
#' @param x A number
#' @param y A number
#' @return The sum of \code{x} and \code{y}
#' @examples
#' add(1, 1)
#' add(10, 1)

add <- function(x, y) {
  x + y
}
```

For the example, above, this will generate man/add.Rd that looks like:

% Generated by roxygen2 (3.2.0): do not edit by hand
\name{add}
\alias{add}
\title{Add together two numbers}
\usage{
add(x, y)
}
\arguments{
  \item{x}{A number}

  \item{y}{A number}
}
\value{
The sum of \code{x} and \code{y}
}
\description{
Add together two numbers
}
\examples{
add(1, 1)
add(10, 1)
}

Roxygen comments start with `#'` and include tags like `@tag details`. Tags break the documentation up into pieces, and the content of a tag extends from the end of tag name to the start of the next tag (or the end of the block).

Each documentation block starts with some text. The first sentence becomes the title of the documentation. It should fit on one line, be written in sentence case, and end in a full stop. The second paragraph is the description: this comes first in the documentation and should briefly describe what the function does. The third and subsequent paragraphs go into the details: this is a (often long) section that comes after the argument description and should provide any other important details of how the function operates.

Here's an example showing what the documentation for `sum()` might look like if it had been written with Roxygen:

```{r packages-roxygen2}
#' Sum of vector elements.
#'
#' \code{sum} returns the sum of all the values present in its arguments.
#'
#' This is a generic function: methods can be defined for it directly
#' or via the \code{\link{Summary}} group generic. For this to work properly,
#' the arguments \code{...} should be unnamed, and dispatch is on the
#' first argument.

sum <- function(..., na.rm = TRUE) {}
```

`\code{}` and `\link{}` are .Rd formatting commands which link to other documentation.

The following documentation produces the same help file as above, but uses explicit tags. You only need explicit tags if you want to the title or description to span multiple paragraphs (a bad idea), or want to omit the description (in which case Roxygen will use the title for the description, since it's a required documentation component).

```{r packages-roxygen3}
#' @title Sum of vector elements.
#'
#' @description
#' \code{sum} returns the sum of all the values present in its arguments.
#'
#' @details
#' This is a generic function: methods can be defined for it directly
#' or via the \code{\link{Summary}} group generic. For this to work properly,
#' the arguments \code{...} should be unnamed, and dispatch is on the
#' first argument.
sum <- function(..., na.rm = TRUE) {}
```

All objects must have a title and description. Details are optional.

Functions are the mostly commonly documented objects. Most functions use three tags:

 - `@param name description` describes the inputs to the function. The description should provide a succinct summary of the type of the parameter (e.g. a string, a numeric vector), and if not obvious from the name, what the parameter does. The description should start with a capital letter and end with a full stop. It can span multiple lines (or even paragraphs) if necessary. All parameters must be documented.

    You can document multiple arguments in one place by separating the names with commas (no spaces). For example, to document both `x` and `y`, you can say `@param x,y Numeric vectors`.

 - `@examples` provides executable R code showing how to use the function in practice. This is a very important part of the documentation because many people look at the examples before reading anything. Example code must work without errors as it is run automatically as part of R CMD check.
     However for the purpose of illustration, it's often useful to include code that causes an error. `\dontrun{}` allows you to include code in the example that is never used. There are two other special commands. `\dontshow{}` is run, but not shown in the help page: this can be useful for informal tests. `\donttest{}` is run in examples, but not run automatically in R CMD check. This is useful if you have examples that take a long time to run. The options are summarised below.

 - `@return description` describes the output from the function. This is not always necessary, but is a good idea if you return different types of outputs depending on the input, or you're returning an S3, S4 or RC object.

```{r packages-roxygen4}
#' Sum of vector elements.
#'
#' \code{sum} returns the sum of all the values present in its arguments.
#'
#' This is a generic function: methods can be defined for it directly
#' or via the \code{\link{Summary}} group generic. For this to work properly,
#' the arguments \code{...} should be unnamed, and dispatch is on the
#' first argument.
#'
#' @param ... Numeric, complex, or logical vectors.
#' @param na.rm A logical scalar. Should missing values (including NaN)
#'   be removed?
#' @return If all inputs are integer and logical, then the output
#'   will be an integer. If integer overflow
#'   \url{http://en.wikipedia.org/wiki/Integer_overflow} occurs, the output
#'   will be NA with a warning. Otherwise it will be a length-one numeric or
#'   complex vector.
#'
#'   Zero-length vectors have sum 0 by definition. See
#'   \url{http://en.wikipedia.org/wiki/Empty_sum} for more details.
#' @examples
#' sum(1:10)
#' sum(1:5, 6:10)
#' sum(F, F, F, T, T)
#'
#' sum(.Machine$integer.max, 1L)
#' sum(.Machine$integer.max, 1)
#'
#' \dontrun{
#' sum("a")
#' }
sum <- function(..., na.rm = TRUE) {}
```

`\url{}` is an .Rd formatting command which link to the web.

Indent the second and subsequent lines of a tag so that when scanning the documentation so it's easy to see where one tag ends and the next begins. Tags that always span multiple lines (like `@example`) should start on a new line and don't need to be indented.


A wide documentation on `roxygen2` is available on CRAN vignette. [package vignettes](http://cran.r-project.org/web/packages/roxygen2/vignettes/roxygen2.html)

## Calling a function from a package

As the package environment is included in the search path, when we call a function from a package, `R` looks for that function along the search path until it finds it in the package environment. Nevertheless, if we ask to a function from a package environment for the environment it belongs to, we have a little surprise:

```{r packages-000I}
environment( sd) 
```
That is, the environment of function `sd()` from `stats` package environment refers to the `stats` namespace environment as its environment.

As a consequence, when function `sd()` runs, a new environment is created whose enclosure is the `stats` namespace environment and all _hidden_ functions within the namespace become available to function `sd()`.

The namespace environment of any package, as any environment has a parent. We can query `R` for the parent of any namespace:

```{r packages-000M}
parent.env(as.environment(.getNamespace("stats")))
```

As we can see the parent environment of a namespace is a new environment: `imports:packagename` whose parent, is the namespace of package `base`.


```{r packages-000N}
parent.env(parent.env(as.environment(.getNamespace("stats"))))
parent.env(parent.env(as.environment(.getNamespace("utils"))))
```

Finally, the parent of `namespace:base` happend to be our `R_GlobalEnv`.

```{r packages-000O}
parent.env(parent.env(parent.env(as.environment(.getNamespace("stats")))))
```

The following picture, borrowed from [obeautifulcode.com](http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/) illustrates the whole chain of environments.


![http://obeautifulcode.com/R/How-R-Searches-And-Finds-Stuff/](images/map-of-the-world-complete.png)

In practice, when we look for a function `f()` in a package `pkg`, we find `f()` in the package environment og `pkg`. When we call `f()`, it runs within the namespace of `pkg` and as this is its environment. The enclosure of execution environment of `f()` is therefore the namespace of `pkg`. 
Whenever `f()` calls a second function `g()`, `g()` is searched first in the execution environment and, as reasonably `g()` is not defined in there, `R` looks for `g()` in the name space and, in case `g()` does not belong to package `pkg`, `R` looks in the imports environment of `pkg`. 

This search structure makes perfect sense as it increases the probability of finding any function `g()` in the shortest possible time.

In case `g()` is not found in the imports of `pkg` then `R` looks for `g()` in the namespace of `base`. Again, this is very reasonable as, almost all packages have to refer to the base package. 

If we assume that the dependency structure of the package has been built properly, the search should end up at the imports namespace or, at worse at the base namespace. In fact, if `g()` is not found within the namespace of `base` the next step in the search mechanism, points to our `R_GlobalEnv` and after that it moves down the search path until it either finds `g()` or reaches the empty environment. 

Older version of `R` did not implement this idea of namespace and, as a consequence, the imports environment did not exists. Dependencies between packages was implemented with the use of _depends_. If a package `pkg1` was dependending from package `pkg2`, `pkg2` was attached in the search path just after package `pkg1`. 
Nowadays, few packages still use this idea of depends. As an exampel consider package `abc`: before attaching the package the search path should look like:


```{r packages-000L31, echo = FALSE}
core <- c(".GlobalEnv", "tools:rstudio","package:stats","package:graphics","package:grDevices","package:utils","package:datasets","package:methods","Autoloads","package:base")     
pkg <- search()[!(search() %in% core)]
lapply(pkg, detach, character.only = TRUE, unload = FALSE)
```


```{r packages-000L32, echo = FALSE}
search()
```

If we load package `abc version 1.8` and we run `search()` again, we observe how our search path is changed:

```{r packages-000L33, echo = FALSE}
require("abc", quietly=TRUE)
search()
```
Packages `nnet`, `quantreg`, `MASS` are attached as package `abc` depends on them while package `SparseM` is attached because package `quantreg` depends on it:

```{r packages-000L34, echo = FALSE}
packageDescription("abc", fields = "Depends")
packageDescription("quantreg", fields = "Depends")
```

Clearly, `imports` is to be preferred to `depends` as it offer a neter structure for `R` searching mechanism.


## Loading packages 

We load a package, with a call either to `library()` or `require()`. These functions perform very similarly but they have few very important differences that is worth to mention. 

As a first difference we can notice the different messages the two functions requrn when called with a non existing library:

```{r packages-000L4, error=TRUE}
library("not_exist")
require("not_exist")
```

beside the message, a more important side effect comes up when we assign the results of these calls to an object:

```{r packages-000L5, error=TRUE}
test_library <- library("not_exist")
test_require <-  require("not_exist")
test_library
test_require
```

We can notice that, in case of error, `library()` does not assign while `require()` returns `FALSE`. This behavior of `require()` allow us to make libraries loading more robust expecially within the body of a function:

```{r packages-000L6}
if(!require("ggplot2")) {install.packages("ggplot2"); require("ggplot2")}
```

Despite this difference, It's bad practice to use `library()` or `require()` inside a function, because it makes it hard to understand code dependencies. They should either be outside functions or, even better, in package `DESCRIPTION`. 

When loading a package these four actions occur: 

1. The namespace environment is loaded 
2. A new environment is created: the package environment
3. Only _exported_ functions are _copied_ from the namespace to the package environment
4. Package environment is that included in the search list  

Packages are usually loaded by mean of a _lazy loading_ mechanism. Lazy loading is always used for code in packages but is optional, as it selected by the package maintainer, for datasets in packages. 
When a package namespace is loaded, the namespace environment is populated with _promises_ for all the named objects and those objects specified in the `NAMESPACE` field of the package are copied into the package environment: when these promises are evaluated they load the actual code from a database.

There are separate databases for code and data, stored respectively in the `R` and `data` subdirectories. Each database consists of two files, `name.rdb` and `name.rdx`. The `.rdb` file is a concatenation of serialized objects, and the `.rdx` file contains an index. The objects are stored in a gzip-compressed format. 

The loader for a lazy-load database of code or data is function `lazyLoad()` in the base package.

As an example we can write a function that load an existing object as a promise from a `.rdb` file being part of a `R` package without loading the package:

```{r packages-000E}
get_from_rdb <- function(symbol, filebase, envir =parent.frame()){
  lazyLoad(filebase = filebase, envir = envir, filter = function(x) x == symbol)
}
```

and use this function to get the promises in our local environment as:

```{r packages-000F}
Rlib = .libPaths()[1]
get_from_rdb(symbol =  "venice", filebase = file.path(Rlib, "evd/data/Rdata"))
find("venice")
```

Once we have the promise we can evaluate it in order to get the value associated to the promise:

```{r packages-000G}
head(eval(venice))
```

Finally, we can easily load all data and functions from  package `.rdb` files by:

```{r packages-000H}
lazyLoad(filebase = file.path(Rlib, "evd/data/Rdata"), envir = parent.frame(), filter = function(x) TRUE)
lazyLoad(filebase = file.path(Rlib, "evd/R/evd"), envir = parent.frame(), filter = function(x) TRUE)
```



## Further deepenings

### Submit a package to CRAN

To distribute a package through the Comprehensive R Archive Network (CRAN) repository, just follow the instructions in [CRAN website](http://cran.r-project.org/). Binaries for Windows and Max OS X are created by CRAN.

### Get the Windows binary

Sometimes, packages are created for personal or business team purposes and may not be avalaible through CRAN.

If the package cannot be submitted through the CRAN repository, the tool provided by the [R-project](http://win-builder.r-project.org/) can be used to get the Windows binary.


### Some terminology about R packages

The following notes[^1] will help understand some terminology.

-   A *package* is a directory of files which extend R, either a source
    package (the master files of a package), or a tarball containing the
    files of a source package, or an installed package, the result of
    running `R CMD INSTALL` on a source package. On some platforms there
    are also binary packages, a zip or tarball containing the files of
    an installed package which can be unpacked rather than installing
    from sources.

-   A package *is not* a library. The latter is used in two senses in R
    documentation.

    1.  The first is a directory into which packages are installed: in that sense it is sometimes referred to as a library
        directory or library tree (since the library is a directory
        which contains packages as directories, which themselves contain
        directories).

    2.  The second sense is that used by the operating system, as a
        shared library or static library or (especially on Windows) a
        DLL, where the second L stands for “library”. Installed packages
        may contain compiled code in what is known on most Unix-alikes
        as a shared object and on Windows as a DLL (and used to be
        called a shared library on some Unix-alikes). The concept of a
        shared library (dynamic library on Mac OS X) as a collection of
        compiled code to which a package might link is also used,
        especially for R itself on some platforms.

-   There are a number of well-defined operations on source packages.
    The most common is *installation* which takes a source package and
    installs it in a library using `R CMD INSTALL` or
    `install.packages()`. Source packages can be *built*, a distinct
    concept. This involves taking a source directory and creating a
    tarball ready for distribution, including cleaning it up and
    creating PDF documentation from any vignettes it may contain. Source
    packages (and most often tarballs) can be checked, when a test
    installation is done and tested (including running its examples);
    also, the contents of the package are tested in various ways for
    consistency and portability.

-   *Compilation* is not a correct term for a package. Installing a
    source package which contains C, C++ or Fortran code will involve
    compiling that code.

-   The option of *lazy loading* of code or data is mentioned at several
    points. This is an optional part of the installation, selected by
    default for R code (and not using it is deprecated). When used the R
    objects of the package are created at installation time, and stored
    in a database in the ‘R’ directory of the installed package, being
    loaded into the session at first use. This makes the R session run
    faster and used less (virtual) memory.

## Collaboration with Git and Github

There are a number of advantages to putting your R package on GitHub.

 - It will be easier for others to peruse your code. They can do so in the web browser without having to download, extract, and start fishing.
 - GitHub includes issue tracking: people (including yourself) can note problems they’re having or suggestions for improvements they’d like you to make.
 - In addition to just pointing out problems, people can actually fix the problem and send you a patch, which you can easily test and then incorporate into your package. Some of this can be done entirely online, with no knowledge of git.
 - With the `install_github()` function in Hadley Wickham’s `devtools` package, it’s easy for people to install your package directly from GitHub. It doesn’t have to be on CRAN. 


### How to install a package from GitHub

To install a package that’s sitting on GitHub:

 1. First, you need to install the devtools package. You can do this from CRAN:
 
    ```{r packages-github1, eval=FALSE}
install.packages("devtools")
    ```

 2. Load the devtools package:
 
    ```{r packages-github2, eval=FALSE}
library(devtools)
    ``` 

 3. In most cases, you just use `install_github("author/package")`.  
    For example, with  [R/broman package](http://github.com/kbroman/broman), you’d type:
    
    ```{r packages-github3, eval=FALSE}
install_github("kbroman/broman")
    ```


### Put your R package on GitHub

To put your package on GitHub, you’ll need to get a GitHub account.  
To create a new git repository, you have to:

 - Change to the package directory
 - Initialize the repository with `git init`
 - Add and commit everything with `git add .` and `git commit`
 - Create a new repository on GitHub
 - Connect your local repository to the GitHub one.
 
    ```{r packages-github4, eval=FALSE}
git remote add origin https://github.com/username/reponame
    ```
 
 - Push everything to github
 
    ```{r packages-github5, eval=FALSE}
git push -u origin master
    ```

