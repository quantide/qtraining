---
title: "Debugging tools in R and RStudio"
---


```{r options, include=FALSE, purl=FALSE}
options(width = 108)
```


## Introduction

In this chapter you will be introduced to the `R` and the `RStudio` debugging tools that will help you find bugs by figuring out where the code is not behaving the way you expected. `RStudio` integrated the debugging tools in `R` into its IDE exposing them in a user friendly way. 

We will show two main ways of detecting your bugs

* opening the function scope and look into the function with `debugonce()` to detect anomalies

* finding and fixing an error: `traceback()` shows the sequence of calls that lead to the error


## Debugging your code

### `debugonce()`

If you know there is a problem in the function you are writing, but you do not exactly know where the errori occurs, you may use  `debugonce()`.

`debugonce` allows you to enter the debugger when you run a specific function. Entering the debugger or the debug mode, means that you can pause the code and see what is happenening. In other words pausing the code when a function is executed, means that you run one line at the time and you can explore the scope of the function.

Let us see an example.

Suppose you built a function to find the first `n` prime numbers. However you made a mistake:

```{r debug1}
prime_numbers <- function(n){
    if (n >= 2) {
      sieve <- seq(2, n)
      primes <- c()

      for (i in seq(2, n)) {
        if (any(sieve == i)) {
          primes <- c(primes)
#          primes <- c(primes, i)
          sieve <- c(sieve[(sieve %% i) != 0], i)
        }
      }
      return(primes)
    } else {
      stop("n should be at least 2.")
    }
}

prime_numbers(7)

```

The function is not returning an error, but it is returning something that you did not expect. One way to dig into the function you just built is to run the debugger for `prime_numbers`:

```{r debug2}
debugonce(prime_numbers())
```

The `debugonce()` allows you to enter the local function environment the first time you run the function and go through the instructions one by one to see how it works.

We are enever updating the content of `primes` vector, so let's change it:

```{r debug3}
prime_numbers <- function(n){
    if (n >= 2) {
      sieve <- seq(2, n)
      primes <- c()

      for (i in seq(2, n)) {
        if (any(sieve == i)) {
          primes <- c(primes, i)
          sieve <- c(sieve[(sieve %% i) != 0], i)
        }
      }
      return(primes)
    } else {
      stop("n should be at least 2.")
    }
}

prime_numbers(7)

```

It seems like it's working!

So let us open the function environment but we'll do it in a slightly different way. If you place `browser()` in the code you want to debug, the debugger will open when it encounters it.

```{r debug4}

prime_numbers <- function(n){
    if (n >= 2) {
      sieve <- seq(2, n)
      primes <- c()

      for (i in seq(2, n)) {
        if (any(sieve == i)) {
          primes <- c(primes, i)
          browser()
          sieve <- c(sieve[(sieve %% i) != 0], i)
        }
      }
      return(primes)
    } else {
      stop("n should be at least 2.")
    }
}

prime_numbers(7)

```


### `debug()`

The function `debug()` allows you to enter the local environment of the function every time you run the function. This means, however, that you need to exit the debugger once you have finished debugging the function.


## Finding and fixing an error

Suppose again that you are writing the function to find the first `n` prime numbers.


```{r traceback1}

prime_numbers <- function(n){
    if (n >= 2) {
      sieve <- seq(2, n)
      primes <- c()

      for (i in seq(2, n)) {
        if (any(sieve == i)) {
          primes <- c(primes, i)
          browser()
          sieve <- c(sieve[(sieve %% i) != 0], i)
        }
      }
      return(primes)
    } else {
      stop("n should be at least 2.")
    }
}

prime_numbers(c(10,1))

```

We do get an error. In order to see where exactly the error occured, you may use the `traceback()` function or just click on `Show traceback` if you using RStudio.

This will allow you to see where the function stopped. Now, you may want to go closer into the function, you may want to go and see inside the function scope.

