---
title: "Creazione di un Bar Plot"
output: html_document
---

```{r options, include=FALSE, purl=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.pos = 'H', fig.width = 4, fig.height = 3)
options(width = 108)
```

<!--
# Creating a Bar Plot
-->

```{r first, include=TRUE, purl=TRUE, message=FALSE}
require(dplyr)
require(ggplot2)
require(qdata)
data(bands)
```

I bar plot sono utilizzati per mostrare valori numerici per diverse categorie. Sebbene possano sembrare simili agli istogrammi, i due tipi di grafici sono molto diversi: i bar plot sono utilizzati per le variabili x categoriali, le barre dovrebbero essere distanziate e il peso delle barre non ha significato; gli istogrammmi invece sono utilizzati per le variabili x continue, le barre (chiamate _bins_) non devono essere separate e il peso dei bins dipende dai dati.

Per evitare confusione tra questi due tipi di grafico, alcuni autori suggeriscono di costruire le barre orizzontalmente.

<!--
Bar plots are used to display numeric values for different categories. Although they appears similar to Histograms, these plots are very different: bar plots are used for categorical x values, bars should be spaced and the weight of the bar has no meaning while histograms are used for continuous x values, bars (that are called _bins_) must not be spaced and the weight of bins depends on data.

To avoid confusion between bar plots and histograms, some authors suggest to build bars horizontally.
-->
```{r bargraphs, message=FALSE, echo=FALSE, purl=FALSE}
ds = data.frame(x=factor(1:4), y=c(4,2,6,5))

ggp <- ggplot(data=ds, aes(x=x, y=y)) +
  geom_bar(stat="identity", fill=c("#74a9cf", "#3690c0", "#0570b0", "#034e7b")) + 
  theme(axis.text.x = element_blank(), axis.text.y = element_blank())

ggp1 <- ggp +
  xlab("Discrete variable\n(x)") + ylab("Frequencies\n(y)")

ggp2 <- ggp +
  xlab("Discrete variable\n(y)") + ylab("Frequencies\n(x)") +
  coord_flip()

gridExtra::grid.arrange(ggp1, ggp2, ncol=2)
```

Questo capitolo mostra come costruire i bar plot e introduce alcuni concetti base della grammatica di `ggplot2`, come le `stats` (layers) e il posizionamento.

<!--
This chapter presents how to build bar plots and introduces other basic concepts of `ggplot2` grammar: `stat` (layers) and positioning. 
-->

## Il mio primo bar plot

Come visto nel capitolo precedente, i polli seguono una delle quattro diete (vedi `ChickWeight` data set). Possiamo rappresentare un summary che mostra come i polli seguano ogni dieta. 
<!--
## The first bar plot

As seen in the previous chapter, chicks receive one of four diets (see `ChickWeight` data set). A graphical summary about how chicks receive each diet can be obtained.
-->
```{r bargraph_first, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) + 
  geom_bar()
```

Se si preferiscono le barre orizzontali, basta capovolgere il grafico con la funzione `coord_flip()`. 
<!--
If you prefer horizontal bars, just flip the plot with `coord_flip()`.
-->
```{r bargraph_coordflip, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) + 
  geom_bar() + 
  coord_flip()
```

Un altro modo per distinguere i grafici a barre dagli istogrammi è ridurre la dimensione delle barre, rendondole più fine incrementando lo spazio tra di esse.
<!--
Another way to distinguish bar plots and histograms are tiny bars, to increase the space among bars.
-->
```{r bargraph_width, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) + 
  geom_bar(width=0.5)
```

## Impostare e mappare variabili sui bar plot

Il colore e le altri impostazione estetiche, come il tipo di linea e la dimensione, possono essere impostate o mappate. E' bene tenere a mente che `colour` consente di impostare il colore dei contorni delle barre, mentre `fill` controlla il colore del riempimento delle barre.  
<!--
## Setting and mapping variables to bar plots

Colours and other available aesthetic settings (`linetype` and `size`) can be set or mapped as usual. Remember that `colour` controls the bar outline, while `fill` controls the bar colour.
-->
```{r bargraph_setcolour, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) +
  geom_bar(fill=c("#74a9cf", "#3690c0", "#0570b0", "#034e7b"))
```

```{r bargraph_scalefill, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) +
  geom_bar(mapping=aes(fill=Diet)) +
  scale_fill_manual(values=c("#74a9cf", "#3690c0", "#0570b0", "#034e7b"))
```

Questi due tipi si grafico sono identici, fatta eccezione per la legenda. Tuttavia sono basati su due approcci diversi. Nel primo grafico, i colori di riempimento (`fill`) sono impostati, se così non fosse stato le barre sarebbero state colorate tutte con lo stesso colore, come abbiamo visto nel primo esempio. Nel secondo grafico, il colore di riempimento delle barre è mappatto sui livelli della variabile `Diet`. Poichè ogni barra rappresenta un diverso tipo di dieta, ogni barra ha un colore diverso anche quando i colori di riempimento non vengono impostati manualmente attraverso la funzione `scale_fill_manual()`.

<!--
These plots are identical except that for legend, but they are based on two different approaches. In the first plot, fill colours are set. If you do not set four different fill colours, all bars have the same colours as shown above. In the second plot, fill colours are mapped to the levels of `Diet`. Since each bar represents a different type of diet, each bar has a different colour also when you do not set manually fill colours with `scale_fill_manual()`.
-->
```{r bargraph_mapping, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) +
  geom_bar(mapping=aes(fill=Diet))
```

La funzione `scale_fill_manual()` ci permette di scegliere quali colori debbano essere utilizzati. Quando i colori di riempimento hanno una variabile mappata, la legenda viene mostrata. In quetso caso la legenda è inutile, perchè la stessa variabile è mappata su `x` e si conosce già che colore si riferisce ad ogni dieta. E' possibile rimuovere la legenda nella funzione `scale_fill_manual()`.  
<!--
The use of `scale_fill_manual()` allows you to choose which colours should be used. Since fill colours are mapped with a variable, in this case the legend will be shown. In this case the legend is useless, because the same aesthetic is mapped to `x` and you already know which Diet refer to each colour. You can hide the legend in `scale_fill_manual()`.
-->
```{r bargraph_nolegend_scale, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) +
  geom_bar(mapping=aes(fill=Diet)) +
  scale_fill_manual(values=c("#74a9cf", "#3690c0", "#0570b0", "#034e7b"), guide=FALSE)
```

`ggplot2` fornisce alcune funzione (ad esempio: `scale_*_brewer` o `scale_*_gradient`) per scegliere una palette di colori (cioè un set di colori), ma di ciò parleremo più approfonditamente nel capitolo _Personalizzazione delle estetiche mappate_. Per il momento potete utilizzare le funzioni `scale_*_manual` e fare riferimento ad alcuni siti per la scelta dei colori da utilizzare, come [Color Brewer](http://colorbrewer2.org/) o [Paletton](http://paletton.com/).

<!--
`ggplot2` provides some functions (e.g. `scale_*_brewer` or `scale_*_gradient`) to choose a palette (i.e. a set of coherent colours), but these functions will be shown in _Mapped Aestethics Customization_ chapter. You can still use `scale_*_manual` functions and refer to some on-line tool like [Color Brewer](http://colorbrewer2.org/) or [Paletton](http://paletton.com/) for a better choice of colours.
-->

## Summary dei dati e le `stat`s

Alcune volte non abbiamo a disposizione i dati originali ma solamente tabelle di frequenza che li riassumnono, come in questo caso:

<!--
## Summarized data and `stat`s

Sometimes data comes already summarized. As an example, you can have the following frequency tables without the original data.
-->

```{r bargraph_ChickWeightFreq, message=FALSE}
ChickWeightFreq <- ChickWeight %>% 
  group_by(Diet) %>% 
  summarize(n=n())

ChickWeightFreq
```

Possiamo provare a costruire il grafico come siamo soliti fare.
<!--
You can try to build the previous plot in the same way.
-->
```{r bargraph_error, message=FALSE}
ggplot(data=ChickWeightFreq, mapping=aes(x=Diet)) + 
  geom_bar()
```

Il risultato è un grafico con 4 barre di lunghezza pari ad 1. Perchè? La ragione è abbastanza semplice. Per default, `geom_bar()` esamina la colonna `Diet` contando quante osservazioni presentano Diet=1, quante Diet=2 e così via. In questo caso dobbiamo dire a `ggplot` che abbiamo già a disposizione il conteggio dei dati. 
<!--
The result is a plot with four bars of length 1. Why? The reason is quite simple. By default, `geom_bar()` scans the `Diet` column counting how many observations have Diet=1, how many have Diet=2 and so on. In this case, you must tell `ggplot` you already have the count.
-->
```{r bargraph_identity, message=FALSE}
ggplot(data=ChickWeightFreq, mapping=aes(x=Diet, y=n)) + 
  geom_bar(stat="identity")
```

Quando la variabile `y` contiene le frequenze, dobbiamo comunicare a `ggplot` qual'è al variabile che contiene i conteggi (`y=n` nell'esempio) e a `geom_bar` che deve utilizzare `stat="identity"`. 

Una trasformazione statistica, o più colloquialmente detta `stats`, trasforma i dati facendone un summary nella maniera specificata. Tutti i `geom` sono basati su una trasformazione statistica. Per default, all'incirca tutti i `geom` visti finora utilizzano `stat="identity"`, che non trasforma i dati. Come appena visto, per default `geom_bar()` utilizza `stat="count"` che conta il numero di casi per ogni `x`. Se non è necessario trasformare i dati perchè questi lo sono già, è necessario impostare `stat="identity"`.   
<!--
Since you have an `y` variable containing frequencies, you tell `ggplot` the variable containing counts (`y=n` in the example) and to `geom_bar` that `stat="identity"` must be used. 

A statistical transformation, or `stat`, transforms the data, typically by summarizing it in some manner. All `geom`s are based on a statistical transformation. By default, almost all `geom`s seen until now uses `stat="identity"`, that do not transform data. As just seen, by default `geom_bar()` uses `stat="count"` that counts the number of cases at each `x` position. If you do not want to transform your data, `stat="identity"` must be supplied.
-->

## Bar plot impilati e raggruppati

Supponiamo di essere degli ingegneri addetti al controllo qualità che stanno analizzando il dataset `bands`. Siamo interessati a rappresentare il numero di presse per ogni tipologia, distinguendo anche la diemnsione del cilindro.

<!--
## Stacked and grouped bar plots

If you are a quality engineer analysing the `bands` data, you may be interested to the number of presses for each type, distinguishing them by the cylinder size.
-->
```{r bargraph_stack, message=FALSE}
ggplot(data=bands, mapping=aes(x=press_type, fill=cylinder_size)) + 
  geom_bar()
```

Ci basta mapparela variabile `cylinder_size` su `fill`. Dal grafico possiamo notare una piccola area grigia in cima alle ultime due barre: questo significa che ci sono pochi casi in cui `cylinder_size` ha dati mancanti.

Potremmo anche essere interessati alla distribuzione di `cylinder_size` per ogni `press_type`.

<!--
Mapping `fill` to `cylinder_size` does the job. Notice a small gray area at the top of the last two bars: this means there are few cases in which `cylinder_size` is missing. 

Sometimes you may be interested at the distribution of `cylinder_size` for each `press_type`.
-->
```{r bargraph_fill, message=FALSE}
ggplot(data=bands, mapping=aes(x=press_type, fill=cylinder_size)) + 
  geom_bar(position="fill")
```

In questo caso preferiamo avere una barra per ogni combinazione `press_type` e `cylinder_size`. Come fare? Affiancando le barre in questo modo:

<!--
In the case you prefer a bar for each combination of `press_type` and `cylinder_size`, you can `dodge` the bars.
-->

```{r bargraph_dodge, message=FALSE}
ggplot(data=bands, mapping=aes(x=press_type, fill=cylinder_size)) + 
  geom_bar(position="dodge")
```

Si noti che `position="dodge"` è un short key per `position=position_dodge()` con gli argomenti impostati ai valori di default. Possiamo incrementare o diminuire lo spazio tra le barre di ogni gruppo direttamente all'interno di questa funzione, impostando l'argomento `width`. Per modificare, invece, lo spazio tra ogni gruppo di barre è necessario impostare sempre l'argomento `width` ma della funzione `geom_bar()`.

<!--
Notice that `position="dodge"` is a short key for `position=position_dodge()` with its default value and you can modify this value to add space between bars. In the case you want to add space between bars, you probably want also to modify the `width` in order to add spaces among each group of bars.
-->

```{r bargraph_manualdodge, message=FALSE}
ggplot(data=bands, mapping=aes(x=press_type, fill=cylinder_size)) +
  geom_bar(position=position_dodge(0.85), width=0.6)
```

L'argomento `width` in `geom_bar()` determina l'ampiezza della barra; l'argomento `width` in `position_dodge()` determina la posizione di ogni barra. Serve un pò di pratica per capire a pieno queste funzionalità.

Tutte le osservazioni relative al tipo di pressa `MOTTER70` presentano `CATALOG` come `cylinder_size`. In questo caso le barre relative agli altri livelli della variabile `cylinder_size` sono mancanti e la barra relativa al livello `MOTTER70` si espande in modo tale da riempire tutto lo spazio.

Per evitare questo comportamento è necessario avere almeno un valore pari a `NA` per ogni combinazione di fattori. Poichè sia `ggplot2`, quando si construisce un grafico, che `dplyr`, quando si costruisce una tabella di frequenza, non mostrano alcun conteggio per i valori mancanti, è necessario costruire manualmente la tabella di frequenza con i valori mancanti che si desidera ottenere, come quella che segue:

<!--
The `width` in `geom_bar()` determines the width of the bar; the `width` in `position_dodge()` determines the position of each bar. Probably you can easily understand their behaviour after you play with them for a while.

All data related to `MOTTER70` press has `CATALOG` as `cylinder_size`. In this case, the bars related to other `cylinder_size` are missing and the `MOTTER70` bar will expand to fill the whole space.

To avoid this behaviour you must have at least a `NA` value for each combination of factors. Since both `ggplot2` when you plot and `dplyr` when you build a frequency table, do not show the count for missing combinations, you should manually build a frequency table like the following one.
-->

```{r bargraph_bands_freq_na, message=FALSE}
bands_freq_na <- bands %>% group_by(press_type, cylinder_size) %>% summarise(n = n()) %>%
  right_join(
    expand.grid(
      press_type = bands %>% magrittr::use_series(press_type) %>% levels,
      cylinder_size = c(bands %>% magrittr::use_series(cylinder_size) %>% levels, NA)
    )
  )
bands_freq_na
```

A questo punto, possiamo facilemnte costruire un grafico a partire dalla tabella di frequenza. Basta ricordarsi di mappare i conteggi a `y` e di aggiungere `stat="identity"` a `geom_bar()`.
<!--
At this point, you can easily build the plot starting from frequency table. Just remember to map the counts to `y` and to add `stat="identity"` to `geom_bar()`.
-->
```{r bargraph_stack_na, message=FALSE}
ggplot(data=bands_freq_na, mapping=aes(x=press_type, y=n, fill=cylinder_size)) +
  geom_bar(stat="identity", position="dodge")
```

Come abbiamo visto nel grafico precedente, `cylinder_size` è una variabile fattoriale con tre livelli: `CATALOG`, `SPIEGEL` e `TABLOID` ma presenta anche valori mancanti (`NA`). Per visualizzare `NA` coem livello nella legenda del grafico, l'unica soluzione è quella di ricodificare i livelli della variabile `cylinder_size`, aggiungendo anche `NA` coem livello. 

<!--
As you see in the previous plots, `cylinder_size` is a factor variable with three levels: `CATALOG`, `SPIEGEL` and `TABLOID` but it has also missing values (`NA`).   
To visualize also missing values (`NA`) as `cylinder_size` level in plots legend, you have to recode its levels, adding also `NA` as level.  
-->

```{r bargraph_na_as_level, message=FALSE}
bands <- bands %>% 
  mutate(cylinder_size = as.character(cylinder_size), 
         cylinder_size =ifelse(is.na(cylinder_size),"NA",cylinder_size), 
         cylinder_size = factor(cylinder_size, 
                                levels= c("CATALOG", "SPIEGEL", "TABLOID", "NA"), 
                                labels = c("CATALOG", "SPIEGEL", "TABLOID", "NA")))

ggplot(data=bands, mapping=aes(x=press_type, fill=cylinder_size)) +
  geom_bar() 
```

## Aggiungere testo al grafico

I garfici sono utili per catturare l'attenzione del nostro pubblico, ma certe volte volte non possono fare la parte anche di dati numerici o testo. Una soluzione per integrare queste informazioni nel grafico, è quella di aggiungerci proprio del testo.
<!--
## Adding text to plots

Plots are useful to catch the eye of your audience but sometimes they cannot replace numbers or text. Adding text to a plot can help you to integrate information in your plot.
-->
```{r bargraph_geomtext, message=FALSE}
bands_freq <- bands %>% group_by(press_type) %>% summarize(n=n())
  
ggplot(data=bands, mapping=aes(x=press_type)) +
  geom_bar() +
  geom_text(data=bands_freq, mapping=aes(y=n, label=n), vjust=1.5, colour="white")
```

`geom_text()` funziona prorio come qualsiasi altro `geom` visto finora. Richiede che vengano definite delle coordinate, una `x` ed una `y`. In questo caso `x` è `press_type` e viene ereditata dalla funzione `ggplot()`, mentre la `y` deve essere passata. Poichè `bands` non contiene i conteggi, calcolati da `stat_count` dentro `geom_bar()`, i dati di default vengono sovrascritti in `geom_text()` in modo da utilizzare le frequenze. `geom_text()` richiede che venga mappata anche l'estetica `label`, che fa riferimento al testo che deve essere scritto nel grafico. Fuori dalla funzione `aes()`, `vjust` sposta in su (o in giù) il testo e `colour` imposta il colore del testo.

<!--
`geom_text()` works as any other `geom` seen until now. It requires `x` and `y` coordinates; in this case, `x` is `press_type` and it is inherited from `ggplot()`, while `y` should be passed. Since `bands` data do not contains the count, that is computed by `stat_count` inside `geom_bar()`, default data are overwritten in `geom_text()` in order to use frequencies. `geom_text()` requires `label` that is the text to be written. Outside `aes()`, `vjust` move down (or up) the text and `colour` set text colour.
-->
