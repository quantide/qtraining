---
title: "Personalizzazione degli Assi"
output: html_document
---

```{r options, include=FALSE, purl=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning =FALSE, message = FALSE, fig.pos = 'H', fig.width = 4, fig.height = 3)
options(width = 108)
```

<!--
# Axes Customization
-->

```{r first, include=TRUE, purl=TRUE, message=FALSE}
require(ggplot2)
require(qdata)
require(scales)
data(bands)
data(brainbod)
```

Gli assi sono più importanti di quanto uno può pensare poichè forniscono il contesto dove vengono rappresentati e interpretati i dati. `ggplot2` ha dei defaults per gli assi che si adattano bene nella maggior parte dei casi. In certi casi, può risultare necessario controllare, ad esempio, la scala, le labels degli assi, il numero, la posizione e i labels dei tick marks, e così via.

<!--
Axes are more important than one thinks as they provide context for interpreting the displayed data. `ggplot2` displays the axes with defaults that look good in most cases, but you might want to control, for example, the axis scales, the axis labels, the number and placement of tick marks, the tick mark labels and so on. 
-->

![](./images/axes.png)

`ggplot2` permette di personalizzare l'aspetto degli assi utilizzando tre importanti componenti della sua gramamtica:

* le scale (`scales`), che controllano il processo di mappatura dai dati agli attributi estetici 
* le coordinate (`coordinates`), che descrivono come le coordinate dei dati siano mappate sullo spazio del grafico
* i temi (`themes`), che controllano gli tutti gli elementi del grafico non legati ai dati

Nei paragrafi seguenti vedremo come risolvere i problemi più comuni in merito alla personalizzazione degli assi.

<!--
`ggplot2` allows one to handle with the appearance of the axes by using three important elements of its grammar: 

* `scales`, which controls the mapping from data to aestethics attributes 
* `coordinates`, which describes how data coordinates are mapped to the plane of the graphic
* `themes`, which controls the non-data elements of the plot 

In the following paragraphs we will see how to handle with the most common questions about axes customization. 
-->

## Scambiare gli assi x e y

Scambiare x e y è semplice se si parla di scatterplot dato che `geom_point()` tratta `x` e `y` allo stesso modo. Infatti se si vuole cambiare ciò che va sull'asse verticale e ciò che va su quello orizzontale basta scambiare le variabili mappate sulle estetiche `x` e `y`. Tuttavia, non è così semplice quando si parla di Box Plot poichè questo tipo di grafico fa un summary dei dati lungo l'asse delle y, oppure quando si parla di Line Plot, che traccia le linee in una sola direzione lungo l'asse delle x. Per scambiare gli assi di questi o di altri geom, che non trattano gli assi delle x e delle y allo stesso modo, è necessario utilizzare la funzione `coord_flip()`, come visto nel capitolo _Creare un Bar Plot_.

Vediamo un esempio.
Consideriamo il dataset `bands`. Supponiamo di essere interessati a studiare le differenze nella distribuzione della variabile `ink_pct` per ogni livello della variabile `press_type`. Possiamo studiare la cosa, costruendo quattro Box Plot per confrontare le distribuzioni.

<!--
## Swapping x and y axis

Swapping x and y axis is simple if you are generating a scatterplot. If you want to change what goes on the vertical axis and what goes on the horizontal axis you just have to exchange the variables mapped to `x` and `y` aesthetics, as `geom_point()` treats the x- and y-axes equally. However, the same cannot be said for Box Plot which summarize the data along the y-axis or for Line Plots, which move the lines in only one direction along the x-axis. To swap the axis of these and more others geoms which not treats the x- and y-axes equally, you have to use `coord_flip()` function as we learn in _Creating a Bar Plot_ chapter.

Let us see an example.   
Consider `bands` dataset. Supposing you are interested in the differences of ink percentage accordingly to the type of press, you can build four box plots to compare distributions.
-->

```{r pl_1}
pl_1 <- ggplot(data=bands, aes(x=press_type, y=ink_pct)) + 
  geom_boxplot(fill="#74a9cf", colour="#034e7b")
pl_1
```

Scambiando gli assi, il risultato è:

<!--
Swapping the axes the result is:
-->

```{r pl_1_swapped_axes}
pl_1 + 
  coord_flip()
```


## cambaire l'ordine degli assi

Consideriamo un asse categoriale (o discreto) con un fattore mappato su di esso.
Spesso, quando gli assi sono scambiati, come nell'esempio precedente, l'ordine degli items sarà l'opposto di quello che ci si aspetta. In un grafico con assi x e y standard, infatti, gli items sull'asse delle x partono da sinistra e finiscono a destra, il che corrisponde al modo standard di leggere, da sinistra a destra. Quando si scambiano gli assi, la disposizione degli items parte ancora dall'origine, quindi significa cha va letta dal basso verso l'alto, il che va contro il classico modo di leggere gli assi. Spesso ciò costituisce un problema, quindi è necessario capovolgere l'ordine degli items nell'asse.     

Tale risultato può essere raggiunto impostando l'argomento `limits` della funzione `scale_x_discrete()` a `rev(levels(...))`, in questo modo:

<!--
## Change axis order

Let us consider a categorical (or discrete) axis with a factor mapped to it.

Sometimes when the axes are swapped, as in the previous example, the order of items will be the reverse of what you want.  
On a graph with standard x- and y-axes, the x items start at the left and go to the right, which corresponds to the normal way of reading, from left to right. When you swap the axes, the items still go from the origin outward, which in this case will be from bottom to top but this conflicts with the normal way of reading, from top to bottom. Sometimes this can be a problem, so it is necessary to reverse the axis order. 

This can be done by using `scale_x_discrete()` with `limits` argument set as `rev(levels(...))` in this way:
-->
```{r pl_1_reverse_discrete_axis_order}
pl_1 + 
  coord_flip() + 
  scale_x_discrete(limits=rev(levels(bands$press_type)))
```

In generale, per cambiare manualmente l'ordine degli item in un asse categoriale (o discreto) nei quai è mappato un fattore, è necessario specificare l'argomento `limits` delle funzioni `scale_x_discrete()` o `scale_y_discrete()` con un vettore contenente i livelli del fattore nell'ordine desiderato: 

<!--
In general, to manually change the order of items in a categorical (or discrete) axis with a factor mapped to it, you have to specify `limits` argument in `scale_x_discrete()` or `scale_y_discrete()` functions with a vector of the levels in the desired order:
-->

```{r pl_1_change_discrete_axis_order}
pl_1 + 
  coord_flip() + 
  scale_x_discrete(limits=c("MOTTER70","WOODHOE70","ALBERT70", "MOTTER94"))
```

E' possibile anche omettere degli items nel grafico, specificando solo quelli che sid esiderano rappresentare:

<!--
You can also omit items with this vector, specifying only the items you want to keep:
-->

```{r pl_1_remove_discrete_axis_level}
pl_1 + 
  coord_flip() + 
  scale_x_discrete(limits=c("MOTTER70","WOODHOE70"))
```

Dal grafico si può vedere come ci sia dello spazio vuoto al posto dei livelli omessi di `press_type` ("ALBERT70", "MOTTER94"). Molto probabilemnte si tratta di un bug della versione 2.1.0 di `ggplot2`, utilizzata per realizare questo libro.

_Nota_: i cambiamenti nell'ordine degli items negli assi funzionano anche senza l'impostazione della funzione `coord_flip()`.

<!--
There is empty space instead of not displayed `press_type` levels ("ALBERT70", "MOTTER94"). Maybe it is a bug of 2.1.0 version of `ggplot2`, used to realize this manual.

_Note:_ the changes on axis order works also without `coord_flip()` function.
-->

## Impostare il range di un asse continuo

`ggplot2` calcola automaticamente i limiti per gli assi dal range dei dati. Ma spesso abbiamo bisogno di personalizzare tali limiti, rimpicciolendoli per focalizzarci su un'area interessante del grafico o ampliandoli per confrontarli ad altei grafici.
`ggplot2` fornisce due modi per impostare il range degli assi. Il primo modo consiste nel modificare la scala del grafico, mentre il secondo nel tarsformare le coordinate. Il primo modo è quello più utilizzato, vediamolo nel dettaglio.

Per modificare i limiti negli assi delle x o delle y, possiamo utilizzare la funzione `scale_y_continuous()` e/o `scale_x_continuous()`, impostando l'argomento `limits` uguale ad un vettore di due elementi, il minimo e il massimo.  

<!--
## Setting the Range of a Continuous Axis

`ggplot2` computes the limits of an axes from the range of the data. But sometimes you could be interested in making the limits smaller that the range of the data to focus on an interesting area of the plot or to make the limits larger because you want multiple plots to match up.  
`ggplot2` provides two ways of setting the range of the axes. The first way is to modify the scale, and the second is to apply a coordinate transformation. The first way is the most used. Let us analyze it.

To change the limits in x and/or y axes you could use `scale_y_continuous()` and/or `scale_x_continuous()`, setting the `limits` argument. `limits` argument has to be set equal to a vector of lenght two:   
-->

```{r pl_1_change_continuous_axis_limits_1}
pl_1 + 
  scale_y_continuous(limits=c(0, max(bands$ink_pct)))
```

Dato che la modificazione dei limiti è una funzionalità molto utilizzata, `ggplot2` fornisce tre shorthand: `ylim()`, `xlim()` e `lims()`.

I due blocchi di codice seguenti producono gli stessi risultati prodotti dall'esempio precedente:

<!--
Because modifying limits is such a common task, `ggplot2` provides three shorthand: `ylim()`, `xlim()` and `lims()`.

The following two code lines produce equal results than the previous example:
-->
```{r pl_1_change_continuous_axis_limits_2, eval = FALSE}
pl_1 + 
  ylim(0, max(bands$ink_pct))

pl_1 + 
  lims(y = c(0, max(bands$ink_pct)))
```

Se si desidera impostare solamente un limite, l'altro deve essere espresso come `NA`. `ggplot2` calcola automaticamente i limiti non impostati dal range dei dati:

<!--
If you want to set only one limit, the other has to be set equal to `NA`. `ggplot2` computes automatically the not setted limit from the range of data:
-->
```{r pl_1_change_continuous_axis_limits_3}
pl_1 + 
  ylim(limits=c(NA, 100))
```

Spesso utilizzando entrambe le funzioni `ylim()` e `scale_y_continuous()` per impostare anche altre caratteristiche dell'asse si possono creare problemi (lo stesso vale per `scale_x_continuous()` e `xlim`), perchè solamente l'ultima delle impostazioni avrà effetto sul grafico. Nei prossimi due esempi, `ylim(0, 100)` dovrebbe fissare il range dell'asse delle y da 0 a 100, e `scale_y_continuous(breaks=c(0, 50, 100))` dovrebbe mettere i tick marks a 0, 50 e 100. Tuttavia, in entrambi i casi, solamente la seconda impostazione ha effetto:

<!--
Sometimes using `ylim()` and `scale_y_continuous()` to set other properties can create problems (the same goes for `scale_x_continuous()` and `xlim`), because only the last of the directives will have an effect. In the following two examples, `ylim(0, 100)` should set the y range from 0 to 100, and `scale_y_continuous(breaks=c(0, 50, 100))` should put tick marks at 0, 50, and 100. However, in both cases, only the second directive has any effect:
-->

```{r pl_1_limits_setting_conflict}
pl_1 + 
  ylim(0, 100) + 
  scale_y_continuous(breaks=c(0, 50, 100))
pl_1 + 
  scale_y_continuous(breaks=c(0, 50, 100)) + 
  ylim(0, 100)
```

Per far funzionare entrambe le impostazioni, vi suggeriamo di impostare sia i limiti che i breaks nella funzione `scale_y_continuous()`:

<!--
To make both changes work, we suggest you to set both limits and breaks in `scale_y_continuous()`:
-->

```{r pl_1_limits_setting_conflict_solve}
pl_1 + 
  scale_y_continuous(limits=c(0, 100), breaks=c(0, 50, 100))
```

Abbiamo visto come modificare le scale sia un'ottima soluzione per cambaire il range degli assi. Tuttavia, quando si modificano le scale degli assi per cambiare i limiti, ogni dato fuori dai limiti impostati viene rimosso, quindi non solo non viene mostrato, ma non verrà proprio più considerato. Considerando i Box Plot rappresentati in questi esempi, una volta ridotto il range degli assi, le statistiche del Box Plot saranno calcolate sui dati troncati e la forma del Box Plot cambierà. 
Applicando invece, una trasformazione alle coordinate del grafico per cam biare i limiti, i dati non vengono troncati; nella pratica, viene fatto uno zoom dentro o fuori al range specificato. 

Vediamo le differenze tra questi due metodi:

<!--
We saw that modifying the scale for changing axes limits works well. However, when you modify the limits of the x or y scale, any data outside of the limits is removed that is, the out-of-range data is not only not displayed, it is removed from consideration entirely.   
With the Box Plots in these examples, if you restrict the y range so that some of the original data is clipped, the box plot statistics will be computed based on clipped data, and the shape of the box plots will change.  
With a coordinate transformation for changing limits, the data is not clipped; in essence, it zooms in or out to the specified range.   
Let us see the difference between these two methods:
-->
```{r pl_1_limits_setting_coord}
# scale transformation method
pl_1 + 
  scale_y_continuous(limits = c(50, 60))
# coordinate transformation method
pl_1 + 
  coord_cartesian(ylim = c(50, 60))
```

## Capovolgere l'ordine degli item in un asse continuo

Per capovolgere l'ordine in un asse continuo la funzione da utilizzare è `scale_y_reverse()` o `scale_x_reverse()`:

<!--
## Reverse a continuous axis order

To reverse a continuous axes the function to use are: `scale_y_reverse()` or `scale_x_reverse()`:
-->
```{r pl_1_reverse_continuous_axis_order_1}
pl_1 + 
  scale_y_reverse()
```

E' possibile utilizzare anche `ylim()`, in questo modo:
<!--
You can use also `ylim()` in this way:
-->
```{r pl_1_reverse_continuous_axis_order_2}
pl_1 + 
  ylim(70, 34)
```

Come `scale_y_continuous()` anche `scale_y_reverse()` non funziona con `ylim()` (lo stesso vale per l'asse delle x). Se l'obiettivo è quello di capovolgere un asse e impostare il suo range, è necessario farlo all'interno della funzione `scale_y_reverse()`, impostando i limiti in ordine rovesciato: 

<!--
Like `scale_y_continuous()`, `scale_y_reverse()` does not work with `ylim()`. (The same is true for the x-axis properties.) If you want to reverse an axis and set its range, you must do it within the `scale_y_reverse()` statement, by setting the limits in reversed order:
-->
```{r pl_1_reverse_continuous_axis_order_3}
pl_1 + 
  scale_y_reverse(limits=c(100, 0))
```

## Riscalare le scale degli assi

Supponiamo di essere interessati alla relazione tra la percentuale di inchiostro e di solvente nel dataset `bands`:

<!--
## Resize axis scale

Suppose you are interested in the relationship between ink and solvent percentage in `bands` dataset:
-->
```{r pl_2}
pl_2 <- ggplot(data = bands, mapping = aes(y=ink_pct, x=solvent_pct)) +
  geom_point()
```

Per ottenere la stessa scala per entrambi gli assi, è necessario utilizzare la funzione `coord_equal()`. 

<!--
If you want the same scale for your axes, you have to use `coord_equal()` function.
-->
```{r pl_2_same_scale}
pl_2  +
  coord_equal()
```

Per default, l'argomento `ratio` è impostato ad 1, il che assicura che un'unità sull'asse delle x abbia la stessa lunghezza di un'unità sull'asse delle y.

Quindi, possiamo riscalare le scale degli assi a nostro piacimento, impostando l'argomento `ratio`:

<!--
By default `ratio` argument is set to 1, which ensures that one unit on the x-axis is the same length as one unit on the y-axis.

You can change it as you want to resize the scales:
-->
```{r pl_2_resize_scale}
pl_2  +
  coord_equal(ratio=1/2)
```

L'argomento `ratio` deve essere interpretato come `y / x`, quindi nell'esempio precedente, due unità sull'asse delle x corrispondono a una sull'asse delle x.

<!--
Ratio is expressed as  `y / x`, so in the previous example, two unit on the x-axis correspond to one unit on the y-axis.

You can use also `coord_fixed()` to achieve the same results.
-->

## Trasformazione della scala dell'asse

Il dataset `brainbod` riporta informazioni circa il peso del corpo e del cervello di diverse specie di animali. Supponiamo di voler visualizzare la relazione tra peso del corpo e peso del cervello in 15 specie animali:

<!--
## Axis scale transformations

`brainbod` dataset contains information about the weight of body and brain of different species of animals. We wants to visualize the relationship between body weight and brain weight of 15 animals species: 
-->

```{r pl_3}
pl_3 <- ggplot(brainbod, aes(x=Body, y=Brain, label=Species)) +
  geom_text(size=3)
pl_3
```

Con le scale di default degli assi, è difficile dare un senso a questo grafico, infatti a causa della presenza dell'elefante, il resto degli animali si trova schiacciato nella parte in basso a sinistra del grafico. Questo è il caso di dati distribuiti esponenzialmente in entrambi gli assi, quindi una trasformazione logaritmica è la soluzione migliore. Le funzioni `scale_x_log10()` e `scale_y_log10()` sono scale di posizione continua con il compito di trasformare le scale di x e y, rispettivamente.

<!--
With the default linearly scaled axes, it’s hard to make much sense of this graph. Because of the presence of elephant, the rest of the animals get squished into the lower-left corner of the graph. This is a case where the data is distributed exponentially on both axes, so a logarithmic transformations is the best solution. `scale_x_log10()` and `scale_y_log10()` functions are continuous position scales which transform x and y axis scales respectively.
-->

```{r pl_3_log_scale_1}
pl_3 + 
  scale_x_log10() + 
  scale_y_log10()
```

Ora, i risultati del grafico sono interpretabili, vediamo chiaramente una relazione lineare tra il peso del cervello e il peso del corpo delle specie animali considerate. 

Nell'esempio precedente abbiamo utilizzato una trasformazione $log_{10}$, ma è possibile utilizzare anche altre trasformazioni, come $log_{2}$ o il logaritmo in base naturale. `scale_x_log10()` e (similmente per `y`) è una shortcut dato che è una delle trasformazioni più utilizzate. E' possibile, infatti, applicare una grande varietà di trasformazioni alle scale continue degli assi, impostando l'argomento `trans` della funzione `scale_x_continuous()` e/o `scale_y_continuous()`.  

Applichiamo la traformazione logaritmo naturaleall'asse delle `x` e la trasformazione $log_{2}$ all'asse delle `y`:

<!--
Now the plot results are intrepretable, we clearly see a linear relationship between brain weight and body weight of the analyzed animal species.  

The previous example used a $log_{10}$ transformation, but it is possible to use other transformations, such as $log_{2}$ and natural log. `scale_x_log10()` (and similarly for y) is a shortcut as it is one of the most common trasformations. A wide variety of transformations can be applied to scales of continuous axes, by setting `trans` argument of `scale_x_continuous()` and/or `scale_y_continuous()`. 

Let us apply natural logarithmic transformation to x axis and $log_{2}$ transformation to y axis:
-->

```{r pl_3_log_scale_2}
pl_3 + 
  scale_x_continuous(trans = log_trans()) +
  scale_y_continuous(trans = log2_trans())
```

## Modificare l'aspetto estetico del grafico: tick labels, tick markse e grid lines

Attualmente, ci sono tre items  hc epossono essere controllati: tick labels, tick marks e grid lines. Per quanto riguarda gli assi continui, `ggplot()` solitamente posiziona un tick label, un tick mark e una grid line principale per ogni valore di break. Per quanto riguarda, invece, gli assi categotiali tick labels, tick marks e grid lines principali sono posizionati in corrispondenza di ogni livello.   

<!--
## Modifying axis appearance: tick labels, tick marks, and the grid lines

There are actually three related items that can be controlled: tick labels, tick marks, and the grid lines. For continuous axes, `ggplot()` normally places a tick label, tick mark, and major grid line at each value of breaks. For categorical axes, these things go at each value of limits.
-->

### Cambiare la posizione dei tick marks 

Solitamente `ggplot()` è efficiente nel decidere dove posizionare i tick marks, ma per cambiarne la posizione è necessario impostare i `breaks` in questo modo: 

<!--
### Change Tick marks position

Usually `ggplot()` does a good job of deciding where to put the tick marks, but if you want to change them, set breaks in the scale in this way:
-->

```{r pl_1_change_tick_marks_position_continuous}
pl_1 + 
  scale_y_continuous(breaks=c(41, 45, 51, 55, 60, 71, 77))
```

La posizione dei tick marks definisce dove devono essere tracciate le gid lines principali. Se l'asse rappresenta una variabile continua, le grid lines minori, che sono più deboli e senza etichetta, saranno tracciate a metà tra le grid lines principali. Se l'asse è discreto invece che continuo, per default viene segnato un tick mark per ogni item. 

Per gli assi discreti, è possibile cambiarne l'ordine o rimuoverli specificando i limiti come visto nel paragrafo _Cambiare l'ordine degli assi_. Impostando i breaks cambieranno i livelli etichettati, ma non ne verrà rimosso alcuno e neppure il loro ordine sarà cambiato.

<!--
The location of the tick marks defines where major grid lines are drawn. If the axis represents a continuous variable, minor grid lines, which are fainter and unlabeled, will by default be drawn halfway between each major grid line. If the axis is discrete instead of continuous, then there is by default a tick mark for each item.  

For discrete axes, you can change the order of items or remove them by specifying the limits as learn in _Change axis order_
 paragraph. Setting breaks will change which of the levels are labeled, but will not remove them or change their order.
-->

```{r, pl_1_change_tick_marks_position_discrete}
pl_1 + 
  scale_x_discrete(limits=c("MOTTER70","WOODHOE70", "MOTTER94", "ALBERT70"), 
                   breaks="WOODHOE70")
```

### Rimuovere i tick marks e le loro labels

La funzione da utilizzare all'interno di `theme` per rimuovere sia i tick marks che i loro labels, è `element_blank()`.  

Gli argomenti `axis.text.x`, `axis.text.y` e `axis.text` della funzione `theme()` controllano il testo dei tick di `x`, `y` o di entrambi gli assi. 

Per rimuovere solamente i tick labels per entrambi gli assi bisogna utilizzare la funzione `theme(axis.text = element_blank())` mentre per rimuovere i tick labels solamente per l'asse delle `y` bisogna utilizzare `theme(axis.text.y = element_blank())` (lo stesso concetto vale per `axis.text.x`). Tutto ciò funziona sia nel caso di assi continui che catgoriali:     

<!--
### Removing Tick Marks and Labels

The theme function for the removal of both tick marks and labels is `element_blank()`.

`axis.text.x`, `axis.text.y` and `axis.text` arguments of `theme()` function controls the text of x, y or both axis ticks.

To remove just the tick labels of both axes use `theme(axis.text = element_blank())`, and to remove the tick labels of y axes use `theme(axis.text.y = element_blank())` (or do the same for `axis.text.x`). This will work for both continuous and categorical axes:
-->

```{r pl_1_remove_tick_labels}
pl_1 + 
  theme(axis.text.y = element_blank())
pl_1 + 
  theme(axis.text = element_blank())
```

`axis.ticks.x`, `axis.ticks.y` e `axis.ticks` controllano i marks di `x`, `y` o di entrambi i ticks degli assi.

Per rimuovere i tock marks su entrambi gli assi, va utilizzata la funzione `theme(axis.ticks=element_blank())`, mentre per rimuovere solamente i tick marks dell'asse delle `y` va utilizzata `theme(axis.ticks.y=element_blank())`. 

<!--
`axis.ticks.x`, `axis.ticks.y` and `axis.ticks` controls the marks of x, y or both axis ticks.

To remove the tick marks on both axes, use `theme(axis.ticks=element_blank())`, and to remove the tick marks of y axes use `theme(axis.ticks.y=element_blank())`. This will remove the tick marks.
-->

```{r pl_1_remove_tick_marks_labels_1}
pl_1 + 
  theme(axis.ticks.y = element_blank(), axis.text.y = element_blank())
pl_1 + 
  theme(axis.ticks = element_blank(), axis.text = element_blank())
```

Per rimuovere i tick marks, le labels, e le grid lines per gli assi continui, è necessario impostare l'argomento `breaks` a `NULL` nella funzione `scale_y_continuous()` (lo stesso vale per `scale_x_continuous()`) 

<!--
To remove the tick marks, the labels, and the grid lines for continuous axis, set `breaks` to `NULL` in `scale_y_continuous` (the same for `scale_x_continuous`).
-->

```{r pl_1_remove_tick_marks_labels_2}
pl_1 + 
  scale_y_continuous(breaks=NULL)
```

### Cambiare il testo dei tick labels

Consideriamo lo scatterplot che mosra la relazione tra la percentuale di inchiostro e di solvente nel dataset `bands`, allocato nell'oggetto `pl_2`:

<!--
### Changing the Text of Tick Labels

Let us consider the scatterplot showing the relationship between ink and solvent percentage in cylinder banding process in rotogravure printing, stored in `pl_2` object:
-->
```{r pl_2_show}
pl_2
```

Per cambiare il testo dei tick amrks negli assi continui, è necessario impostare gli argomenti `breaks` e `labels` della funzione `scale_y_continuous()`:

<!--
To change the text of ticks marks in continuous axes, set `breaks` and `labels` in `scale_y_continuous` function:
-->
```{r pl_2_change_tick_labels_text}
pl_2 +  
  scale_y_continuous(breaks=c(40, 50, 60, 70), 
                     labels=c("Less", "Medium-\nLess", "Medium-\nHigh", "High"))
```

Fate attenzione al carattere `"\n"`, è necessario per comunicare a `ggplot()` di andare a capo.

Consideriamo l'esempio visto nel paragrafo _Trasformazione della scala dell'asse_, che analizza la relazione tra corpo e cervello di 15 spece animali, allocato nell'oggetto `pl_3`:

<!--
Pay attention to `"\n"` character, which tells `ggplot()` to put a line break.

Let us consider the example described in _Axis scale transformations_ paragraph, which analyze the relationship between body  and brain weight of 15 species of animals, stored in `pl_3` object:   
-->
```{r pl_3_show}
pl_3
```

Applichiamo una trasformazione logaritmica all'asse:

<!--
We applied a logarithmic transformation to the axis: 
-->
```{r pl_3_log_scale_show}
pl_3 +
  scale_x_log10()+
  scale_y_log10()
```

Con un asse logaritmico, ogni unità nell'asse rappresenta una costante di cambiamento proporzionale; ad esempio, ogni centimetro nell'asse delle y potrebbe rappresentare una moltiplicazione per 10. In presenza di assi lineari, inveci, ogni unità rappresenta una quantità di cambiamento costante; ogni centimetro potrebbe rappresentare un'aggiunta di 10. 

`ggplot2 ` cerca sempre di posizionare i tick marks nel modo più opportuno, ma è possibile modificare il default impostando l'argomento `breaks` e, facoltativamente, anche i labels. In quest'esempio, i tick marks sono più distanziati di quanto si vorrebbe. Per i tick marks dell'asse delle y, possiamo definire un vettore per contenente ogni potenza 10 da
$10^{0}$ a $10^{3}$ come:

`10^(0:3)`

<!--
With a log axis, a given visual distance represents a constant proportional change; for example, each centimeter on the y-axis might represent a multiplication of the quantity by 10. In contrast, with a linear axis, a given visual distance represents a constant quantity change; each centimeter might represent adding 10 to the quantity.

`ggplot2 ` will try to make good decisions about where to place the tick marks, but if you don’t like them, you can change them by specifying breaks and, optionally, labels . In the example here, the automatically generated tick marks are spaced farther apart than is ideal. For the y-axis tick marks, we can get a vector of every power of 10 from $10^{0}$ to
$10^{3}$ like this:

`10^(0:3)`
-->

```{r pl_3_change_tick_labels_text}
pl_3 + 
  scale_x_log10(breaks=10^(-1:5)) + 
  scale_y_log10(breaks=10^(0:3))
```

Invece di utilizzare la notazione esponenziale per le labels dei breaks, possiamo fare riferimento alla funzione `trans_format()` del package `scales`:

Supponendo che tale package sia già stato installato, è necessario caricarlo nel workspace:

<!--
To instead use exponential notation for the break labels, use the `trans_format()` function, from the `scales` package:.

Supposing `scales` is already installed, it must be loaded:
-->

```{r load_scales, eval=FALSE}
require(scales)
```

Torniamo all'esempio del box plot che mostra la distribuzione della variabile `ink_pct` per ogni livello di `press_type` nel dataset `bands`. Per cambiare il testo dei tock amrks negli assi discreti, è necessario impostare l'argomento `labels` nella funzione `scale_x_discrete()`:

<!--
Let us go back to boxplot showing the distribution of `ink_pct` by `press_type` in `bands` dataset.   
To change the text of ticks marks in discrete axes, set the `labels` argument in `scale_x_discrete()` function.
-->

```{r pl_1_change_tick_labels_text_discrete}
pl_1 + 
  scale_x_discrete(labels=c("Albert70", "Motter70", "Motter94", "Woodhoe70"))
```

### Cambiare l'aspetto estetico dei tick labels

Le proprietà del testo come l'angolatura, la dimensione, lo stile (grassetto, corsivo, normale) e il font (come Times o Helvetica) posssono essere impostati all'interno della funzione `element_text()` in `theme()`:

<!--
### Changing the Appearance of Tick Labels

Text properties like rotation, size, style (bold/italic/normal), and the font family (such as Times or Helvetica) can be set with `element_text()` theme function: 
-->

```{r pl_1_change_tick_labels_appearance_1}
# To rotate the text 90 degrees counterclockwise
pl_1 + 
  theme(axis.text.x = element_text(angle=90, hjust=1, vjust=0.5))
# Rotating the text 30 degrees
pl_1 + 
  theme(axis.text.x = element_text(angle=30, hjust=1, vjust=1))
```

Il parametro `angle` specifica l'angolatura del testo e `hjust` e `vjust` specificano l'allineamento orizzontale (sinistra/centro/destra) e verticale (alto/mezzo/basso), rispettivamente. 

<!--
The `angle` setting specifies the text rotation and the `hjust` and `vjust` settings specify the horizontal alignment (left/center/right) and vertical alignment (top/middle/bottom).
-->
```{r pl_1_change_tick_labels_appearance_2}
pl_1 + 
  theme(axis.text.x = element_text(family="Times", face="bold", colour="darkgreen", size=rel(0.8)))
```

Il parametro `family` specifica il font da utilizzare, `face` identifica lo stile, `colour` il colore del testo e `size` la grandezza sempre del teso. In questo esempio notiamo che il parametro `size` è impostato a `rel(0.8)`, cioè la dimensione del testo deve essere 0.8 volte la dimensione base per il theme.

<!--
The `family` setting specifies the font family, `face` the font face, `colour` the text colour and `size` the text size.
In this example, the size is set to `rel(0.8)`, which means that it is 0.8 times the size of the base font size for the theme.
-->

### Cambiare l'aspetto estetico dei tick marks

L'aspetto estetico dei tick amrks può essere cambiato utilizzando la funzione `element_line()` all'interno di `theme()`.

<!--
### Changing the Appearance of Tick marks

The appearance of tick marks can be changed by `element_line()` theme function.
-->

```{r pl_1_change_tick_marks_appearance}
pl_1 + 
  theme(axis.ticks.x = element_line(colour="green", size=4), axis.ticks.y=element_line(colour="red"))
```

In particolare, l'argomento `colour` indica il colore della linea e `size` la dimensione della linea.

<!--
In particular, `colour` setting specifies the line colour and `size` the line size.
-->

<!--
aggiungere esempio sul log?
-->

### Cambiare il testo dei labels degli assi

Per default, i grafici utilizzano i nomi di colonna del data frame come labels degli assi. Questo può andare bene per avere un immediato riferimento ai dati, ma non per presentazioni, per le quali sono necessarie labels con descrizioni più accurate.

`ggplot2` fornisce tre modi equivalenti per canbiare i labels degli assi:

<!--
### Changing the Text of Axis Labels

By default the graphs will just use the column names from the data frame as axis labels. This might be fine for exploring data, but for presenting it, you may want more descriptive axis labels.

`ggplot2` provides these three equivalent ways to change the axis labels:
-->

```{r pl_1_change_axis_labels, eval=FALSE}
pl_1 + 
  xlab("Pressure type") + 
  ylab("Ink percentage")
pl_1 + 
  labs(x = "Pressure type", y = "Ink percentage")
pl_1 + 
  scale_y_continuous(name="Ink percentage") + 
  scale_x_discrete(name="Pressure type")
```

I tre comandi visti sopra producono lo stesso risultato:

<!--
Which produces the same results:
-->

```{r, echo=FALSE, purl=FALSE}
pl_1 + 
  labs(x = "Pressure type", y = "Ink percentage")
```

Utilizzare la funzione `scale_y_continuous()` può sembrare un pò più articolato, ma è utile nel momento in cui si necessita di impostare altre caratteristiche della scala, come il posizionamento dei tick marks, il range degli assi, e così via.

<!--
Using `scale_y_continuous()` may look a bit awkward, but it can be useful if you’re also setting other properties of the scale, such as the tick mark placement, range, and so on.
-->

### Rimuovere i labels degli assi

Spesso i albels degli assi sono ridontanti opore ovvi a partire dal contesto, quindi non si necessità che vengano mostrati.

Possiamo impostare il label dell'asse delle x come una stringa vuota:

<!--
### Removing Axis Labels

Sometimes axis labels are redundant or obvious from the context, and don’t need to be displayed.

You can set x label to an empty string:
-->
```{r pl_1_remove_axis_labels_1}
pl_1 + 
  xlab("")
```

O possiamo utilizzare la funzione `theme()` impostando al suo interno `axis.title.x=element_blank()`:  

<!--
or you can use `theme()` function to set `axis.title.x=element_blank()`:
-->

```{r pl_1_remove_axis_labels_2}
pl_1 + 
  theme(axis.title.x=element_blank())
```

La differenza tra questi due modi stà nel fatto che la funzione `theme()` non cambia il nome dell'asse. Il testo, infatti, non viene mostrato e alcun spazio viene riservato ad esso. Quando, invece, si imposta il label a `""` nella funzione `xlab()`, il nome della scala non viene cambiato e viene mostrato del testo vuoto.

<!--
The difference between the two ways is that `theme()` function doesn't change axis name. The text is not displayed and no space is reserved for it. When you set the label to "" in `xlab()` function, the name of the scale is changed and the (empty) text is displayed.
-->

### Cambiare l'aspetto estetico delle labels degli assi

Gli argomenti `axis.title.x`, `axis.title.y` e `axis.title` della funzione `theme()` controllano i labels di `x`, `y` o di entrambi gli assi. 

La funzione di riferimento è `element_text()` e lavora come visto nel paragrafo _Cambiare l'aspetto estetico dei tick labels_.

<!--
### Changing the appearance of axis labels

`axis.title.x`, `axis.title.y` and `axis.title` arguments of `theme()` function controls the label of x, y or both axis.

The reference function is `element_text()` and works at the same way as we saw in _Changing the Appearance of Tick Labels_ paragraph.
-->
```{r pl_1_change_axis_labels_appearance}
pl_1 + 
  theme(axis.title.y=element_text(angle=0, face="italic", size=14, colour = "green"))
```

## Usare le date negli assi

`ggplot2` tratta due tipi di oggetti "data": le date (oggetti di classe `Date`) e le date-ore (oggetti di classe `POSIXt`). La differenza tra questi è che gli oggetti di classe `Date` rappresentano date con risoluzione di una giornata, mentre quelli di classe `POSIXt` rappresentano momenti nel tempo e hanno una risoluzione di una frazione di secondo. 

La specifica dei `breaks` è simile a quella degli assi numerici. La differenza principale è nella specificazione di una sequenza did ate da utilizzare. Utilizzeremo per quest esempio, un sottoinsieme del dataset `economics`, disponibile all'interno del package `ggplot2`, che va da maggio 1992 a giugno 1993.   

<!--
## Using Dates on an Axis

`ggplot2` handles two kinds of time-related objects: dates (objects of class Date ) and date-times (objects of class POSIXt). The difference between these is that Date objects represent dates and have a resolution of one day, while POSIXt objects represent moments in time and have a resolution of a fraction of a second.  
Specifying the breaks is similar to with a numeric axis, the main difference is in specifying the sequence of dates to use.  
We use a subset of the `economics` data, provided in `ggplot2` package which ranges from may 1992 to june 1993. 
-->
```{r economics_sample}
econ <- subset(economics, date >= as.Date("1992-05-01") & date < as.Date("1993-06-01"))
```

Supponiamo di voler generare una serie storica del tasso di risparmio personale:

<!--
Suppose we want to generate the time series plot of personal savings rate:
-->

```{r pl_4}
pl_4 <- ggplot(econ, aes(x=date, y=psavert)) + 
  geom_line(colour = "orangered")
pl_4
```

La funzione `scale_x_date()` tratte le scale di date, l'argomento `date_breaks` specifica la distanza tra i breaks.

<!--
`scale_x_date()` function handle with date scales, the argument `date_breaks` specifies the distance between breaks.
-->

```{r pl_4_change_axis_labels_1}
# Use breaks, and rotate text labels
pl_4 + 
  scale_x_date(date_breaks= "2 month") + 
  theme(axis.text.x = element_text(angle=30, hjust=1))
```

Notiamo che la formattazione dei breaks cambia. Possiamo specificare la formattazione utilizzando la funzione `date_format()` dal package `scales` come valore dell'argomento `label`: 

<!--
Notice that the formatting of the breaks changed. You can specify the formatting by using the `date_format()` function from the `scales` package as `label` value: 
-->

```{r pl_4_change_axis_labels_2}
pl_4 + 
  scale_x_date(date_breaks= "2 month", labels=date_format("%Y %b")) +
  theme(axis.text.x = element_text(angle=30, hjust=1))
```

Il formato specificato è `"%Y %b"`, che risulta come `"1992 Jun"`. Tale formato deve essere passato come strimga alla funzione `date_format()` e gli indicatori di formato saranno sostituiti con i valori appropriati. per esempio, se si imposta `"%B %d, %Y"`, risulteranno labels come "June 01, 1992"`.

<!--
The format specified is `"%Y %b"`, which results like `"1992 Jun"`.

The format specified is to be put in a string that is passed to `date_format()`, and the format specifiers will be replaced with the appropriate values. For example, if you use `"%B %d, %Y"`, it will result in labels like `"June 01, 1992"`.
-->

La seguente tabella elenca i più importanti formati data-ora:

Opzione   | Descrizione 
--------- | ------------------------------------------------------------------------------------- 
%Y        |  Anno con secolo (2012)
%y        |  Anno senza secolo (12)
%m        |  Mese come numero decimale (08)
%b        |  Abbreviazione del nome del mese nella posizione corrente (Aug)
%B        |  Nome del mese completo nella posizione corrente (August)
%d        |  Giorno del mese come numero decimale (04)
%U        |  Settimana dell'anno come numero decimale, con Domenica come primo giorno della settimana (00–53)
%W        |  Settimana dell'anno come numero decimale, con Lunedì come primo giorno della settimana (00–53)
%w        |  giorno della settimana (0–6, Domenica è 0)
%a        |  Abbreviazione dei nomi della settimana (Thu)
%A        |  Nomi della settimana completi (Thursday)

<!--
The following table lists the most important date-time format:


Option    | Description 
--------- | ------------------------------------------------------------------------------------- 
%Y        |  Year with century (2012)
%y        |  Year without century (12)
%m        |  Month as a decimal number (08)
%b        |  Abbreviated month name in current locale (Aug)
%B        |  Full month name in current locale (August)
%d        |  Day of month as a decimal number (04)
%U        |  Week of the year as a decimal number, with Sunday as the first day of the week (00–53)
%W        |  Week of the year as a decimal number, with Monday as the first day of the week (00–53)
%w        |  Day of week (0–6, Sunday is 0)
%a        |  Abbreviated weekday name (Thu)
%A        |  Full weekday name (Thursday)
-->


