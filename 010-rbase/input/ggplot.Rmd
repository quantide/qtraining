---
title: "Key concepts about the grammar of graphics"
---

```{r date-requirePackages, echo=FALSE, message=FALSE}
# Install required packages
if(! "ggplot2" %in% installed.packages()) {install.packages("ggplot2")}
if(! "nycflights13" %in% installed.packages()) {install.packages("nycflights13")}
if(! "dplyr" %in% installed.packages()) {install.packages("dplyr")}
###################################################################
```

```{r echo=FALSE,message=FALSE}
library(ggplot2)
library(nycflights13)
library(dplyr)
require(qdata)
data(bands)
```

```{r echo=FALSE, message=FALSE}
set.seed(1000)
sflights <- flights[sample(nrow(flights), 500), ]
```


# ggplot()

`ggplot()` function creates a chart with `ggplot2`.  

Suppose you are interested in the relationship between the humidity and the viscosity in the `bands` dataset. 

```{r ggplot, warning=FALSE}
pl <- ggplot(data = bands, mapping = aes(x = humidity, y = viscosity))
```

The syntax is quite simple. The function `ggplot()` initializes the plot with the following parameters: the _data_ are in the `bands` data frame, which represents the data frame that you want to visualise, and you _map_ the data to _aesthetics_ (visual properties) of plot like follow: the _x_-axis displays the `humidity` variable and the _y_-axis displays the `viscosity` variable. 

The `ggplot()` function does not return anything so this plot object cannot be displayed until a layer will be added.

# Layers
Layers are responsible for creating the objects perceived on the plot.  
A layer is composed of four parts:

* data and aesthetic mapping of the layer itself; 
* a geometric object (`geom`), which controls the type of plot to create;
* a statistical transformation (`stat`) of the original dataset;
* a position adjustment of elements within a layer.

`layer(geom, geom_params, stat, stat_params, data, mapping, position)`

## Data and aesthetic mapping

`data`(optional) refers to a dataset which overrides the default plot dataset. It is most commonly omitted, in which case the layer will use the default plot data.

`mapping` (optional) refers to a set of aesthetic mappings, specified using the `aes()` function and combined with the plot defaults.

<!--
   The `aes` function takes a list of aesthetic-variable pairs like these:
```{r aes, eval=FALSE, warning=FALSE}
aes(x = distance, y = air_time, colour = carrier)
```

Here `x-position` is mapped to `distance`, `y-position` to `air_time` and `colour` to `carrier`. The first two arguments can be left without names, in which case they correspond to the `x` and `y` variables.  
Also functions of variables can be used.

-->

## Geom
Geometric objects, or geoms for short, perform the actual rendering of the layer, control the type of plot that you create. It is a text string containing the name of the `geom` to use.

This table lists all of the geoms available in `ggplot2`:


Name        | Description
----------- | -------------
abline      | Line, specified by slope and intercept
area        | Area plots
bar         | Bars, rectangles with bases on y-axis
blank       | Blank, draws nothing
boxplot     | Box-and-whisker plot
contour     | Display contours of a 3d surface in 2d
crossbar    | Hollow bar with middle indicated by horizontal line
density     | Display a smooth density estimate
density 2d  | Contours from a 2d density estimate
errorbar    | Error bars
histogram   | Histogram
hline       | Line, horizontal
interval    | Base for all interval (range) geoms
jitter      | Points, jittered to reduce overplotting
line        | Connect observations, in order of x value
linerange   | An interval represented by a vertical line
path        | Connect observations, in original order
point       | Points, as for a scatterplot
pointrange  | An interval represented by a vertical line, with a point in the middle
polygon     | Polygon, a filled path
quantile    | Add quantile lines from a quantile regression
ribbon      | Ribbons, y range with continuous x values
rug         | Marginal rug plots
segment     | Single line segments
smooth      | Add a smoothed condition mean
step        | Connect observations by stairs
text        | Textual annotations
tile        | Tile plot as densely as possible, assuming that every tile is the same size
vline       | Line, vertical

Each geom has a set of aesthetics that it understands, and a set that are required for drawing. 
The most used aestetics are listed below:

* `colour`
* `fill`
* `lower`, `middle`, `upper`
* `linetype`
* `size`
* `shape`
* `weight`
* `x`
* `y`
* `ymax`, `ymin`

Let us see how to create the most important types of graph, as scatterplot, linegraph, bargraph, histogram and boxplot.

### Scatterplot 
Scatter plots are used to display the relationship between two continuous variables. Axes represent a variable each, while each point represents an observation. This plot is often the first way to describe data when you look at it. 

As a scatter plot is made by points, add `geom_point()` geom to a ggplot object to build a scatterplot.  
The following example shows the command to build the scatterplot that relates `humidity` and `viscosity` in the `bands` dataset:   
```{r geom_point, warning=FALSE}
pl1 <- ggplot(data = bands, mapping = aes(x = humidity, y = viscosity))
pl1 + geom_point()
```


#### Changing the shape and size of points

At this point, you probably are interested to change the aspect of points like shape or size: it suffices to set the `shape` or the `size` as a parameter of `geom_point()`.

```{r scatterplot_shape, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=humidity, y=viscosity)) + 
  geom_point(shape=2)
```

The following shapes are available in R graphics. Point shapes from 0 to 14 have just an outline, shapes from 15 to 20 are solid and shapes from 21 to 25 have both an outline and a fill. Default shape for `ggplot2` graphics is 16.

```{r plot_shape, echo=FALSE, fig=TRUE, purl=FALSE}
 par(mar=rep(0,4))
 # Make an empty chart
 plot(1, 1, xlim = c(1, 5.5), ylim=c(0.5, 9.5), type = "n", axes = FALSE, ann = FALSE, frame.plot = TRUE, mar=0)
 # Plot symbols 0-4 with increasing size
 points(1:5, rep(9, 5), cex = 2, pch = 0:4, col="red", bg="green")
 text((1:5) + 0.4, rep(9, 5), cex = 1, (0:4))
 # Plot symbols 5-9 with labels
 points(1:5, rep(7, 5), cex = 2, pch = (5:9), col="red", bg="green")
 text((1:5) + 0.4, rep(7, 5), cex = 1, (5:9))
 # Plot symbols 10-14 with labels
 points(1:5, rep(5, 5), cex = 2, pch = (10:14), col="red", bg="green")
 text((1:5) + 0.4, rep(5, 5), cex = 1, (10:14))
 # Plot symbols 15-19 with labels
 points(1:6 * 0.8 + 0.2, rep(3, 6), cex = 2, pch = (15:20), col="red", bg="green")
 text((1:6) * 0.8 + 0.6, rep(3, 6), cex = 1, (15:20))
 # Plot symbols 20-25 with labels
 points((1:5), rep(1, 5), cex = 2, pch = (21:25), col="red", bg="green")
 text((1:5) + 0.4, rep(1, 5), cex = 1, (21:25))
```

Shape can also be a (single) character string.

```{r scatterplot_shape_char, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=humidity, y=viscosity)) + 
  geom_point(shape="$", size=3)
```

The same way works for `size` too.

```{r scatterplot_size, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=humidity, y=viscosity)) + 
  geom_point(size=5)
```

```{r scatterplot_shape_size, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=humidity, y=viscosity)) + 
  geom_point(shape=3, size=1)
```


#### Changing the colour of points

Colour can be set in a similar way than `shape` and `size`: setting `colour` as a `geom_point()` parameters. Both UK and US spellings (`color`) can be used.

```{r scatterplot_colour, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=humidity, y=viscosity)) + 
  geom_point(colour="red")
```

Shapes from 21 to 25 allow two colours. In these cases, `colour` set the outline and `fill` set the internal colour.

```{r scatterplot_fill, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=humidity, y=viscosity)) + 
  geom_point(shape=21, colour="red", fill="#FF0000")
```

When you need to pass a colour to R, you can use a string with the colour name. There are 657 colour names in R; just type `colours()` to view them. Alternatively, you can pass a string with the hexadecimal code (e.g. "#FF0000") or you can use `rgb()`, `hsv()` or `hcl()`  if you are familiar with these colour models.

Data used in these examples has 540 observations but the plot seems have less points. This is because many points overlap. Transparencies are useful in this cases. The `alpha` aesthetic set the transparency level: legal `alpha` values are any numbers from 0 (transparent) to 1 (opaque). 

```{r scatterplot_alpha, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=humidity, y=viscosity)) +
  geom_point(alpha=0.25)
```

Since `alpha=0.25` (and 0.25 is 1/4) a point will be drawn as solid when four points overlap.

<!--
#### Mapping a third variable to scatter plots

Scatter plots were born to visualize the relationship between two variables: one mapped to the x-axis and one mapped to the y-axis. Sometimes, a third variable should be visualized. In these case, you can map a third variable to other aesthetics: size, shape or colour.

Suppose you're interested in the relationship between humidity and viscosity accordingly the presence or absence of `band_type`. To perform this task, you have to map `band_type` to `colour`. 

```{r scatterplot_map_colour, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=humidity, y=viscosity, colour=band_type)) +
  geom_point()
```

Note that mapping occurs within `aes()`, while setting occurs outside of `aes()`.

The plot shows the same points that previous ones with different colours and a legend will be added.

Alternatively, you can map `band_type` to another aesthetic, like `shape`.

```{r scatterplot_map_shape, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=humidity, y=viscosity, shape=band_type)) +
  geom_point()
```

Since different shapes are more difficult to read when you have many points, this solution provide an alternative when you are printing in black and white, without colours. You can improve your result using both aesthetics together.

```{r scatterplot_map_colour_shape, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=humidity, y=viscosity, colour=band_type, shape=band_type)) +
  geom_point()
```

You can map `band_type` to size, but the result advise against this choice. 
```{r scatterplot_map_size, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=humidity, y=viscosity, size=band_type)) +
  geom_point()
```

If you're interested in a continuous variable as third variable you can `map` it to `colour` or to `size`. It makes no sense map a continuous value to `shape`.

```{r scatterplot_map_colour_continuous, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=humidity, y=viscosity, colour=ink_pct)) +
  geom_point()
```

```{r scatterplot_map_size_continuous, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=humidity, y=viscosity, size=ink_pct)) +
  geom_point()
```

It is more difficult perceiving small differences in size and colour, so variable mapped to these aesthetic attributes will be interpreted with a much lower accuracy than those mapped to spatial coordinates (`x` and `y`).

The following code will produce a scatter plot of `humidity` versus `viscosity` with `band_type` mapped to `colour`. 

```{r scatterplot_map_colour_smooth, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=humidity, y=viscosity, colour=band_type)) +
  geom_point() + geom_smooth(method="lm")
```

The scatter plot has two regression lines. This is the expected results, as `band_type` is mapped to `colour` in the `ggplot()` function and its arguments are used not only by `geom_point()` but also by `geom_smooth()`.

To produce a scatter plot with a single regression line the `colour` aesthetic must be mapped only to `geom_point()`.

```{r scatterplot_map_colour_onesmooth, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=humidity, y=viscosity)) +
  geom_point(mapping=aes(colour=band_type)) + geom_smooth(method="lm")
```

Finally, this is the plot if you are interested to three regression line, one for all values and one for each level of `band_type`.

```{r scatterplot_map_colour_threesmooth, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=humidity, y=viscosity)) +
  geom_point(mapping=aes(colour=band_type)) + 
  geom_smooth(mapping=aes(colour=band_type), method="lm") +
  geom_smooth(method="lm")
```


#### Mapping four variables to scatter plots

Although the interpretation may be difficult, different variable can map to different aesthetics at the same time. From a theoretical point of view you can map as many variable as the number of aesthetics, but it is not suggested map more than four variable.

This is the result when you are interested to the ink percentage and band type, at the same time.

```{r scatterplot_map_four_variables, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=humidity, y=viscosity, size=ink_pct, colour=band_type)) +
  geom_point()
```

When a variable is mapped to `size` it is not suggested to map another variable to `shape`. This is because it is difficult to compare the sizes of different shapes.



    It is possible to group points by some variable.  
    If the grouping variable is a categorial variable, it must be mapped to `shape` or `colour`:
    
-->    
<!--
* `shape`  
    The next examples refers to the relationship between `distance`, `air_time` and `origin`:
    ```{r scatterplot2, warning=FALSE}
pl2 <- ggplot(data = sflights, mapping = aes(x = distance, y = air_time, shape = origin))
pl2 + geom_point()
    ```

* `colour`:
    ```{r scatterplot4, warning=FALSE}
pl4 <- ggplot(data = sflights, mapping = aes(distance, air_time, colour = origin))
pl4 + geom_point()
    ```
    
    If the grouping variable is a continuous variable, it must be mapped to `size` or `colour`:

* `size`  
    The next examples refers to the relationship between `distance`, `air_time` and `arr_delay`:
    ```{r scatterplot9, warning=FALSE}
pl6 <- ggplot(data = sflights, mapping = aes(distance, air_time, size = arr_delay))
pl6 + geom_point()
    ``` 
    
    When a variable is mapped to `size` , the results can be perceptually misleading if the dataset is large.
    
* `colour`:
    ```{r scatterplot10, warning=FALSE}
pl7 <- ggplot(data = sflights, mapping = aes(distance, air_time, colour = arr_delay))
pl7 + geom_point()
    ```

    To draw a smoothed line, `geom_smooth` must be added:    
    ```{r geom_point and geom_smooth, warning=FALSE}
pl1 + geom_point(mapping = aes(colour = origin), shape = 20, size = 3) + geom_smooth()
    ```
-->

### Line Graphs

Line Graphs are used to display how one continuous variable, on the y-axis, changes in relation to another continuous variable, on the x-axis. It is similar to a scatter plot, except that points are ordered in the x-axis and connected by a segment. Points can also be missing. 
As a scatter plot is made by points, add `geom_point()` geom to a ggplot object to build a scatterplot.
To build a line plot, add `geom_line()` geom to a ggplot object.  

`ChickWeight` data contains the body weight of 50 chicks over time. Suppose you are interested to the growth of the first chick.

```{r linegraph_first, message=FALSE}
ggplot(data=(ChickWeight %>% filter(Chick==1)), mapping=aes(x=Time, y=weight)) + geom_line()
```

Points can be easily added with `geom_point()`.

```{r linegraph_geompoint, message=FALSE}
ggplot(data=(ChickWeight %>% filter(Chick==1)), mapping=aes(x=Time, y=weight)) + geom_line() + geom_point()
```

You can change the appearance of the plot setting an aesthetic to a value. For example, the following plot has a dark blue line with squared and bigger points.

```{r linegraph_set2, message=FALSE}
ggplot(data=(ChickWeight %>% filter(Chick==1)), mapping=aes(x=Time, y=weight)) +
  geom_line(colour="darkblue") + geom_point(shape=15, size=2)
```

Line Graphs are used to display how one continuous variable, on the y-axis, changes in relation to another continuous variable, on the x-axis. It is similar to a scatter plot, except that points are ordered in the x-axis and connected by a segment. Points can also be missing. 

```{r linegraphs, message=FALSE, echo=FALSE, purl=FALSE}
ds = data.frame(x=0:6, y=c(0,3,7,12,20,30,45.6))

ggp <- ggplot(data=ds, aes(x=x, y=y)) + 
  geom_line(colour="#2B4C6F") +  
  xlab("Explanatory variable\n(x)") + ylab("Response variable\n(y)") +
  theme(axis.text.x = element_blank(), axis.text.y = element_blank())

gridExtra::grid.arrange(ggp+geom_point(colour="#2B4C6F"), ggp, ncol=2)
```

This chapter presents how to build line graphs and introduces other basic concepts of `ggplot2` graphics: `group` aesthetic and manual scales.


# The first line graph

`ChickWeight` data contains the body weight of 50 chicks over time. Suppose you are interested to the growth of the first chick.

```{r we, message=FALSE}
ggplot(data=(ChickWeight %>% filter(Chick==1)), mapping=aes(x=Time, y=weight)) + geom_line()
```

Points can be easily added with `geom_point()`.

```{r linegraph_geompoint2, message=FALSE}
ggplot(data=(ChickWeight %>% filter(Chick==1)), mapping=aes(x=Time, y=weight)) + geom_line() + geom_point()
```

You can change the appearance of the plot setting an aesthetic to a value. For example, the following plot has a dark blue line with squared and bigger points.

```{r linegraph_set, message=FALSE}
ggplot(data=(ChickWeight %>% filter(Chick==1)), mapping=aes(x=Time, y=weight)) +
  geom_line(colour="darkblue") + geom_point(shape=15, size=2)
```

Available aesthetic are `x`, `y`, `alpha`, `colour` and `size` with the same (intuitive) meaning already seen for `geom_point()`.

To choose the style of the line you can use `linetype`. If you are experienced with R basic graphic, `linetype` has the same meaning that `lty`.

```{r linegraph_linetype, message=FALSE}
ggplot(data=(ChickWeight %>% filter(Chick==1)), mapping=aes(x=Time, y=weight)) +
  geom_line(colour="darkblue", linetype=2)
```

The `linetype` can be a number (0-6) or a description (like `"solid"` or `"dashed"`). Available line types are:

```{r plot_linetypes, echo=FALSE, fig=TRUE, purl=FALSE}
par(mar=rep(0,4))
# Make an empty chart
plot(1, 1, xlim = c(0.5, 5.5), ylim=c(0.5, 7.5), type = "n", axes = FALSE, ann = FALSE, frame.plot = TRUE, mar=0)
# Default values
x0 = 0.5 # Text x coordinate
xs = 1.8 # Line start point
xe = 5.2 # Line end point
cex0 = 1 # Default text size (cex)
pos0 = 4 # Default text position (pos): right
lwd0 = 2 # Default line width (lwd)
# Line 0
text(x = x0, y = 7, labels = '0. "blank"', cex = cex0, pos = pos0)
lines(x = c(xs, xe), y = c(7, 7), lty = 0, lwd = lwd0)
# Line 1
text(x = x0, y = 6, labels = '1. "solid"', cex = cex0, pos = pos0)
lines(x = c(xs, xe), y = c(6, 6), lty = 1, lwd = lwd0)
# Line 2
text(x = x0, y = 5, labels = '2. "dashed"', cex = cex0, pos = pos0)
lines(x = c(xs, xe), y = c(5, 5), lty = 2, lwd = lwd0)
# Line 3
text(x = x0, y = 4, labels = '3. "dotted"', cex = cex0, pos = pos0)
lines(x = c(xs, xe), y = c(4, 4), lty = 3, lwd = lwd0)
# Line 4
text(x = x0, y = 3, labels = '4. "dotdash"', cex = cex0, pos = pos0)
lines(x = c(xs, xe), y = c(3, 3), lty = 4, lwd = lwd0)
# Line 5
text(x = x0, y = 2, labels = '5. "longdash"', cex = cex0, pos = pos0)
lines(x = c(xs, xe), y = c(2, 2), lty = 5, lwd = lwd0)
# Line 6
text(x = x0, y = 1, labels = '6. "twodash"', cex = cex0, pos = pos0)
lines(x = c(xs, xe), y = c(1, 1), lty = 6, lwd = lwd0)
```


# Mapping variables to line graphs

If you are interested in the average growth of chicks for the different diets, you must first summarize data.

```{r linegraph_ChickWeightMean, message=FALSE}
ChickWeightMean <- ChickWeight %>% group_by(Time, Diet) %>% summarize(weight=mean(weight))
ChickWeightMean
```

If you draw the same plot as above with new data, you will obtain a figure like this one.

```{r linegraph__sawtooth, message=FALSE}
ggplot(data=ChickWeightMean, mapping=aes(x=Time, y=weight)) +
  geom_line() + geom_point()
```

A jagged line appears when there are multiple data at each `x` and you tell ggplot to connect them. A plot like this one should sounds as a warning that something is wrong. In order to have a single point for each `x` you can summarize your data, or you can draw several lines, accordingly to a third variable, just adding a new aesthetic.

```{r linegraph_aes, message=FALSE}
ggplot(data=ChickWeightMean, mapping=aes(x=Time, y=weight, colour=Diet)) +
  geom_line() + geom_point()
```

Sometimes, the `x` variable can be a categorical variable. This is the case when you have numerical values that are conceived as categorical ones. The `ToothGrowth` data set can be a good case in point. Data can be summarized as follow:

```{r linegraph_tg, message=FALSE}
tg <- ToothGrowth %>% group_by(supp, dose) %>% summarize(length=mean(len))
tg
```

You can plot a line for each `supp` value:

```{r linegraph_numericx, message=FALSE}
ggplot(data=tg, mapping=aes(x=dose, y=length, colour=supp)) +
  geom_line() + geom_point()
```

The plot is good but since `dose` level are fixed the space between 0.5-1.0 and 1.0-2.0 should be the same. You can fix this issue, transforming `dose` into a factor.

```{r linegraph_factorx, message=FALSE}
ggplot(data=tg, mapping=aes(x=factor(dose), y=length, colour=supp, group=supp)) +
  geom_line() + geom_point()
```

Notice the use of `group=supp`. This is required to tell ggplot how to group data when it draws the lines. As [Hadley himself said](https://groups.google.com/forum/#!topic/ggplot2/Pwq6hO7r90w):

> The important thing [for a line graph with a factor on the horizontal axis] is to manually specify the grouping. By default `ggplot2` uses the combination of all categorical variables in the plot to group geoms - that doesn't work for this plot because you get an individual line for each point. Manually specify `group = 1` indicates you want a single line connecting all the points.

```{r linegraph_group1, message=FALSE}
ggplot(data=(tg%>%filter(supp=="OJ")), mapping=aes(x=factor(dose), y=length, group=1)) +
  geom_line() + geom_point()
```

When points overlap, you can _dodge_ them. Dodging adjusts points left and right and must be applied to both lines and points, to avoid misalignment.

```{r linegraph_dodge, message=FALSE}
ggplot(data=tg, mapping=aes(x=factor(dose), y=length, colour=supp, group=supp)) +
  geom_line(position=position_dodge(0.15)) + geom_point(position=position_dodge(0.15))
```


# Changing the Appearance of Mapped Aesthetics

When you feed your chicks, you use the "A" fodder for diet 1, the "B" fodder for diet 2, the "C" for diet 3 and the "D" for diet 4. 

```{r linegraph_labels, message=FALSE}
ChickWeightMean <- ChickWeightMean %>% mutate(Diet = factor(Diet, levels=1:4, labels=c("A","B","C","D")))
```

"A" fodder is sold in red bags and farmers immediately identify this product with the red colour. In the same way, B is associated with the blue, C with the green and D with the orange. To improve the readability of the plot, lines for each diet should be of the colour that identify the fodder maker.

You cannot set the colour inside `ggplot()` or `geom_line()` using the `colour` argument, because this is admitted only when a variable is not _mapped_ to the `colour` aesthetic. You can set manually the colour with the function `scale_colour_manual()`.

```{r linegraph_setcolourmanual, message=FALSE}
ggplot(data=ChickWeightMean, mapping=aes(x=Time, y=weight, colour=Diet)) +
  geom_line() + geom_point() + scale_color_manual(values=c("red", "blue", "green", "orange"))
```

Colours in the `values` string vector must appear in the same order as they appear in the legend. You can pass a named vector to be sure of the correspondence between colour and data.

```{r linegraph_setcolourmanual_order, message=FALSE}
ggplot(data=ChickWeightMean, mapping=aes(x=Time, y=weight, colour=Diet)) +
  geom_line() + geom_point() + 
  scale_color_manual(values=c("D"="orange", "B"="blue", "A"="red", "C"="green"))
```

There are as many `scale_*_manual` function as aesthetics for which values can be set manually.

```{r linegraph_setshape_order, message=FALSE}
ggplot(data=ChickWeightMean, mapping=aes(x=Time, y=weight, colour=Diet)) +
  geom_line(mapping=aes(linetype=Diet)) + geom_point(mapping=aes(shape=Diet)) + 
  scale_color_manual(values=c("D"="orange", "B"="blue", "A"="red", "C"="green")) +
  scale_shape_manual(values=c(16,18,20,22)) + 
  scale_linetype_manual(values=c(1,3,5,6))
```


#### Adding horizontal and vertical lines

Line graphs often contains horizontal or vertical lines.

It may be interesting to analyse the average daily growth for each diet type.

```{r linegraph_ChickWeightGrowthMean, message=FALSE}
ChickWeightGrowth <- ChickWeight %>% group_by(Chick) %>%
  mutate(growth=c(0,diff(weight))) %>% filter(growth != 0)
  
ChickWeightGrowthMean <- ChickWeightGrowth %>% group_by(Time, Diet) %>%
  summarize(growth=mean(growth)) 

ggp <- ggplot(data=ChickWeightGrowthMean, mapping=aes(x=Time, y=growth, colour=Diet)) +
  geom_line(mapping=aes(linetype=Diet)) + geom_point(mapping=aes(shape=Diet))

ggp
```

At this point you may want to add the average growth to the plot.

```{r linegraph_hline, message=FALSE}
growth_avg <- ChickWeightGrowth %>% magrittr::use_series(growth) %>% mean
ggp1 <- ggp + geom_hline(yintercept = growth_avg, colour="grey20")
ggp1
```

Data refers to a three-weeks period. It may be interesting to highlight each week adding a vertical line at days 7, 14 and 21.

```{r linegraph_vline, message=FALSE}
ggp1 + geom_vline(xintercept = c(7,14,21), colour="grey40", linetype=3)
```



### Bar plot 

Bar Graphs are used to display numeric values for different categories. Although they appears similar to Histograms, these plots are very different: bar plot are used for categorical x values, bars should be spaced and the weight of the bar has no meaning while histograms are used for continuous y values, bars (that are called _bins_) must not be spaced and the weight of bins depends on data.

To build a bar plot, add `geom_bar()` geom to a ggplot object.  
As seen in the previous chapter, chicks receive one of four diets (see `ChickWeight` data set). A graphical summary about how chicks receive each diet can be obtained.

```{r bargraph_first2, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) + geom_bar()
```

If you prefer horizontal bars, just flip the plot with `coord_flip()`.

```{r bargraph_coordflip2, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) + geom_bar() + coord_flip()
```

Another way to distinguish bar graphs and histograms are tiny bars, to increase the space among bars.

```{r bargraph_width2, message=FALSE}
pl <- ggplot(data=ChickWeight, mapping=aes(x=Diet)) + geom_bar(width=0.5)
pl
```

To change the colour of the bar graph, `fill` and `colour` parameter must be specified; `fill` refers to the colour of bars and `colour` to the border of bars. `width` refers to the bar width: larger values make the bars wider, and smaller values make the bars narrower (default value is 0.9): 
    ```{r geom_bar options, warning=FALSE}
pl + geom_bar(fill = "lightblue", colour = "black", width = 0.5)
    ```

To avoid confusion between bar graphs and histograms, some authors suggest to build bars horizontally.

```{r bargraphs, message=FALSE, echo=FALSE, purl=FALSE}
ds = data.frame(x=factor(1:4), y=c(4,2,6,5))

ggp <- ggplot(data=ds, aes(x=x, y=y)) +
  geom_bar(stat="identity", fill=c("#74a9cf", "#3690c0", "#0570b0", "#034e7b")) + 
  theme(axis.text.x = element_blank(), axis.text.y = element_blank())

ggp1 <- ggp +
  xlab("Discrete variable\n(x)") + ylab("Frequencies\n(y)")

ggp2 <- ggp +
  xlab("Discrete variable\n(y)") + ylab("Frequencies\n(x)") +
  coord_flip()

gridExtra::grid.arrange(ggp1, ggp2, ncol=2)
```

This chapter presents how to build bar graphs and introduces other basic concepts of `ggplot2` graphics: `stat`.


# The first bar graph

As seen in the previous chapter, chicks receive one of four diets (see `ChickWeight` data set). A graphical summary about how chicks receive each diet can be obtained.

```{r bargraph_first, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) + geom_bar()
```

If you prefer horizontal bars, just flip the plot with `coord_flip()`.

```{r bargraph_coordflip, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) + geom_bar() + coord_flip()
```

Another way to distinguish bar graphs and histograms are tiny bars, to increase the space among bars.

```{r bargraph_width, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) + geom_bar(width=0.5)
```

# Setting and mapping variables to line graphs

Colours and other available aesthetics (`linetype` and `size`) can be set or mapped as usual. Remember that `colour` controls the bar outline, while `fill` controls the bar colour.

```{r bargraph_setcolour, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) +
  geom_bar(fill=c("#74a9cf", "#3690c0", "#0570b0", "#034e7b"))
```

```{r bargraph_scalefill, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) +
  geom_bar(mapping=aes(fill=Diet)) +
  scale_fill_manual(values=c("#74a9cf", "#3690c0", "#0570b0", "#034e7b"))
```

These plots are identical except that for legend, but they are based on two different approaches. In the first plot, fill colours are set. If you do not set four different fill colours, all bars have the same colours as shown above. In the second plot, fill colours are mapped to the level of `Diet`. Since each bar represents a different type of diet, each bar has a different colour also when you do not set manually fill colours with `scale_fill_manual()`.

```{r bargraph_mapping, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) +
  geom_bar(mapping=aes(fill=Diet))
```

The use of `scale_fill_manual()` allows you to choose which colours should be used. Since fill colours are mapped with a variable, in this case the legend will be shown. In this case the legend is useless, because the same aesthetic is mapped to `x` and you already know which Diet refer to each colour. You can hide the legend in `scale_fill_manual()`.

```{r bargraph_nolegend_scale, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) +
  geom_bar(mapping=aes(fill=Diet)) +
  scale_fill_manual(values=c("#74a9cf", "#3690c0", "#0570b0", "#034e7b"), guide=FALSE)
```

Alternatively, you can use the `guides` function to hide the legend, just setting to `FALSE` the related aesthetic, in this case `fill`.

```{r bargraph_nolegend_guides, message=FALSE}
ggplot(data=ChickWeight, mapping=aes(x=Diet)) +
  geom_bar(mapping=aes(fill=Diet)) +
  scale_fill_manual(values=c("#74a9cf", "#3690c0", "#0570b0", "#034e7b")) +
  guides(fill=FALSE)
```

`ggplot2` provides some functions (e.g. `scale_*_brewer` or `scale_*_gradient`) to choose a palette (i.e. a set of coherent colours), but these functions are not shown in this chapter. You can still use `scale_*_manual` functions and refer to some on-line tool like [Color Brewer](http://colorbrewer2.org/) or [Paletton](http://paletton.com/) for a better choice of colours.


# Summarized data and `stat`s

Sometimes data comes already summarized. As an example, you can have the following frequency tables without the original data.

```{r bargraph_ChickWeightFreq, message=FALSE}
ChickWeightFreq <- ChickWeight %>% group_by(Diet) %>% summarize(n=n())
ChickWeightFreq
```

You can try to build the previous plot in the same way.

```{r bargraph_error, message=FALSE}
ggplot(data=ChickWeightFreq, mapping=aes(x=Diet)) + geom_bar()
```

The result is a plot with four bars of length 1. Why? The reason is quite simple. By default, `geom_bar()` scans the `Diet` column counting how many observations have Diet=1, how many have Diet=2 and so on. In this case, you must tell `ggplot` you already have the count.

```{r bargraph_identity, message=FALSE}
ggplot(data=ChickWeightFreq, mapping=aes(x=Diet, y=n)) + geom_bar(stat="identity")
```

Since you have an `y` variable containing frequencies, you tell `ggplot` the variable containing counts (`y=n` in the example) and to `geom_bar` that `stat="identity"` must be used. 

A statistical transformation, or `stat`, transforms the data, typically by summarizing it in some manner. By default, almost all `geom`s seen until now uses `stat="identity"`, that do not transform data. As just seen, by default `geom_bar()` uses `stat="count"` that counts the number of cases at each `x` position. If you do not want to transform your data, `stat="identity"` must be supplied.


# Stacked and grouped bar graphs

If you are a quality engineer analysing the `bands` data, you may be interested to the number of presses for each type, distinguishing them by the cylinder size.

```{r bargraph_stack, message=FALSE}
ggplot(data=bands, mapping=aes(x=press_type, fill=cylinder_size)) + geom_bar()
```

Mapping `fill` to `cylinder_size` does the job. Notice a small gray area at the top of the last two bars: this means there are few cases in which `cylinder_size` is missing. 

Sometimes you may be interested at the distribution of `cylinder_size` for each `press_type`.

```{r bargraph_fill, message=FALSE}
ggplot(data=bands, mapping=aes(x=press_type, fill=cylinder_size)) + geom_bar(position="fill")
```

In the case you prefer a bar for each combination of `press_type` and `cylinder_size`, you can `dodge` the bars.

```{r bargraph_dodge, message=FALSE}
ggplot(data=bands, mapping=aes(x=press_type, fill=cylinder_size)) + geom_bar(position="dodge")
```

Notice that `position="dodge"` is a short key for `position=position_dodge()` with its default value and you can modify this value to add space between bars. In the case you want to add space between bars, you probably want also to modify the `width` in order to add spaces among each group of bars.

```{r bargraph_manualdodge, message=FALSE}
ggplot(data=bands, mapping=aes(x=press_type, fill=cylinder_size)) +
  geom_bar(position=position_dodge(0.85), width=0.6)
```

The `width` in `geom_bar()` determines the width of the bar; the `width` in `position_dodge()` determines the position of each bar. Probably you can easily understand their behaviour after you play with them for a while.

All data related to `MOTTER70` press has `CATALOG` as `cylinder_size`. In this case, the bars related to other `cylinder_size` are missing and the `MOTTER70` bar will expand to fill the whole space.

To avoid this behaviour you must have at least a `NA` value for each combination of factors. Since both `ggplot2` when you plot and `dplyr` when you build a frequency table, do not show the count for missing combinations, you should manually build a frequency table like the following one.

```{r bargraph_bands_freq_na, message=FALSE}
bands_freq_na <- bands %>% group_by(press_type, cylinder_size) %>% summarise(n = n()) %>%
  right_join(
    expand.grid(
      press_type = bands %>% magrittr::use_series(press_type) %>% levels,
      cylinder_size = c(bands %>% magrittr::use_series(cylinder_size) %>% levels, NA)
    )
  )
bands_freq_na
```

At this point, you can easily build the plot starting from frequency table. Just remember to map the counts to `y` and to add `stat="identity"` to `geom_bar()`.

```{r bargraph_stack_na, message=FALSE}
ggplot(data=bands_freq_na, mapping=aes(x=press_type, y=n, fill=cylinder_size)) +
  geom_bar(stat="identity", position="dodge")
```


# Adding text to plots

Plots are useful to catch the eye of your audience but sometimes they cannot replace numbers or text. Adding text to a plot can help you to integrate information in your plot.

```{r bargraph_geomtext, message=FALSE}
bands_freq <- bands %>% group_by(press_type) %>% summarize(n=n())
  
ggplot(data=bands, mapping=aes(x=press_type)) +
  geom_bar() +
  geom_text(data=bands_freq, mapping=aes(y=n, label=n), vjust=1.5, colour="white")
```

`geom_text()` works as any other `geom` seen until now. It requires `x` and `y` coordinates; in this case, `x` is `press_type` and it is inherited from `ggplot()`, while `y` should be passed. Since `bands` data do not contains the count, that is computed by `stat_count` inside `geom_bar()`, default data are overwritten in `geom_text()` in order to use frequencies. `geom_text()` requires `label` that is the text to be written. Outside `aes()`, `vjust` move down (or up) the text and `colour` set text colour.




### Histogram

Histograms are used to summarize a continuous variable into classes, called _bins_. The area (and not the height) of each bin is proportional to the frequency of cases in the bin. The vertical axis is not frequency but density. When bins are equal size, a rectangle is erected over the bin with height proportional to the frequency. As the adjacent bins leave no gaps, the rectangles of a histogram touch each other to indicate that the original variable is continuous.

```{r histograms, message=FALSE, warning=FALSE, echo=FALSE, purl=FALSE}
ggp <- ggplot(data=bands, aes(x=ink_pct)) + 
  xlab("Continuous variable\n(x)") +
  theme(axis.text.x = element_blank(), axis.text.y = element_blank())

ggp1 <- ggp + geom_histogram(fill="#2B4C6F") + ylab("Frequency\n(y)")

ggp2 <- ggp + geom_histogram(fill="#2B4C6F", colour="#3690c0", bins = 8) + ylab("Density\n(y)")

gridExtra::grid.arrange(ggp1, ggp2, ncol=2)
```

This chapter presents how to build histograms and introduces a basic concepts of `ggplot2` graphics: faceting. 


#### The first histogram

As a quality engineer, you are interested to the distribution of ink percentage in `bands` data.

```{r histogram_first, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) + geom_histogram()
```

As usual,  aesthetics can be set to modify the appearance of plot.

```{r histogram_aes, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) + geom_histogram(fill="#2B4C6F", colour="#3690c0")
```

By default, the data is grouped into 30 bins. You can modify the number of bins:

 - setting the number of bins:
    ```{r histogram_bins, message=FALSE, warning=FALSE}
    ggplot(data=bands, mapping=aes(x=ink_pct)) + geom_histogram(fill="#2B4C6F", colour="#3690c0", bins=6)
    ```
    
 - setting the width of each bin:
    ```{r histogram_binwidth, message=FALSE, warning=FALSE}
    ggplot(data=bands, mapping=aes(x=ink_pct)) + geom_histogram(fill="#2B4C6F", colour="#3690c0", binwidth=7)
    ```  
    
#### Mapping variables to histograms and faceting

May be interesting analysing the distribution of ink percentage for each level of `proof_on_ctd_ink`. 

```{r histogram_mapping, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) +
  geom_histogram(mapping=aes(fill=proof_on_ctd_ink))
```

Mapping the grouping variable to `fill`, two overlapped distributions are shown. In some cases, as shown above, this solution may work. In other cases, the result may be very difficult to be understood.

```{r histogram_mapping_hide, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) +
  geom_histogram(mapping=aes(fill=press_type))
```

In this cases, four different histograms may produce a more readable result.

```{r histogram_facetgrid_col, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) +
  geom_histogram(fill="#2B4C6F") +
  facet_grid(. ~ press_type)
```

`facet_grid()` produces a different panel for each level of `press_type`. It requires a formula style: `rows ~ columns`. The dot in the formula is used to indicate there should be no faceting on this dimension (either row or column). The following example shows faceting on rows.

```{r histogram_facetgrid_row, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) +
  geom_histogram(fill="#2B4C6F") +
  facet_grid(type_on_cylinder ~ .)
```

Faceting on both dimensions:

```{r histogram_facetgrid_row_col, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) +
  geom_histogram(fill="#2B4C6F") +
  facet_grid(type_on_cylinder ~ press_type)
```

When you have a categorical variable with many levels, it does not make sense to try and display them all in one row (or one column) and you may want to wrap it. `facet_wrap(~ variable)` wraps a sequence of panels into rows and columns, to better fit screen.

```{r histogram_facetwrap, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) +
  geom_histogram(fill="#2B4C6F") +
  facet_wrap(~ press_type)
```

Mapping `fill` to the faceting variable (`press_type`) returns a different coloured histogram for each panel.

```{r histogram_facetwrap_fill, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct)) +
  geom_histogram(mapping=aes(fill=press_type)) +
  guides(fill=FALSE) +
  facet_wrap(~ press_type)
```


#### Making a density histogram

To show densities instead than count (frequencies) on the y axis, the special word `..density..` must be used.

```{r histogram_density, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct, y=..density..)) +
  geom_histogram(fill="#74a9cf")
```

A density curve can be added.

```{r histogram_geomdensity, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct, y=..density..)) +
  geom_histogram(fill="#74a9cf") + geom_density(colour="#034e7b")
```

The `geom_density()` function draws a closed polygon. If you do not like the lines along the side and bottom, you can draw a density curve using `geom_line` with `stat="density"`.

```{r histogram_geomline_density, message=FALSE, warning=FALSE}
ggplot(data=bands, mapping=aes(x=ink_pct, y=..density..)) +
  geom_histogram(fill="#74a9cf") + geom_line(stat="density", colour="#034e7b")
```

### Box Plot
A Box-and-Whiskers Plot, or Box Plot, is a convenient way to draw data distribution. The box ranges from the first quartile to the third (inter-quartile range or IQR) with a line indicating the median (second quartile). The whiskers contains the lowest datum still within 1.5 IQR of the lower quartile, and the highest datum still within 1.5 IQR of the upper quartile. If there are data outside the range of whiskers, they are represented by a dot. Box Plots are very popular among data analyst, but they are not suggested for a wider audience. Box plots can be drawn either horizontally or vertically.

```{r boxplots, message=FALSE, warning=FALSE, echo=FALSE, purl=FALSE}
ggp <- ggplot(data=bands, aes(x=press_type, y=ink_pct)) + 
  geom_boxplot(fill="#3690c0") +
  ylab("Continuos variable") + xlab("Grouping variable") + 
  theme(
    axis.text.x = element_blank(), axis.text.y = element_blank()
  )

ggp1 <- ggp + theme(axis.ticks.x = element_blank())
  
ggp2 <- ggp + theme(axis.ticks.y = element_blank()) + coord_flip()

gridExtra::grid.arrange(ggp1, ggp2, ncol=2)
```

This chapter presents how to build box plots and show how to customize: main titles, axes labels and legend titles.


#### The first box plot

Supposing you are interested in the differences of ink percentage accordingly to the type of press, you can build four box plots to compare distributions.

```{r boxplot_first, message=FALSE, warning=FALSE}
ggplot(data=bands, aes(x=press_type, y=ink_pct)) + 
  geom_boxplot(fill="#3690c0")
```

Appearance aesthetics work as seen until now; `fill` controls the box filling, while `colour` controls the box outline, whiskers and outline points. 

```{r boxplot_colour, message=FALSE, warning=FALSE}
ggplot(data=bands, aes(x=press_type, y=ink_pct)) + 
  geom_boxplot(fill="#74a9cf", colour="#034e7b")
```

There are also a few `outline.*` parameter to set aesthetics for outlier points.

```{r boxplot_outlines, message=FALSE, warning=FALSE}
ggplot(data=bands, aes(x=press_type, y=ink_pct)) + 
  geom_boxplot(fill="#74a9cf", colour="#034e7b", outlier.colour="red", outlier.shape=18, outlier.size=3)
```


#### Making a single box plot

Surprisingly, it is more complicated to draw a single box plot. This is because `geom_boxplot()` requires an `x` value that is used as grouping variable. You have to set a single value for `x` when you do not have a grouping variable.

```{r boxplot_group0, message=FALSE, warning=FALSE}
ggplot(data=bands, aes(x="0", y=ink_pct)) + 
  geom_boxplot(fill="#74a9cf", colour="#034e7b")
```

It does the job, however you have to remove the x-axis tick marker and label in order to have a nice result.

```{r boxplot_xlab, message=FALSE, warning=FALSE}
ggplot(data=bands, aes(x="0", y=ink_pct)) + 
  geom_boxplot(fill="#74a9cf", colour="#034e7b") +
  xlab("") +
  theme(axis.ticks.x = element_blank(), axis.text.x = element_blank())
```


#### Customizing Titles and Axis

The last example reveals how to change the x-axis title. This is useful when the name of the variable is not enough clear. An analogous function `ylab()` set the y-axis title, while `ggtitle()` should be used when you want a title for the whole plot. Note the use of the escape code `\n` to break lines.

```{r boxplot_ylab, message=FALSE, warning=FALSE}
ggplot(data=bands, aes(x=press_type, y=ink_pct)) + 
  geom_boxplot(fill="#74a9cf", colour="#034e7b") +
  xlab("Press type") + ylab ("Ink %") + ggtitle("Distribution\n(bands data set)")
```

You already saw a "preview" of the `theme()` function, that set many theme settings. Here only a few options regarding axis and titles are shown:

 - `axis.ticks.x` (or `axis.ticks.y`) controls the ticks of x-axis (or y-axis). `axis.ticks` performs the same action to both axis. You can suppress ticks with `element_blank()` or use `element_line()` to change the aspect of ticks setting `colour`, `size` or `linetype`.
 
    ```{r boxplot_axis_ticks, message=FALSE, warning=FALSE}
    ggplot(data=bands, aes(x="0", y=ink_pct)) + 
      geom_boxplot(fill="#74a9cf", colour="#034e7b") +
      xlab("Press type") + ylab ("Ink %") + ggtitle("Distribution\n(bands data set)") +
      theme(axis.ticks.x = element_line(colour="green", size=4), axis.ticks.y=element_line(colour="red"))
    ```

 - `axis.text.x`, `axis.text.y` and `axis.text` controls the text of x, y or both axis ticks. You can suppress text with `element_blank()` or use `element_text()` to change the aspect of ticks setting font `family`, font `face`, `colour`, `size`, `angle` and other options.
 
    ```{r boxplot_axis_text, message=FALSE, warning=FALSE}
    ggplot(data=bands, aes(x=press_type, y=ink_pct)) + 
      geom_boxplot(fill="#74a9cf", colour="#034e7b") +
      xlab("Press type") + ylab ("Ink %") + ggtitle("Distribution\n(bands data set)") +
      theme(axis.text = element_text(face="bold", colour="#034e7b"))
    ```
    
 - `axis.text.x`, `axis.text.y` and `axis.text` controls the title of x, y or both axes. You can suppress text with `element_blank()` or use `element_text()` to change the aspect of axis text.
 
    ```{r boxplot_axis_title, message=FALSE, warning=FALSE}
    ggplot(data=bands, aes(x=press_type, y=ink_pct)) + 
      geom_boxplot(fill="#74a9cf", colour="#034e7b") +
      xlab("Press type") + ylab ("Ink %") + ggtitle("Distribution\n(bands data set)") +
      theme(axis.title = element_text(face="italic", colour="#034e7b"))
    ```
    
 - `plot.title` controls the text of the overall plot. You can use `element_text()` to change the aspect of title.
 
    ```{r boxplot_plot_title, message=FALSE, warning=FALSE}
    ggplot(data=bands, aes(x=press_type, y=ink_pct)) + 
      geom_boxplot(fill="#74a9cf", colour="#034e7b") +
      xlab("Press type") + ylab ("Ink %") + ggtitle("Distribution\n(bands data set)") +
      theme(plot.title = element_text(face="bold", size=18))
    ```
    


* `geom_boxplot()` and `geom_jitter()`  
    The following example shows the command to build the boxplot that represent the speed for each `carrier` category:
    ```{r geom_boxplot, warning=FALSE}
pl3 <- ggplot(data = sflights, mapping = aes(x = carrier, y = distance/air_time))
pl3 + geom_boxplot()
    ```
    
    It is possible to change: the width of the boxes with `width` option, the size and shape of the outlier points with `outlier.size` and `outlier.shape` options (the default size is 2 and the default shape is 16):
    ```{r geom_boxplot options, warning=FALSE}
pl3 + geom_boxplot(outlier.size = 1.5, outlier.shape = 21, widht = .5)
    ```

    To add the points to the boxplot, `geom_jitter` function must be added:
    ```{r geom_boxplot and geom_jitter, warning=FALSE}
pl3 + geom_boxplot(outlier.size = 1.5, outlier.shape = 21, widht = .5) + geom_jitter()
    ```

* `geom_histogram()` and `geom_density()`  
    The following example shows the command to build the histogram that represent the speeds of flight: 
    ```{r geom_histogram, warning=FALSE}
pl4 <- ggplot(data = sflights, mapping = aes(x = distance/air_time))
pl4 + geom_histogram()
    ```


<!--
    To change the size of the bins `binwidth` option could be used (by default, the data is gruped into 30 bins) and `origin` parameter lets to choose the starting values for x axis:
    ```{r geom_histogram options, warning=FALSE}
#pl4 + geom_histogram(binwidth = 0.5, fill = "lightblue", colour = "blue", origin = 2.5)
    ```
    
    To add a density curve to the histogram, `y=..density..` must be mapped, so that the histogram is scaled down to the height of the density curves, and `geom_density()` must be specified: 
    ```{r geom_histogram and geom_density, warning=FALSE}
#pl4b <- ggplot(data = sflights, mapping = aes(x = distance/air_time, y=..density..))
#pl4b + geom_histogram(bindwidht = 1, fill = "lightblue", colour = "blue", origin = 2.5) +
#       geom_density(colour = "blue", size = 1.5)
    ```
    In particular, `..density..` refers to a transformation of the original data.

-->

### Stat

A statistical transformation, or `stat`, transforms the data, typically by summarising it in some manner. A `stat` must be location-scale invariant:  
$f(x + a) = f(x) + a$ and $f(b  x) = b  f(x)$.  
This ensures that the transformation stays the same when the scales of the plot is changed.    
A `stat` takes a dataset as input and returns a dataset as output, and so a `stat` can add new variables to the original dataset. It is possible to map aesthetics to these new variables but the names of generated variables must be surrounded with `..` when used.

This table lists all of the stats available in `ggplot2`:

Name        | Description
----------- | -------------
bin         | Bin data
boxplot     | Calculate components of box-and-whisker plot
contour     | Contours of 3d data
density     | Density estimation, 1d
density 2d  | Density estimation, 2d
function    | Superimpose a function
identity    | Dont transform data
qq          | Calculation for quantile-quantile plot
quantile    | Continuous quantiles
smooth      | Add a smoother
spoke       | Convert angle and radius to xend and yend
step        | Create stair steps
sum         | Sum unique values. Useful for overplotting on scatter-plots
summary     | Summarise y values at every unique x
unique      | Remove duplicates

Examples:

* `stat_bin()`  
    The following example shows the command to draw the frequency of `air_time`, changing binwidth values: 
    ```{r stat_bin, warning=FALSE}
pl5 <- ggplot(data = sflights, mapping = aes(x = air_time))
pl5 + stat_bin(binwidth = 2) 
pl5 + stat_bin(binwidth = 40)
    ```

* `stat_bin2d()`  
        The following example shows the command to draw the frequency of the relationship between `air_time` and `distance`, changing binwidth values:
    ```{r stat_bin2d, warning=FALSE}
pl6 <- ggplot(data = sflights, mapping = aes(x = distance, y = air_time))
pl6 + stat_bin2d(bins = 40)
pl6 + stat_bin2d(bins = 20)
    ```

* `stat_function()`  
    The following example shows the command to draw the density of a normal distribution:
    ```{r stat_function, warning=FALSE}
pl7 <- ggplot(data = data.frame(x=c(-3,3)), mapping = aes(x=x))
pl7 + stat_function(fun = dnorm)
    ```

* `stat_quantile()`  
    The following example shows the command to draw the quantiles of the relationship between `air_time` and `distance`(by default the quantiles drawn are: 0.25, 0.50, 0.75):
    ```{r stat_quantile, warning=FALSE}
pl8 <- ggplot(data = sflights, mapping = aes(x = distance, y = air_time))
pl8 + geom_point() + stat_quantile()
    ```

* `stat_qq()`  
    The following example shows the command to draw quantile-quantile plot of `air_time`:
    ```{r stat_qq, warning=FALSE}
pl9 <- ggplot(data = sflights, mapping = aes(sample = air_time)) 
pl9 + stat_qq()
    ```     
    
 * `stat_smooth()`  
    The following example shows the command to add a smoothed line that show the relationship between `arr_delay` and `deep_delay`:  
    ```{r stat_smooth, warning=FALSE}
pl10 <- ggplot(data = sflights, mapping = aes(x = arr_delay, y = dep_delay))
pl10  + geom_point() + stat_smooth()
    ``` 

* `stat_sum()`  
    The following example shows the command to show the frequency of flights by `carrier` that leave from each `origin`:  
    ```{r stat_sum, warning=FALSE}
pl11 <- ggplot(data = sflights, mapping = aes(x = origin, y = carrier))
pl11 + stat_sum(mapping = aes(group = origin, color=origin)) + scale_size(range = c(3, 10))
    ```

* `stat_summary()`  
    The following example shows the command to draw the mean of speed by `carrier`:  
    ```{r stat_summary, warning=FALSE}
pl12 <- ggplot(data = sflights, mapping = aes(x = carrier, y = distance/air_time))
pl12 + geom_boxplot(outlier.size = 1.5, outlier.shape = 21, widht = .5) +
       stat_summary(fun.y = "mean", geom = "point", shape = 23, size = 3, fill = "blue")
    ```

#### Position adjustments
Position adjustments apply minor tweaks to the position of elements within a layer. Position adjustments are normally used with discrete data. Continuous data typically doesnt overlap exactly, and when it does (because of high data density) minor adjustments, like jittering, are usually insufficient to fix the problem.

The next table lists all of the position adjustments available within `ggplot2`:

Adjustment  | Description
----------- | -------------
dodge       | Adjust position by dodging overlaps to the side
fill        | Stack overlapping objects and standardise have equal height
identity    | Dont adjust position
jitter      | Jitter points to avoid overplotting
stack       | Stack overlapping objects on top of one another


Examples:

* `position="jitter"`  
    The following example shows the command to draw `dep_delay` by `origin`: 
    ```{r position_jitter, warning=FALSE}
pl13 <- ggplot(data = sflights, mapping = aes(x = origin, y = dep_delay, colour = origin))
pl13 + geom_point() # default position (overlapping points)
pl13 + geom_point(position = "jitter") # nonoverlapping points
    ```

* `position="dodge"`  
     The following example shows the command to draw the mean distances by `carrier` and `origin`:
    ```{r position_dodge, warning=FALSE}
sfl <- sflights %>% group_by(carrier, origin) %>% summarize(md = mean(distance))
pl3 <- ggplot(data = sfl, mapping = aes(x = carrier, y = md, fill = origin))
pl3 + geom_bar(stat = "identity", position = "dodge") 
    ```
   
    In this case `stat=identity` means that the heights of the bars represent values in `y` mapped (`md`).
    
* `position="fill"`  
        The following example shows the command to draw a proportional relationship between `carrier` and `origin`: 
    ```{r position_fill, warning=FALSE}
pl15 <- ggplot(data = sflights, mapping = aes(x = factor(carrier), fill = factor(origin)))
pl15 + geom_bar(position = "fill")
    ```

## Faceting
Faceting generates small multiples each showing a different subset of the data. Small multiples are a powerful tool for exploratory data analysis: It is possible to rapidly compare patterns in different parts of the data and see whether they are the same or different.

There are two types of faceting provided by ggplot2: `facet_grid` and `facet_wrap`.  

* `Facet grid` produces a 2d grid of panels defined by variables which form the rows and columns: 
 
     * `. ~ carrier`: a single row with multiple columns. 
    ```{r facet_grid, warning=FALSE}
pl16 <- ggplot(data = sflights, mapping = aes(x = distance/air_time))
pl16 + geom_histogram(binwidth = 0.1, xlim = c(2, 9)) + facet_grid(. ~ origin)
    ```
 
     * `carrier ~ .`: a single column with multiple rows. 
    ```{r facet_grid1, warning=FALSE}
pl16 + geom_histogram(binwidth = 0.1, xlim = c(2, 9)) + facet_grid(origin ~ .)
    ```

     * `carrier ~ origin`: Multiple rows and columns
    ```{r facet_grid2, warning=FALSE}
pl16 + geom_histogram(binwidth = 0.1, xlim = c(2, 9)) + facet_grid(carrier ~ origin)
    ```  

* `facet wrap` produces a 1d ribbon of panels that is wrapped into 2d.
The specification of faceting variables is of the form `~ carrier + origin`.

    ```{r facet_wrap, warning=FALSE}
pl16 <- ggplot(data = sflights, mapping = aes(x = distance/air_time))
pl16 + geom_histogram(binwidth = 0.1, xlim = c(2, 9)) + facet_wrap( ~ carrier)
    ``` 

    It is also possible to specify the number of rows or columns to obtein with options: `nrow=` and `ncol=`. 
    ```{r facet_wrap1, warning=FALSE}
pl16 <- ggplot(data = sflights, mapping = aes(x = distance/air_time))
pl16 + geom_histogram(binwidth = 0.1, xlim = c(2, 9)) + facet_wrap( ~ carrier, nrow=2)
    ``` 

    ```{r facet_wrap3, warning=FALSE}
pl16 + geom_histogram(binwidth = 0.1, xlim = c(2, 9)) + facet_wrap( ~ carrier + origin)
    ``` 



