---
title: "Writing R functions"
output: html_document
---

## Function Object

Functions are one of the most important objects in R.

A function is characterised by an input and an output. The input of the function, i.e. the set of the arguments, can be either null or made of one or more R objects. The output of the function can be either null or a single R object. If the function has to return more than one object, the objects are to be inserted in a list.

The function `ls()` doesn't require any input and returns an output.

```{r, argument1}
ls()
```

The function `rm()` requires an input and doesn't return an output.

```{r, argument2}
foo <- 3
rm(foo)
```

Usually, functions require an input and returns an output.

```{r, argument3}
sum(1:10)
```

The several elements of the input of a function are the arguments of the function. When a function is called the arguments can be declared explicitely or implicitely. The arguments can be explicitely with their name.

```{r, argument4}
sum(c(1, 2, NA), na.rm = TRUE)
```
In the above example, the `na.rm` argument of the `sum()` function is called explicitely.

When arguments are called implicitely, the order of the arguments is fundamental. The third example of the code below returns a wrong result.

```{r, argument5}
rdata <- c(rnorm(100), NA)
quantile(x = rdata, probs = c(0.25, 0.50, 0.75), na.rm = TRUE)
quantile(rdata, c(0.25, 0.50, 0.75), TRUE)
quantile(rdata, TRUE, c(0.25, 0.50, 0.75))
# When arguments are called explicitely, you can change arguments order 
quantile(rdata, na.rm = TRUE, probs = c(0.25, 0.50, 0.75))
```


It is advisable to use the help command of each function to understand not only the arguments which can be used as function inputs, but also the output:
  
```{r, help3, eval=F}
help(read.table)
```

or

```{r, help4, eval=F}
?read.table
```

<!--

## Mathematical Functions

The names of the basic functions and mathematical operators in R follow the standards of programming languages. In this paragraph the functions and operators enabling basic mathematical operations to be performed will be dealt with. R can also be used to perform more complex calculations, such as matrix operations or calculations with complex numbers.

Functions are usually applied to one or more vectors. In this case, operations are performed on each element of each vector. Vectors have to be the same length.

```{r, operations}
x = 1:10
y = 11:20
z = -4:5
x + y + z
exp(x)
log(z)
abs(z)
sqrt(x)
```

The `sum()` function calculates the sum of all the elements of a vector.

```{r, sum}
sum(x)
```

The `floor`, `ceiling`, `trunc` and `round` functions can be used to round a number. `floor()` returns a numeric vector containing the largest integers not greater than the corresponding input elements. `ceiling()` returns a numeric vector containing the smallest integers not less than the corresponding input elements. `trunc()` returns a numeric vector containing the integers formed by truncating the input values toward 0. `round()` rounds the values in its first argument to the specified number of decimal places (default 0).

```{r, round}
floor(3.14)
floor(3.67)
ceiling(3.14)
ceiling(3.67)
trunc(3.14)
trunc(3.67)
round(3.14, digits = 1)
round(3.19, digits = 1)
```


## Probabilistic Functions

Probabilistic functions in R fall into four categories:

 1. `r*` functions for generating random numbers,
 2. `d*` functions for calculating the value of the density function in a point,
 3. `p*` functions for calculating the cumulative distribution function,
 4. `q*` functions for calculating quantiles.

The asterisk indicates the distribution which is used: `norm` for normal distribution, `t` for Student's t-distribution, `binom` for binomial distribution, `gamma` distribution, `beta` distribution, `weibull` distribution, etc. R integrates numerous statistical distributions. The list of all the probability distributions included in the base R can be obtained by typing `help(Distributions)`. Other probability distributions become available when loading additional packages.

The following functions:
```{r, random}
rnorm(n = 10)
rnorm(n = 20, mean = 3, sd = 5)
rbinom(n = 50, size = 20, prob = 0.8)
rweibull(n = 30, shape = 5, scale = 3)
```
generate, respectively:

 - 10 pseudorandom values from a normal distribution with parameters (0, 1);
 - 20 pseudorandom values from a normal distribution with parameters (3, 5);
 - 50 pseudorandom values from a binomial distribution with $n = 20$ and $\pi = 0.8$;
 - 50 pseudorandom values from a Weibull distribution with parameters (5, 3).

The following functions:
```{r, density}
dbinom(x = 20, size = 20, prob = 0.8)
dnorm(x = -5:5, mean = 0, sd = 1)
```
calculate, respectively:

 - the probability that `x` is equal to 20, if `x` is distributed as a binomial distribution with $n = 20$ and $\pi = 0.8$;
 - thee values of the density function of a standard normal for integer values comprised between -5 and 5. As expected, the highest value is obtained with 0. 

The following functions:
```{r, cdf}
pnorm(q = 0, mean = 0, sd = 1)
pbinom(q = 20, size = 20, prob = 0.8)
```
calculate, respectively:

 - the value of the cumulative distribution function of a standard normal distribution at zero; as expected the result is 0.5.
 - the value of a cumulative distribution function of a binomial distribution with parameters $n = 20$ and $\pi = 0.8$ at 20; as expected, the result is 1.

The following functions:
```{r, quantiles}
qnorm(p = 0.5, mean = 0, sd = 1)
qbinom(p = 0.5, size = 20, prob = 0.8)
```
calculate, respectively:

 - the quantile with which a 0.5 probability on the left is obtained in a standard normal distribution;
 - The quantile with which a 0.5 probability on the left is obtained in a binomial distribution with parameters $n = 20$ and $\pi = 0.8$.


## Statistical Functions

Any kind of statistical analysis can be performed in R thanks to the built-in functions of the base version or the numerous additional packages. The functions enabling the calculation of the main descriptive statistical analyses are explained below.
 
The `mean()`, `median()`, `sd()` and `var()` functions are used to calculate the mean, the median, the sample standard deviation and the sample variance of a numeric vector. 

```{r, stats}
x = mtcars$mpg
mean(x)
median(x)
sd(x)  
var(x)
```

The `quantile()` function calculates one or more quantiles.

```{r, quantile}
quantile(x, .9) 
quantile(x, c(.3, .84))
quantile(x, c(.25, .50, .75))
```

The `min()` and `max()` functions return the minimum and maximum  value respectively.

```{r, minmax}
min(x)
max(x)
```

The `summary()` generic function applied to a numeric vector returns minimum, maximum, quartiles and arithmetic mean.

```{r, summary}
summary(x)
```

Correlation and covariance can be calculated with the `cor()` and `cov()` functions, respectively.

```{r, corcov}
data = mtcars[, c(1, 3, 4, 5, 6)]
cor(data)
cov(data)
```

-->

## Function Structure

When working with R we all make constant use of functions and, when developing, we create new functions so that functions look like very familiar R objects. Nevertheless, understanding the theory and the rationals underlying R functions may help to create much more efficient and possibly elegant coding.

We can create and assign functions to a variable name as we do with any other object:

```{r functions-create}
f <- function(x, y = 0) {
  z <- x + y
  z
}
```

Eventually, we can delete any function with the usual call to `rm()` or `remove()`

Functions are objects with three basic components: 

* a formal arguments list
* a body
* an environment. 

```{r functions-002}
formals(f)
body(f)
environment(f)
```


### Formals
Formals are the formal arguments of a function.
<!--
Formals are the formal arguments of a function returned as an object of class `pairlist` where a `pairlist` can be thought as something similar to a list with an important difference:

```{r functions-formals-pairlist}
is.null(pairlist())
is.null(list())
```

that is: a `pairlist` of length zero is `NULL` while a `list` is not.
-->

When we call a function, formals arguments can be specified by position or by name and we can mix positional matching with matching by name so that the following are equivalent:

```{r functions-formals-argument}

mean(x = 1:5, trim = 0.1)
mean(1:5, trim = 0.1)
mean(x = 1:5, 0.1)
mean(1:5, 0.1)
mean(trim = 0.1, x = 1:5)
```

Along with position and name, we can also specify formals by partial matching so that:

```{r functions-formals-argument2}
mean(1:5, tr = 0.1)
mean(tr = 0.1, x = 1:5)
```

would work anyway.

Functions formals may also have the construct `symbol = default`, that unless differently specified, forces any argument to be used with its default value.

Specifically, function `mean()` also have a third argument `na.rm` that defaults to `FALSE` and, as a result passing vectors with `NA` values to `mean()` returns `NA`

```{r functions-formals-arguments3}
mean(c(1, 2, NA))
```

While, by specifying `na.rm=TRUE` we get the mean of all non missing elements of vector `x`.

```{r functions-formals-arguments4}
mean(c(1, 2, NA), na.rm = TRUE)
```

The order `R` uses for matching formals against value is:

1. Check for exact match for a named argument
2. Check for a partial match
3. Check for a positional match

<!--
Formals of a function are normally used within functions by the internal `R` evaluator but, we can use function `formals()` to expose formals explicitly. 

```{r functions-formals-f}
formals(f)
```

`args()` is an other function that displays the formals in a more user friendly fashion. Actually, `args(fun)` returns a function with the same arguments as `fun` but with an empty body.  

```{r functions-formals-args}
args(f)
```


Surely, for programming purposes, `formals()` is a better choice as it returns a simple `pairlist` that can be handled as a list:

```{r functions-formals-list}
is.list(formals(mean))
```

The "`...`" argument of a function is a special argument and can contain any number of `symbol=value` arguments. The "`...`" argument is transformed by `R` into a list that is simply added to the `formals` list:

```{r functions-dots}
h <- function (x, ...) {0}
formals(h)
```

The "`...`" argument can be used if the number of arguments is unknown. Suppose we want to define a function that counts the number of rows of any given number of data frames we could write:

```{r functions-dots2}
count_rows <- function(...) {
  list <- list(...)
  lapply(list, nrow)
}

count_rows(airquality, cars)
```

Similarly, the "`...`" arguments becomes very handy when the "`...`" arguments will be passed on to another function as it often happened when calling `plot()` from within another function. The following example shows a basic plot function used for depths plotting where additional graphics parameters are passed via "`...`":

```{r functions-dots3, fig.height=7, fig.width=7}
time <-  1:13
depth <-  c(0,9,18,21,21,21,21,18,9,3,3,3,0)

plot_depth <-  function ( time , depth , type = "l", ...){
  plot(time, -depth, type = type, 
       ylab = deparse(substitute(depth)), ...)
}
par(mfrow = c(1, 2))
plot_depth(time, depth, lty = 2)
plot_depth(time, depth, lwd = 4, col = "red")
```
-->

### Body of a function

The body of a function is a parsed R statement. In practice, this implies that the body of a function needs to be correct from a formal point of view but no evaluation of the body of a function occurred yet. 

As a result, this function would return an error:

```{r functions-body-wrong, eval=FALSE}
wrong <- function(x) {x =}
```

as its body is not a correct `R` statement.

While this function:

```{r functions-body-right}
right <- function(x){x+h}
```

is accepted by `R` as is formally correct even thought, except under specific circumstances, will always return an error:

```{r functions-body-right-error, error=TRUE}
right(x = 2)
```

The body of a function, is usually a collection of statements in braces but it can be a single statement, a symbol or even a constant.

### Environment of a function
Environments are a fundamental concept in R and their knowledge is essential for advanced programming.
<!--
Environments are not threated here, but the following fundamental concepts:
-->
Environments have the following fundamental concepts:

 * The environment of a function is the environment that was active at the time that the function was created. Generally, for user defined function, the Global environment:

    ```{r functions-environment-userdefined}
    f <- function(x){x+1}
    environment(f)
    ```
    or, when a function is defined within a package, the environment associated to that package:

    ```{r functions-environment-package}
    environment(mean)
    ```

 * Objects defined within a function, exists in the environment of the function itself.
 
    ```{r functions-environment-global, error=TRUE}
    f <- function(x){x+1}
    x
   ```

## Writing a function

A function in R can be defined with the `function()` function. Its use can be summed up as follows:
  
```{r functions-writing2}
my_function <- function(a, b, c) {...}
```

* `my_function` is the name of the customised function 
* `a`, `b` and `c` are the arguments of `my_function()` 
* the part in curly brackets contains the definition of the function

It is good practice to end the function specifying its output with the `return()` or `invisible()` functions (inside curly brackets). The function output ought to be made of a single object. If there are multiple objects, they can be inserted in a list. 

Let us see some examples.  

The following function squares an incoming argument. The function below takes the argument `x` and multiplies it by itself. It saves this value into the object called `square`, and then it returns the value of the object `square`.

```{r functions-writing-example1, tidy=FALSE}
# Function definition
compute_square <- function(x) {
    square <- x * x
    return(square)
}


compute_square(2)
compute_square(24)
```


The following function calculates taxable income and taxes, given the total and the VAT percentage.

```{r functions-writing-example2, tidy=FALSE}
# Function definition
vat <- function(amount, rate = 0.21) {
  taxable = amount / (1 + rate)
  tax = amount - taxable
  return(list(tax = tax, taxable = taxable))
}

vat(121)
vat(104, rate = 0.04)
```

The value assigned to the `rate` argument is the default value assumed by the argument itself.

   
<!--

## Summary
> In this chapter, we showed the most common object types within R. We introduced the main features of each object type and how get a subset of data. Vector is the "basic" object. You can have a numeric, character or logical vector. Matrices are generalisation of vectors. Lists are more complex data type: they collect in a single object several other objects. A factor is a vector-like object used to specify a discrete classification (grouping) of the components of other vectors of the same length. Data frame is a very well-know structure in statistics. It looks like a matrix, but each column can contain different types of data. Its different kinds of information are organised in columns, whereas rows represent different types of observational units. Now that you know the several object types of R, it's time to get your data into the mix. 
In the next chapter, we'll look how to import data into and export data from R from text files, other programs, and database management systems.

-->