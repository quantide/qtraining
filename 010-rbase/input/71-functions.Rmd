---
title: "Writing R functions"
output: html_document
---

<!--
## Function Object

Functions are one of the most important objects in R.

A function is characterised by an input and an output. The input of the function, i.e. the set of the arguments, can be either null or made of one or more R objects. The output of the function can be either null or a single R object. If the function has to return more than one object, the objects are to be inserted in a list.

The function `ls()` doesn't require any input and returns an output.

```{r, argument1}
ls()
```

The function `rm()` requires an input and doesn't return an output.

```{r, argument2}
foo <- 3
rm(foo)
```

Usually, functions require an input and returns an output.

```{r, argument3}
sum(1:10)
```

The several elements of the input of a function are the arguments of the function. When a function is called the arguments can be declared explicitely or implicitely. The arguments can be explicitely with their name.

```{r, argument4}
sum(c(1, 2, NA), na.rm = TRUE)
```
In the above example, the `na.rm` argument of the `sum()` function is called explicitely.

When arguments are called implicitely, the order of the arguments is fundamental. The third example of the code below returns a wrong result.

```{r, argument5}
rdata <- c(rnorm(100), NA)
quantile(x = rdata, probs = c(0.25, 0.50, 0.75), na.rm = TRUE)
quantile(rdata, c(0.25, 0.50, 0.75), TRUE)
quantile(rdata, TRUE, c(0.25, 0.50, 0.75))
# When arguments are called explicitely, you can change arguments order 
quantile(rdata, na.rm = TRUE, probs = c(0.25, 0.50, 0.75))
```


It is advisable to use the help command of each function to understand not only the arguments which can be used as function inputs, but also the output:
  
```{r, help3, eval=F}
help(read.table)
```

or

```{r, help4, eval=F}
?read.table
```


## Function Structure

When working with R we all make constant use of functions and, when developing, we create new functions so that functions look like very familiar R objects. Nevertheless, understanding the theory and the rationals underlying R functions may help to create much more efficient and possibly elegant coding.

We can create and assign functions to a variable name as we do with any other object:

```{r functions-create}
f <- function(x, y = 0) {
  z <- x + y
  z
}
```

Eventually, we can delete any function with the usual call to `rm()` or `remove()`

Functions are objects with three basic components: 

* a formal arguments list
* a body
* an environment. 

```{r functions-002}
formals(f)
body(f)
environment(f)
```


### Formals
Formals are the formal arguments of a function.
<!--
Formals are the formal arguments of a function returned as an object of class `pairlist` where a `pairlist` can be thought as something similar to a list with an important difference:

```{r functions-formals-pairlist}
is.null(pairlist())
is.null(list())
```

that is: a `pairlist` of length zero is `NULL` while a `list` is not.


When we call a function, formals arguments can be specified by position or by name and we can mix positional matching with matching by name so that the following are equivalent:

```{r functions-formals-argument}

mean(x = 1:5, trim = 0.1)
mean(1:5, trim = 0.1)
mean(x = 1:5, 0.1)
mean(1:5, 0.1)
mean(trim = 0.1, x = 1:5)
```

Along with position and name, we can also specify formals by partial matching so that:

```{r functions-formals-argument2}
mean(1:5, tr = 0.1)
mean(tr = 0.1, x = 1:5)
```

would work anyway.

Functions formals may also have the construct `symbol = default`, that unless differently specified, forces any argument to be used with its default value.

Specifically, function `mean()` also have a third argument `na.rm` that defaults to `FALSE` and, as a result passing vectors with `NA` values to `mean()` returns `NA`

```{r functions-formals-arguments3}
mean(c(1, 2, NA))
```

While, by specifying `na.rm=TRUE` we get the mean of all non missing elements of vector `x`.

```{r functions-formals-arguments4}
mean(c(1, 2, NA), na.rm = TRUE)
```

The order `R` uses for matching formals against value is:

1. Check for exact match for a named argument
2. Check for a partial match
3. Check for a positional match


### Body of a function

The body of a function is a parsed R statement. In practice, this implies that the body of a function needs to be correct from a formal point of view but no evaluation of the body of a function occurred yet. 

As a result, this function would return an error:

```{r functions-body-wrong, eval=FALSE}
wrong <- function(x) {x =}
```

as its body is not a correct `R` statement.

While this function:

```{r functions-body-right}
right <- function(x){x+h}
```

is accepted by `R` as is formally correct even thought, except under specific circumstances, will always return an error:

```{r functions-body-right-error, error=TRUE}
right(x = 2)
```

The body of a function, is usually a collection of statements in braces but it can be a single statement, a symbol or even a constant.

### Environment of a function
Environments are a fundamental concept in R and their knowledge is essential for advanced programming.
<!--
Environments are not threated here, but the following fundamental concepts:

Environments have the following fundamental concepts:

 * The environment of a function is the environment that was active at the time that the function was created. Generally, for user defined function, the Global environment:

    ```{r functions-environment-userdefined}
    f <- function(x){x+1}
    environment(f)
    ```
    or, when a function is defined within a package, the environment associated to that package:

    ```{r functions-environment-package}
    environment(mean)
    ```

 * Objects defined within a function, exists in the environment of the function itself.
 
    ```{r functions-environment-global, error=TRUE}
    f <- function(x){x+1}
    x
   ```

## Writing a function
-->

One of the great strengths of R is the user's ability to add functions. Indeed, each one of us can write his/her own functions following simple rules.  
A function in R can be defined with the `function()` function. Its use can be summed up as follows:
  
```{r functions-writing2}
my_function <- function(a, b, c) {
  statements
  return(object)
  }
```

* `my_function` is the name of the customised function 
* `a`, `b` and `c` are the arguments of `my_function()` 
* the part in curly brackets contains the definition of the function, that is a body of code that does one or more operations

It is good practice to end the function specifying its output with the `return()` or `invisible()` functions (inside curly brackets). The function output ought to be made of a single object. If there are multiple objects, they can be inserted in a list. 

Let us see some examples.  

The following function, `compute_square`, squares an incoming argument. It takes the argument `x` and multiplies it by itself. It saves this value into the object called `square`, and then it returns the value of the object `square`.

```{r functions-writing-example1, tidy=FALSE}
# Function definition
compute_square <- function(x) {
    square <- x * x
    return(square)
}


compute_square(2)
squared_num <- compute_square(24)
squared_num
```


The following function, `vat`,  calculates taxable income and taxes, given the total and the VAT percentage.

```{r functions-writing-example2, tidy=FALSE}
# Function definition
vat <- function(amount, rate = 0.21) {
  taxable = amount / (1 + rate)
  tax = amount - taxable
  return(list(tax = tax, taxable = taxable))
}

vat(121)
vat(104, rate = 0.04)
```

You can also specify a default value for function arguments, as for `rate` argument of the previous function. This value will be always used for the argument itself unless than different specification. 

   
<!--

## Summary
> In this chapter, we showed the most common object types within R. We introduced the main features of each object type and how get a subset of data. Vector is the "basic" object. You can have a numeric, character or logical vector. Matrices are generalisation of vectors. Lists are more complex data type: they collect in a single object several other objects. A factor is a vector-like object used to specify a discrete classification (grouping) of the components of other vectors of the same length. Data frame is a very well-know structure in statistics. It looks like a matrix, but each column can contain different types of data. Its different kinds of information are organised in columns, whereas rows represent different types of observational units. Now that you know the several object types of R, it's time to get your data into the mix. 
In the next chapter, we'll look how to import data into and export data from R from text files, other programs, and database management systems.

-->