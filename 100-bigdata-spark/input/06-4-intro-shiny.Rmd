---
title: "Building Shiny Apps"
output: html_document
---

```{r options, include=FALSE, purl=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, fig.pos = 'H', fig.width = 8, fig.height = 5)
options(width = 108)
```



## Introduction to Shiny


Shiny is a package from RStudio that allows you to easily build interactive web pages with R. You will be able interact and display any R objects: plots, tables, etc. Online resources on Shiny are as rich as you can image. To get a glimpse of the many things you can build with Shiny, out of the many websites with Shiny examples, we suggest you visit https://daattali.com/shiny/ and https://shiny.rstudio.com/gallery/.


If you want to find additional material, you may visit the RStudio official Shiny page https://shiny.rstudio.com/ and we suggest you always keep the [Shiny cheat sheet](http://shiny.rstudio.com/images/shiny-cheatsheet.pdf) on hand when you are developing your Shiny app!



### Required R packages

Before we begin you need to install `Shiny` package:

```{r, eval = FALSE}
install.packages("shiny")
```

To ensure you successfully installed Shiny, try running one of the demo apps.

```{r, eval = FALSE}
library(shiny)
runExample("01_hello")
```

If the example app is running, press Escape to close the app, and you are ready to build your first Shiny app!


## Basic concepts

The first thing you need to know is that every Shiny app is composed of two parts: 

* a _web page_ that shows the app to the user and that the user interacts with
* a _computer_ that runs the functions that create the output to be visualised in the webpage 

Notice that in this course "the computer" will be your own laptop, although most likely when you want other users to use your app, it will run on a server somewhere else. 

In `Shiny` terminology, the two parts are called _user interface (ui)_ and _server_: 

* the _ui_ contains the functions that show the layout of the app and that allow you to interact with the app; here you need to indicate where you want your plots to be showed, where you want to include a drop down menu, how many tabs you want, etc

* the _server_ is where plots and tables are generated, here you will add all the types of outputs you want to show, you will need to indicate which colour you want your plot, whether the data to be plotted is filtered by specific characteristics, what kind of tables you want, etc

You need to build both of them separately and they will be run together when you run the shiny app in order to compose the app.


## Building the first Shiny app

Following the above structure, let us initialise the first Shiny App. Create a new folder where you will pace your shiny app. It is good practice that the app is contained in its own folder and no code besides that of the app, should go in it. Copy the following code lines into a new file named `app.R` in the folder where you will build your shiny app:

```{r my-first-shiny-app, eval = FALSE}
library(shiny)

ui <- fluidPage()
server <- function(input, output) {}

shinyApp(ui = ui, server = server)
```

More specifically we initialised an empty web page (ui) and an empty server.

Notice that once you save the file as `app.R`, the latest RStudio recognizes that you are building a Shiny app, and, at the top right of you code, you should see the Run button change to Run App.

If you click the Run App button, your app should run. As we are just building an empty app, all you see is a new window appearing and the console with a text similar to this:

`Listening on http://127.0.0.1:7118`

This means that R is currently busy as it is powering a Shiny app and is waiting (listening) for user interaction. In this case, of course, no user interaction will happen as the ui contains a blank page and we have not programmed any interactive parts. In fact, our `ui` function is empty and so is the `server`.

If you click the stop button the app will stop.

Now, let us spend a couple of words on the functions we are using. `fluidPage()` creates a page with fluid layout which consists of rows that include columns. Rows make sure their elements appear on the same line (if the browser has adequate width), while columns define how much horizontal space within a _12-unit wide grid_ elements should occupy. When you build the user interface, all you will be doing is passing comma-separated elements to the `fluidPage()` function.

`server` is initialised as a function taking two arguments: input and output. This structure is always the same, we will come back to it when we will walk you through the creation of the server functions.

### Separate ui and server functions

When the app gets more complicated, it is a good practice to work on separate files so that you have the `ui.R` file containing all the code that is assigned to the ui variable, and the `server.R` file containing all the code assigned to the server function. 

When RStudio sees these two files in the same folder, it will know youâ€™re writing a Shiny app. If you use this method (instead of having one `app.R` file), then you do not need to include the `shinyApp(ui = ui, server = server)` line.



### Building the first shinydashboard

`shinydashboard` is a package that provides a theme on top of 'Shiny'. The structure is the same as the one seen so far: you have a _ui_ and a _server_ function, but it allows for a better graphical layout.

First of all, the dashboard is defined as having three parts: a header, a sidebar, and a body. 

To initialise an empty `shinydashboard`, use the following code:

```{r shinydashboard}
library(shiny)
library(shinydashboard)
 
ui <- dashboardPage(
     dashboardHeader(),
     dashboardSidebar(),
     dashboardBody()
)
 
server <- function(input, output) { }
 
shinyApp(ui, server)
```

Again, you will notice that the `R` session is busy listening to user's interactions. Note also, that differently from before, we were forced to include some sort of layout: in fact, together with `dashboardPage`, we had to add `dashboardHeader()`, `dashboardSidebar()` and `dashboardBody()`. The app does not run if you do not add these three.



## Shiny and Spark

In the global part we open the Spark Context, and read the data. The aggregation of data depends from an UI input, so it has been placed in the Server function, because it is re-calculated each time the input changes.

```{r}

# global --------
library(shiny)
library(shinydashboard)
library(sparklyr) 
library(ggplot2)
library(dplyr)

sc <- spark_connect( master = "local", version = "2.0.0" )

csv_file <- "/data/2008.csv"

 ## read data
spark_table <- spark_read_csv(
	sc = sc,
	name = "year2008",
	path = csv_file
)


# ui --------
ui <- dashboardPage(
	dashboardHeader(),
	dashboardSidebar(
		numericInput('minCount', label = "Minimun count", step = 5, value = 20)
	),
	dashboardBody(
		plotOutput('plot')
	)
)

# server -------
server <- function(input, output) { 
	
	output$plot <- renderPlot({
		## Collect some data
		delay <-
			spark_table %>% 
			group_by(TailNum) %>%
			summarise(count = n(), dist = mean(Distance), delay = mean(ArrDelay)) %>%
			filter(count > input$minCount, dist < 2000, !is.na(delay)) %>%
			collect()
		## Plot delays
		ggplot(delay, aes(dist, delay)) +
			geom_point(aes(size = count), alpha = 1/2) 
	})
}

# run --------
shinyApp(ui, server)
```


