---
title: "Each"
---

```{r options, include=FALSE, purl=FALSE}
source("options.R")
```

```{r first, include=FALSE, purl=TRUE, message=FALSE}
# This code chunk contains R code already described in the previous chapters
# that is required by following examples
require(dplyr)
require(qdata)
data(mtcars)
```


# Controlling `dplyr`

When using `dplyr` to manipulate data, you have three factors to control:

1. how many variables to manipulate
2. how many functions to apply to each variable 
3. the length of functions results 

In more details:

1. how many variables to manipulate:
  + 1A. single variable
  + 1B. more than a variable 

2. how many functions to apply to each variable :
  + 2A. single function  
  + 2B. more than one function 

3. the length of functions results :
  + 3A. a single value: i.e. `mean()`, `max()`, `min()`, etc ... 
  + 3B. `n` values: i.e. `order()`, `rescale()`, etc ...

For a totale result of eigth cases.

<!--------------------- res == 1 ------------------------------------>
## Functions Returning Results of Length One

There are four cases:

* case 1: apply one function to one variable
* case 2: apply many functions to one variable
* case 3: apply one function to many variables
* case 4: apply many functions to many variables

We will test them by using two `dplyr` verbs:

1. `summarise()`
2. `summarise_each()`

We will also test them under the three options provided by the `group_by()` verb: 

A.  `group_by()` is not used group: no groups 
B.  `group_by(g)` is used on a single variable: one group 
C.  `group_by(g1, g2, ..., gk)` is used on more than one variables: many groups 

For a total of $8 \times 3 = 24$ tests.


### Case 1: Apply One Function to One Variable

In this case, `summarise()` results the simplest candidate:

```{r}
# without groups
mtcars %>% 
  summarise(mean_mpg = mean(mpg))

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise(mean_mpg = mean(mpg))

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise(mean_mpg = mean(mpg))
```

You could use function `summarise_each()` as well, but its usage results in a loss of clarity:

```{r}
# without groups
mtcars %>% 
  summarise_each(funs(mean), mean_mpg = mpg)

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise_each(funs(mean), mean_mpg = mpg)

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise_each(funs(mean), mean_mpg = mpg)
```


### Case 2: Apply Many Functions to One Variable

In this case you can use both functions `summarise()` and `summarise_each()`.  

Function `summarise()` has a more intuitive syntax:

```{r}
# without groups
mtcars %>% 
  summarise(min_mpg = min(mpg), max_mpg = max(mpg))

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise(min_mpg = min(mpg), max_mpg = max(mpg))

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise(min_mpg = min(mpg), max_mpg = max(mpg))
```

The names of the output variables can be specified in simple forms like: `max_mpg = max(mpg)`.

When you apply many functions to one variable, the use of `summarise_each()` provides a more compact and tidy notation:

```{r}
# without groups
mtcars %>% 
  summarise_each(funs(min, max), mpg)

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise_each(funs(min, max), mpg)

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise_each(funs(min, max), mpg)
```

The default names of the output variables are given by the names of the functions: `min` and `max`.

In this case you lose track of the name of the variable the functions are applied to.

If you prefer something like `min_mpg` and `max_mpg`, you shall appropriately rename the __functions__ you call within `funs()`:

```{r}
# without groups
mtcars %>% 
  summarise_each(funs(min_mpg = min, max_mpg = max), mpg)

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise_each(funs(min_mpg = min, max_mpg = max), mpg)

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise_each(funs(min_mpg = min, max_mpg = max), mpg)
```


### Case 3: Apply One Function to Many Variables

This case is very similar to case 2. Both functions `summarise()` and `summarise_each()` can be used.

Function `summarise()` has again a more intuitive syntax and the names of output variables can be specified in the usual simple form: `max_mpg = max(mpg)`.

```{r}
# without groups
mtcars %>% 
  summarise(mean_mpg = mean(mpg), mean_disp = mean(disp))

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise(mean_mpg = mean(mpg), mean_disp = mean(disp))

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise(mean_mpg = mean(mpg), mean_disp = mean(disp))
```

When you apply one function to many variables, the use of `summarise_each()` provides a more compact and tidy notation:

```{r}
# without groups
mtcars %>% 
  summarise_each(funs(mean), mpg, disp)

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise_each(funs(mean), mpg, disp)

# with  more than group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise_each(funs(mean), mpg, disp)
```

The default names of the output variables are given by the names of the variables: `mpg` and `disp`.

In this case you lose track of the name of the function applied to the variables.

If you prefer something like `mean_mpg` and `mean_disp`, you shall appropriately rename the __variables__ you pass to `...` within `summarise_each()`:

```{r}
# without groups
mtcars %>% 
  summarise_each(funs(mean), mean_mpg = mpg, mean_disp = disp)

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise_each(funs(mean), mean_mpg = mpg, mean_disp = disp)

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise_each(funs(mean), mean_mpg = mpg, mean_disp = disp)
```


### Case 4: Apply Many Functions to Many Variables

As in the previous cases both functions: `summarise()` and `summarise_each()` provide a valid alternative.

Function `summarise()` has again a more intuitive syntax and the names of output variables can be specified in the usual simple form: `max_mpg = max(mpg)`.

```{r}
# without groups
mtcars %>% 
  summarise(min_mpg = min(mpg), min_disp = min(disp), max_mpg = max(mpg), max_disp = max(disp))

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise(min_mpg = min(mpg), min_disp = min(disp), max_mpg = max(mpg), max_disp = max(disp))

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise(min_mpg = min(mpg), min_disp = min(disp), max_mpg = max(mpg), max_disp = max(disp))
```

When you apply many functions to one variable, the use of `summarise_each()` provides a more compact and tidy notation:

```{r}
# without groups
mtcars %>% 
  summarise_each(funs(min, max), mpg, disp)

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise_each(funs(min, max), mpg, disp)

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise_each(funs(min, max), mpg, disp)
```

The names of the output variables are given by the notation `variable_function`, i.e. `mpg_min`, `disp_min`, etc.

Naming output variables with a different notation, i.e. `function_variable`, does not appear to be possible within the call to `summarise_each()`.

This goal has to be achieved with a separate instruction:

```{r}
# without groups
mtcars %>% 
  summarise_each(funs(min, max), mpg, disp) %>%
  setNames(c("min_mpg", "min_disp", "max_mpg", "max_disp"))

# with one group
mtcars %>% 
  group_by(cyl) %>% 
  summarise_each(funs(min, max), mpg, disp) %>%
  setNames(c("cyl", "min_mpg", "min_disp", "max_mpg", "max_disp"))

# with more than one group
mtcars %>% 
  group_by(cyl, carb) %>% 
  summarise_each(funs(min, max), mpg, disp) %>%
  setNames(c("cyl", "carb", "min_mpg", "min_disp", "max_mpg", "max_disp"))
```


<!--------------------- res == n ------------------------------------>

## Functions Returning Results of Length `n`

Also here there are four cases: 

* Case 5: apply one function to one variable
* Case 6: apply many functions to one variable
* Case 7: apply one function to many variables
* Case 8: apply many functions to many variables

We will test them by using two `dplyr` verbs:

1. `mutate()`
2. `mutate_each()`

Each of them tested under the three options provided by the `group_by()` verb: 

A.  `group_by()` is not used: no groups 
B.  `group_by(g)` is used on a single variable: one group 
C.  `group_by(g1, g2, ..., gk)` is used on more than one variables: many groups 

For a total of $8 \times 3 = 24$ tests.


### The Value of `n`

The `group_by()` option has an impact on the value of `n`:

* when there is no group variable `n` is the number of records in the whole data frame:

```{r}
mtcars %>% summarise(n = n())
```

* when there is one group variable `n` is the number of records within each level of the group variable:

```{r}
mtcars %>% group_by(carb) %>% summarise(n = n())
```

* when there are many group variables `n` is the number of records within each combination of levels of group variables:

```{r}
mtcars %>% group_by(carb, cyl) %>% summarise(n = n())
```

For the next examples we will use two functions: 

* `order()`: as from base `R` 
* `rescale()`: defined as:

```{r}
rescale <- function(x){
  x <- x - min(x, na.rm = TRUE)
  x/max(x)
}
```

Both functions take `x` of length `n` as input and return a new vector of length `n`. 


### Case 5: Apply One Function to One Variable

As you expect results of length `n`, function `mutate()` is the candidate function:

```{r}
# without groups
mtcars %>% 
  mutate(rescale_mpg = rescale(mpg))

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate(rescale_mpg = rescale(mpg)) 

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate(rescale_mpg = rescale(mpg))
```

You could use function `mutate_each()` as well, but its usage results in a loss of clarity:

```{r}
# without groups
mtcars %>% 
  mutate_each(funs(rescale), rescale_mpg = mpg)

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_each(funs(rescale), rescale_mpg = mpg)

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_each(funs(rescale), rescale_mpg = mpg)
```


### Case 6: Apply Many Functions to One Variable

In this case you can use both functions `mutate()` and `mutate_each()`.  

Function `mutate()` has a more intuitive syntax:

```{r}
# without groups
mtcars %>% 
  mutate(rescale_mpg = rescale(mpg), order_mpg = order(mpg))

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate(rescale_mpg = rescale(mpg), order_mpg = order(mpg)) 

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate(rescale_mpg = rescale(mpg), order_mpg = order(mpg))
```

The names of the output variables can be specified in simple forms like `order_mpg = order(mpg)`.

When you apply many functions to one variable, the use of `mutate_each()` provides a more compact and tidy notation:

```{r}
# without groups
mtcars %>% 
  mutate_each(funs(rescale, order), mpg)

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_each(funs(rescale, order), mpg) 

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_each(funs(rescale, order), mpg)
```

The default names of the output variables are given by the names of the functions: `order` and `rescale`.

In this case you lose track of the name of the variable the functions are applied to.

If you prefer something like `rescale_mpg` and `order_mpg`, you shall appropriately rename the __functions__ you call within `funs()`:

```{r}
# without groups
mtcars %>% 
  mutate_each(funs(rescale_mpg = rescale, order_mpg = order), mpg)

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_each(funs(rescale_mpg = rescale, order_mpg = order), mpg)

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_each(funs(rescale_mpg = rescale, order_mpg = order), mpg)
```


### Case 7: Apply One Function to Many Variables

This case is very similar to case 6. Both functions `mutate()` and `mutate_each()` can be used.

Function `mutate()` has again a more intuitive syntax and the names of output variables can be specified in the usual simple form: `rescale_mpg = rescale(mpg)`.

```{r}
# without groups
mtcars %>% 
  mutate(rescale_mpg = rescale(mpg), rescale_disp = rescale(disp))

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate(rescale_mpg = rescale(mpg), rescale_disp = rescale(disp))

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate(rescale_mpg = rescale(mpg), rescale_disp = rescale(disp))
```

When you apply one function to many variables, the use of `mutate_each()` provides a more compact and tidy notation:

```{r}
# without groups
mtcars %>% 
  mutate_each(funs(rescale), mpg, disp)

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_each(funs(rescale), mpg, disp)

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_each(funs(rescale), mpg, disp)
```

The default names of the output variables are given by the names of the variables: `mpg` and `disp`.

In this case you lose track of the name of the function applied to the variables.

If you prefer something like `rescale_mpg` and `rescale_disp`, you shall appropriately rename the __variables__ you pass to `...` within `mutate_each()`:

```{r}
# without groups
mtcars %>% 
  mutate_each(funs(rescale), rescale_mpg = mpg, rescale_disp = disp)

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_each(funs(rescale), rescale_mpg = mpg, rescale_disp = disp)

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_each(funs(rescale), rescale_mpg = mpg, rescale_disp = disp)
```


### Case 8: Apply Many Functions to Many Variables

As in the previous cases both functions `mutate()` and `mutate_each()` provide a valid alternative.

Function `mutate()` has again a more intuitive syntax and the names of output variables can be specified in the usual simple form: `rescale_mpg = rescale(mpg)`.

```{r}
#  without groups
mtcars %>% 
  mutate(rescale_mpg = rescale(mpg),  order_disp = order(disp))

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate(rescale_mpg = rescale(mpg),  order_disp = order(disp))

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate(rescale_mpg = rescale(mpg),  order_disp = order(disp))
```

When you apply many functions to one variable, the use of `mutate_each()` provides a more compact and tidy notation:

```{r}
# without groups
mtcars %>% 
  mutate_each(funs(rescale, order), mpg,  disp)

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_each(funs(rescale, order), mpg,  disp)

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_each(funs(rescale, order), mpg,  disp)
```

The names of the output variables are given by the notation `variable_function`, i.e. `mpg_rescale`, `disp_rescale`, etc.

Naming output variables with a different notation, i.e. `function_variable`, does not appear to be possible within the call to `mutate_each()`.

This goal has to be achieved with a separate instruction:

```{r}
# without groups
mtcars %>% 
  mutate_each(funs(rescale, order), mpg,  disp) %>% 
  rename(rescale_mpg = mpg_rescale, rescale_disp = disp_rescale, order_mpg = mpg_order, order_disp = disp_order)

# with one group
mtcars %>% 
  group_by(carb) %>% 
  mutate_each(funs(rescale, order), mpg, disp) %>% 
  rename(rescale_mpg = mpg_rescale, rescale_disp = disp_rescale, order_mpg = mpg_order, order_disp = disp_order)

# with more than one group
mtcars %>% 
  group_by(carb, cyl) %>% 
  mutate_each(funs(rescale, order), mpg, disp) %>%
  rename(rescale_mpg = mpg_rescale, rescale_disp = disp_rescale, order_mpg = mpg_order, order_disp = disp_order)
```


# Conclusions

You have two alternatives to functions `summarise()` and `mutate()`: `summarise_each()` and `mutate_each()` respectively.

Functions `summarise()` and `mutate()` have a simpler syntax while functions `summarise_each()` and `mutate_each()` have a more compact notation. 

As a consequence, `summarise()` and `mutate()`  seem more appropriate when dealing with a single variable or a single function. The more the number of variables or  functions increases,  the more `summarise_each()` and `mutate_each()` become a better choice.  

Functions `summarise_each()` and `mutate_each()` have their own way to assign names to output variables:

* apply many functions to one variable: the names of the output variables are given by the name of the __functions__.  In this case you lose the name of the variable the function is applied to;

* apply one function to many variables: the names of the output variables are given by the name of the __variables__.  In this case you lose track of the name of the function applied to the variables;

* apply many functions to many variables: the names of the output variables are given by the notation: __variable_function__. Naming output variables with a different notation does not appear to be possible within the call to `summarise_each()` or `mutate_each()`.

